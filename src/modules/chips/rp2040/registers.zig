// generated using svd2zig.py
// DO NOT EDIT
// based on RP2040 version 0.1
const mmio = @import("microzig-mmio").mmio;
const Name = "RP2040";
pub const XIP_CTRL = extern struct {
    pub const Address: u32 = 0x14000000;
    // byte offset: 0 Cache control
    pub const CTRL = mmio(Address + 0x00000000, 32, packed struct {
        EN: u1, // bit offset: 0 desc: When 1, enable the cache. When the cache is disabled, all XIP accesses\n will go straight to the flash, without querying the cache. When enabled,\n cacheable XIP accesses will query the cache, and the flash will\n not be accessed if the tag matches and the valid bit is set.\n\n If the cache is enabled, cache-as-SRAM accesses have no effect on the\n cache data RAM, and will produce a bus error response.
        ERR_BADWRITE: u1, // bit offset: 1 desc: When 1, writes to any alias other than 0x0 (caching, allocating)\n will produce a bus fault. When 0, these writes are silently ignored.\n In either case, writes to the 0x0 alias will deallocate on tag match,\n as usual.
        reserved0: u1 = 0,
        POWER_DOWN: u1, // bit offset: 3 desc: When 1, the cache memories are powered down. They retain state,\n but can not be accessed. This reduces static power dissipation.\n Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot\n be enabled when powered down.\n Cache-as-SRAM accesses will produce a bus error response when\n the cache is powered down.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 4 Cache Flush control
    pub const FLUSH = mmio(Address + 0x00000004, 32, packed struct {
        FLUSH: u1, // bit offset: 0 desc: Write 1 to flush the cache. This clears the tag memory, but\n the data memory retains its contents. (This means cache-as-SRAM\n contents is not affected by flush or reset.)\n Reading will hold the bus (stall the processor) until the flush\n completes. Alternatively STAT can be polled until completion.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 8 Cache Status
    pub const STAT = mmio(Address + 0x00000008, 32, packed struct {
        FLUSH_READY: u1, // bit offset: 0 desc: Reads as 0 while a cache flush is in progress, and 1 otherwise.\n The cache is flushed whenever the XIP block is reset, and also\n when requested via the FLUSH register.
        FIFO_EMPTY: u1, // bit offset: 1 desc: When 1, indicates the XIP streaming FIFO is completely empty.
        FIFO_FULL: u1, // bit offset: 2 desc: When 1, indicates the XIP streaming FIFO is completely full.\n The streaming FIFO is 2 entries deep, so the full and empty\n flag allow its level to be ascertained.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 12 Cache Hit counter\n A 32 bit saturating counter that increments upon each cache hit,\n i.e. when an XIP access is serviced directly from cached data.\n Write any value to clear.
    pub const CTR_HIT = mmio(Address + 0x0000000c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 16 Cache Access counter\n A 32 bit saturating counter that increments upon each XIP access,\n whether the cache is hit or not. This includes noncacheable accesses.\n Write any value to clear.
    pub const CTR_ACC = mmio(Address + 0x00000010, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 20 FIFO stream address
    pub const STREAM_ADDR = mmio(Address + 0x00000014, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        STREAM_ADDR: u30, // bit offset: 2 desc: The address of the next word to be streamed from flash to the streaming FIFO.\n Increments automatically after each flash access.\n Write the initial access address here before starting a streaming read.
    });
    // byte offset: 24 FIFO stream control
    pub const STREAM_CTR = mmio(Address + 0x00000018, 32, packed struct {
        STREAM_CTR: u22, // bit offset: 0 desc: Write a nonzero value to start a streaming read. This will then\n progress in the background, using flash idle cycles to transfer\n a linear data block from flash to the streaming FIFO.\n Decrements automatically (1 at a time) as the stream\n progresses, and halts on reaching 0.\n Write 0 to halt an in-progress stream, and discard any in-flight\n read, so that a new stream can immediately be started (after\n draining the FIFO and reinitialising STREAM_ADDR)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
    });
    // byte offset: 28 FIFO stream data\n Streamed data is buffered here, for retrieval by the system DMA.\n This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing\n the DMA to bus stalls caused by other XIP traffic.
    pub const STREAM_FIFO = mmio(Address + 0x0000001c, 32, packed struct {
        raw: u32, // placeholder field
    });
};
pub const XIP_SSI = extern struct {
    pub const Address: u32 = 0x18000000;
    // byte offset: 0 Control register 0
    pub const CTRLR0 = mmio(Address + 0x00000000, 32, packed struct {
        DFS: u4, // bit offset: 0 desc: Data frame size
        FRF: u2, // bit offset: 4 desc: Frame format
        SCPH: u1, // bit offset: 6 desc: Serial clock phase
        SCPOL: u1, // bit offset: 7 desc: Serial clock polarity
        TMOD: enum(u2) { // bit offset: 8 desc: Transfer mode
            @"TX_AND_RX" = 0, // desc: Both transmit and receive
            @"TX_ONLY" = 1, // desc: Transmit only (not for FRF == 0, standard SPI mode)
            @"RX_ONLY" = 2, // desc: Receive only (not for FRF == 0, standard SPI mode)
            @"EEPROM_READ" = 3, // desc: EEPROM read mode (TX then RX; RX starts after control data TX'd)
        },
        SLV_OE: u1, // bit offset: 10 desc: Slave output enable
        SRL: u1, // bit offset: 11 desc: Shift register loop (test mode)
        CFS: u4, // bit offset: 12 desc: Control frame size\n Value of n -> n+1 clocks per frame.
        DFS_32: u5, // bit offset: 16 desc: Data frame size in 32b transfer mode\n Value of n -> n+1 clocks per frame.
        SPI_FRF: enum(u2) { // bit offset: 21 desc: SPI frame format
            @"STD" = 0, // desc: Standard 1-bit SPI frame format; 1 bit per SCK, full-duplex
            @"DUAL" = 1, // desc: Dual-SPI frame format; two bits per SCK, half-duplex
            @"QUAD" = 2, // desc: Quad-SPI frame format; four bits per SCK, half-duplex
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        SSTE: u1, // bit offset: 24 desc: Slave select toggle enable
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
    // byte offset: 4 Master Control register 1
    pub const CTRLR1 = mmio(Address + 0x00000004, 32, packed struct {
        NDF: u16, // bit offset: 0 desc: Number of data frames
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 8 SSI Enable
    pub const SSIENR = mmio(Address + 0x00000008, 32, packed struct {
        SSI_EN: u1, // bit offset: 0 desc: SSI enable
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 12 Microwire Control
    pub const MWCR = mmio(Address + 0x0000000c, 32, packed struct {
        MWMOD: u1, // bit offset: 0 desc: Microwire transfer mode
        MDD: u1, // bit offset: 1 desc: Microwire control
        MHS: u1, // bit offset: 2 desc: Microwire handshaking
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 16 Slave enable
    pub const SER = mmio(Address + 0x00000010, 32, packed struct {
        SER: u1, // bit offset: 0 desc: For each bit:\n 0 -> slave not selected\n 1 -> slave selected
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 20 Baud rate
    pub const BAUDR = mmio(Address + 0x00000014, 32, packed struct {
        SCKDV: u16, // bit offset: 0 desc: SSI clock divider
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 24 TX FIFO threshold level
    pub const TXFTLR = mmio(Address + 0x00000018, 32, packed struct {
        TFT: u8, // bit offset: 0 desc: Transmit FIFO threshold
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 28 RX FIFO threshold level
    pub const RXFTLR = mmio(Address + 0x0000001c, 32, packed struct {
        RFT: u8, // bit offset: 0 desc: Receive FIFO threshold
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 32 TX FIFO level
    pub const TXFLR = mmio(Address + 0x00000020, 32, packed struct {
        TFTFL: u8, // bit offset: 0 desc: Transmit FIFO level
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 36 RX FIFO level
    pub const RXFLR = mmio(Address + 0x00000024, 32, packed struct {
        RXTFL: u8, // bit offset: 0 desc: Receive FIFO level
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 40 Status register
    pub const SR = mmio(Address + 0x00000028, 32, packed struct {
        BUSY: u1, // bit offset: 0 desc: SSI busy flag
        TFNF: u1, // bit offset: 1 desc: Transmit FIFO not full
        TFE: u1, // bit offset: 2 desc: Transmit FIFO empty
        RFNE: u1, // bit offset: 3 desc: Receive FIFO not empty
        RFF: u1, // bit offset: 4 desc: Receive FIFO full
        TXE: u1, // bit offset: 5 desc: Transmission error
        DCOL: u1, // bit offset: 6 desc: Data collision error
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
    });
    // byte offset: 44 Interrupt mask
    pub const IMR = mmio(Address + 0x0000002c, 32, packed struct {
        TXEIM: u1, // bit offset: 0 desc: Transmit FIFO empty interrupt mask
        TXOIM: u1, // bit offset: 1 desc: Transmit FIFO overflow interrupt mask
        RXUIM: u1, // bit offset: 2 desc: Receive FIFO underflow interrupt mask
        RXOIM: u1, // bit offset: 3 desc: Receive FIFO overflow interrupt mask
        RXFIM: u1, // bit offset: 4 desc: Receive FIFO full interrupt mask
        MSTIM: u1, // bit offset: 5 desc: Multi-master contention interrupt mask
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 48 Interrupt status
    pub const ISR = mmio(Address + 0x00000030, 32, packed struct {
        TXEIS: u1, // bit offset: 0 desc: Transmit FIFO empty interrupt status
        TXOIS: u1, // bit offset: 1 desc: Transmit FIFO overflow interrupt status
        RXUIS: u1, // bit offset: 2 desc: Receive FIFO underflow interrupt status
        RXOIS: u1, // bit offset: 3 desc: Receive FIFO overflow interrupt status
        RXFIS: u1, // bit offset: 4 desc: Receive FIFO full interrupt status
        MSTIS: u1, // bit offset: 5 desc: Multi-master contention interrupt status
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 52 Raw interrupt status
    pub const RISR = mmio(Address + 0x00000034, 32, packed struct {
        TXEIR: u1, // bit offset: 0 desc: Transmit FIFO empty raw interrupt status
        TXOIR: u1, // bit offset: 1 desc: Transmit FIFO overflow raw interrupt status
        RXUIR: u1, // bit offset: 2 desc: Receive FIFO underflow raw interrupt status
        RXOIR: u1, // bit offset: 3 desc: Receive FIFO overflow raw interrupt status
        RXFIR: u1, // bit offset: 4 desc: Receive FIFO full raw interrupt status
        MSTIR: u1, // bit offset: 5 desc: Multi-master contention raw interrupt status
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 56 TX FIFO overflow interrupt clear
    pub const TXOICR = mmio(Address + 0x00000038, 32, packed struct {
        TXOICR: u1, // bit offset: 0 desc: Clear-on-read transmit FIFO overflow interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 60 RX FIFO overflow interrupt clear
    pub const RXOICR = mmio(Address + 0x0000003c, 32, packed struct {
        RXOICR: u1, // bit offset: 0 desc: Clear-on-read receive FIFO overflow interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 64 RX FIFO underflow interrupt clear
    pub const RXUICR = mmio(Address + 0x00000040, 32, packed struct {
        RXUICR: u1, // bit offset: 0 desc: Clear-on-read receive FIFO underflow interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 68 Multi-master interrupt clear
    pub const MSTICR = mmio(Address + 0x00000044, 32, packed struct {
        MSTICR: u1, // bit offset: 0 desc: Clear-on-read multi-master contention interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 72 Interrupt clear
    pub const ICR = mmio(Address + 0x00000048, 32, packed struct {
        ICR: u1, // bit offset: 0 desc: Clear-on-read all active interrupts
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 76 DMA control
    pub const DMACR = mmio(Address + 0x0000004c, 32, packed struct {
        RDMAE: u1, // bit offset: 0 desc: Receive DMA enable
        TDMAE: u1, // bit offset: 1 desc: Transmit DMA enable
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 80 DMA TX data level
    pub const DMATDLR = mmio(Address + 0x00000050, 32, packed struct {
        DMATDL: u8, // bit offset: 0 desc: Transmit data watermark level
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 84 DMA RX data level
    pub const DMARDLR = mmio(Address + 0x00000054, 32, packed struct {
        DMARDL: u8, // bit offset: 0 desc: Receive data watermark level (DMARDLR+1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 88 Identification register
    pub const IDR = mmio(Address + 0x00000058, 32, packed struct {
        IDCODE: u32, // bit offset: 0 desc: Peripheral dentification code
    });
    // byte offset: 92 Version ID
    pub const SSI_VERSION_ID = mmio(Address + 0x0000005c, 32, packed struct {
        SSI_COMP_VERSION: u32, // bit offset: 0 desc: SNPS component version (format X.YY)
    });
    // byte offset: 96 Data Register 0 (of 36)
    pub const DR0 = mmio(Address + 0x00000060, 32, packed struct {
        DR: u32, // bit offset: 0 desc: First data register of 36
    });
    // byte offset: 240 RX sample delay
    pub const RX_SAMPLE_DLY = mmio(Address + 0x000000f0, 32, packed struct {
        RSD: u8, // bit offset: 0 desc: RXD sample delay (in SCLK cycles)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 244 SPI control
    pub const SPI_CTRLR0 = mmio(Address + 0x000000f4, 32, packed struct {
        TRANS_TYPE: enum(u2) { // bit offset: 0 desc: Address and instruction transfer format
            @"1C1A" = 0, // desc: Command and address both in standard SPI frame format
            @"1C2A" = 1, // desc: Command in standard SPI format, address in format specified by FRF
            @"2C2A" = 2, // desc: Command and address both in format specified by FRF (e.g. Dual-SPI)
            _, // non-exhaustive
        },
        ADDR_L: u4, // bit offset: 2 desc: Address length (0b-60b in 4b increments)
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        INST_L: enum(u2) { // bit offset: 8 desc: Instruction length (0/4/8/16b)
            @"NONE" = 0, // desc: No instruction
            @"4B" = 1, // desc: 4-bit instruction
            @"8B" = 2, // desc: 8-bit instruction
            @"16B" = 3, // desc: 16-bit instruction
        },
        reserved2: u1 = 0,
        WAIT_CYCLES: u5, // bit offset: 11 desc: Wait cycles between control frame transmit and data reception (in SCLK cycles)
        SPI_DDR_EN: u1, // bit offset: 16 desc: SPI DDR transfer enable
        INST_DDR_EN: u1, // bit offset: 17 desc: Instruction DDR transfer enable
        SPI_RXDS_EN: u1, // bit offset: 18 desc: Read data strobe enable
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        XIP_CMD: u8, // bit offset: 24 desc: SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L = 0-bit)
    });
    // byte offset: 248 TX drive edge
    pub const TXD_DRIVE_EDGE = mmio(Address + 0x000000f8, 32, packed struct {
        TDE: u8, // bit offset: 0 desc: TXD drive edge
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const SYSINFO = extern struct {
    pub const Address: u32 = 0x40000000;
    // byte offset: 0 JEDEC JEP-106 compliant chip identifier.
    pub const CHIP_ID = mmio(Address + 0x00000000, 32, packed struct {
        MANUFACTURER: u12, // bit offset: 0 desc:
        PART: u16, // bit offset: 12 desc:
        REVISION: u4, // bit offset: 28 desc:
    });
    // byte offset: 4 Platform register. Allows software to know what environment it is running in.
    pub const PLATFORM = mmio(Address + 0x00000004, 32, packed struct {
        FPGA: u1, // bit offset: 0 desc:
        ASIC: u1, // bit offset: 1 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 64 Git hash of the chip source. Used to identify chip version.
    pub const GITREF_RP2040 = mmio(Address + 0x00000040, 32, packed struct {
        raw: u32, // placeholder field
    });
};
pub const SYSCFG = extern struct {
    pub const Address: u32 = 0x40004000;
    // byte offset: 0 Processor core 0 NMI source mask\n Set a bit high to enable NMI from that IRQ
    pub const PROC0_NMI_MASK = mmio(Address + 0x00000000, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 4 Processor core 1 NMI source mask\n Set a bit high to enable NMI from that IRQ
    pub const PROC1_NMI_MASK = mmio(Address + 0x00000004, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 8 Configuration for processors
    pub const PROC_CONFIG = mmio(Address + 0x00000008, 32, packed struct {
        PROC0_HALTED: u1, // bit offset: 0 desc: Indication that proc0 has halted
        PROC1_HALTED: u1, // bit offset: 1 desc: Indication that proc1 has halted
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        PROC0_DAP_INSTID: u4, // bit offset: 24 desc: Configure proc0 DAP instance ID.\n Recommend that this is NOT changed until you require debug access in multi-chip environment\n WARNING: do not set to 15 as this is reserved for RescueDP
        PROC1_DAP_INSTID: u4, // bit offset: 28 desc: Configure proc1 DAP instance ID.\n Recommend that this is NOT changed until you require debug access in multi-chip environment\n WARNING: do not set to 15 as this is reserved for RescueDP
    });
    // byte offset: 12 For each bit, if 1, bypass the input synchronizer between that GPIO\n and the GPIO input register in the SIO. The input synchronizers should\n generally be unbypassed, to avoid injecting metastabilities into processors.\n If you're feeling brave, you can bypass to save two cycles of input\n latency. This register applies to GPIO 0...29.
    pub const PROC_IN_SYNC_BYPASS = mmio(Address + 0x0000000c, 32, packed struct {
        PROC_IN_SYNC_BYPASS: u30, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 For each bit, if 1, bypass the input synchronizer between that GPIO\n and the GPIO input register in the SIO. The input synchronizers should\n generally be unbypassed, to avoid injecting metastabilities into processors.\n If you're feeling brave, you can bypass to save two cycles of input\n latency. This register applies to GPIO 30...35 (the QSPI IOs).
    pub const PROC_IN_SYNC_BYPASS_HI = mmio(Address + 0x00000010, 32, packed struct {
        PROC_IN_SYNC_BYPASS_HI: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 20 Directly control the SWD debug port of either processor
    pub const DBGFORCE = mmio(Address + 0x00000014, 32, packed struct {
        PROC0_SWDO: u1, // bit offset: 0 desc: Observe the value of processor 0 SWDIO output.
        PROC0_SWDI: u1, // bit offset: 1 desc: Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set
        PROC0_SWCLK: u1, // bit offset: 2 desc: Directly drive processor 0 SWCLK, if PROC0_ATTACH is set
        PROC0_ATTACH: u1, // bit offset: 3 desc: Attach processor 0 debug port to syscfg controls, and disconnect it from external SWD pads.
        PROC1_SWDO: u1, // bit offset: 4 desc: Observe the value of processor 1 SWDIO output.
        PROC1_SWDI: u1, // bit offset: 5 desc: Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set
        PROC1_SWCLK: u1, // bit offset: 6 desc: Directly drive processor 1 SWCLK, if PROC1_ATTACH is set
        PROC1_ATTACH: u1, // bit offset: 7 desc: Attach processor 1 debug port to syscfg controls, and disconnect it from external SWD pads.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 24 Control power downs to memories. Set high to power down memories.\n Use with extreme caution
    pub const MEMPOWERDOWN = mmio(Address + 0x00000018, 32, packed struct {
        SRAM0: u1, // bit offset: 0 desc:
        SRAM1: u1, // bit offset: 1 desc:
        SRAM2: u1, // bit offset: 2 desc:
        SRAM3: u1, // bit offset: 3 desc:
        SRAM4: u1, // bit offset: 4 desc:
        SRAM5: u1, // bit offset: 5 desc:
        USB: u1, // bit offset: 6 desc:
        ROM: u1, // bit offset: 7 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const CLOCKS = extern struct {
    pub const Address: u32 = 0x40008000;
    // byte offset: 0 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT0_CTRL = mmio(Address + 0x00000000, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u4) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_sys" = 0, // desc:
            @"clksrc_gpin0" = 1, // desc:
            @"clksrc_gpin1" = 2, // desc:
            @"clksrc_pll_usb" = 3, // desc:
            @"rosc_clksrc" = 4, // desc:
            @"xosc_clksrc" = 5, // desc:
            @"clk_sys" = 6, // desc:
            @"clk_usb" = 7, // desc:
            @"clk_adc" = 8, // desc:
            @"clk_rtc" = 9, // desc:
            @"clk_ref" = 10, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        DC50: u1, // bit offset: 12 desc: Enables duty cycle correction for odd divisors
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 4 Clock divisor, can be changed on-the-fly
    pub const CLK_GPOUT0_DIV = mmio(Address + 0x00000004, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional component of the divisor
        INT: u24, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
    });
    // byte offset: 8 Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT0_SELECTED = mmio(Address + 0x00000008, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 12 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT1_CTRL = mmio(Address + 0x0000000c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u4) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_sys" = 0, // desc:
            @"clksrc_gpin0" = 1, // desc:
            @"clksrc_gpin1" = 2, // desc:
            @"clksrc_pll_usb" = 3, // desc:
            @"rosc_clksrc" = 4, // desc:
            @"xosc_clksrc" = 5, // desc:
            @"clk_sys" = 6, // desc:
            @"clk_usb" = 7, // desc:
            @"clk_adc" = 8, // desc:
            @"clk_rtc" = 9, // desc:
            @"clk_ref" = 10, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        DC50: u1, // bit offset: 12 desc: Enables duty cycle correction for odd divisors
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 16 Clock divisor, can be changed on-the-fly
    pub const CLK_GPOUT1_DIV = mmio(Address + 0x00000010, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional component of the divisor
        INT: u24, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
    });
    // byte offset: 20 Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT1_SELECTED = mmio(Address + 0x00000014, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 24 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT2_CTRL = mmio(Address + 0x00000018, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u4) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_sys" = 0, // desc:
            @"clksrc_gpin0" = 1, // desc:
            @"clksrc_gpin1" = 2, // desc:
            @"clksrc_pll_usb" = 3, // desc:
            @"rosc_clksrc_ph" = 4, // desc:
            @"xosc_clksrc" = 5, // desc:
            @"clk_sys" = 6, // desc:
            @"clk_usb" = 7, // desc:
            @"clk_adc" = 8, // desc:
            @"clk_rtc" = 9, // desc:
            @"clk_ref" = 10, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        DC50: u1, // bit offset: 12 desc: Enables duty cycle correction for odd divisors
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 28 Clock divisor, can be changed on-the-fly
    pub const CLK_GPOUT2_DIV = mmio(Address + 0x0000001c, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional component of the divisor
        INT: u24, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
    });
    // byte offset: 32 Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT2_SELECTED = mmio(Address + 0x00000020, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 36 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_GPOUT3_CTRL = mmio(Address + 0x00000024, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u4) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_sys" = 0, // desc:
            @"clksrc_gpin0" = 1, // desc:
            @"clksrc_gpin1" = 2, // desc:
            @"clksrc_pll_usb" = 3, // desc:
            @"rosc_clksrc_ph" = 4, // desc:
            @"xosc_clksrc" = 5, // desc:
            @"clk_sys" = 6, // desc:
            @"clk_usb" = 7, // desc:
            @"clk_adc" = 8, // desc:
            @"clk_rtc" = 9, // desc:
            @"clk_ref" = 10, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        DC50: u1, // bit offset: 12 desc: Enables duty cycle correction for odd divisors
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 40 Clock divisor, can be changed on-the-fly
    pub const CLK_GPOUT3_DIV = mmio(Address + 0x00000028, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional component of the divisor
        INT: u24, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
    });
    // byte offset: 44 Indicates which src is currently selected (one-hot)
    pub const CLK_GPOUT3_SELECTED = mmio(Address + 0x0000002c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 48 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_REF_CTRL = mmio(Address + 0x00000030, 32, packed struct {
        SRC: enum(u2) { // bit offset: 0 desc: Selects the clock source glitchlessly, can be changed on-the-fly
            @"rosc_clksrc_ph" = 0, // desc:
            @"clksrc_clk_ref_aux" = 1, // desc:
            @"xosc_clksrc" = 2, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        AUXSRC: enum(u2) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_usb" = 0, // desc:
            @"clksrc_gpin0" = 1, // desc:
            @"clksrc_gpin1" = 2, // desc:
            _, // non-exhaustive
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
    });
    // byte offset: 52 Clock divisor, can be changed on-the-fly
    pub const CLK_REF_DIV = mmio(Address + 0x00000034, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        INT: u2, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
    });
    // byte offset: 56 Indicates which src is currently selected (one-hot)
    pub const CLK_REF_SELECTED = mmio(Address + 0x00000038, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 60 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_SYS_CTRL = mmio(Address + 0x0000003c, 32, packed struct {
        SRC: enum(u1) { // bit offset: 0 desc: Selects the clock source glitchlessly, can be changed on-the-fly
            @"clk_ref" = 0, // desc:
            @"clksrc_clk_sys_aux" = 1, // desc:
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        AUXSRC: enum(u3) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_sys" = 0, // desc:
            @"clksrc_pll_usb" = 1, // desc:
            @"rosc_clksrc" = 2, // desc:
            @"xosc_clksrc" = 3, // desc:
            @"clksrc_gpin0" = 4, // desc:
            @"clksrc_gpin1" = 5, // desc:
            _, // non-exhaustive
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 64 Clock divisor, can be changed on-the-fly
    pub const CLK_SYS_DIV = mmio(Address + 0x00000040, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional component of the divisor
        INT: u24, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
    });
    // byte offset: 68 Indicates which src is currently selected (one-hot)
    pub const CLK_SYS_SELECTED = mmio(Address + 0x00000044, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 72 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_PERI_CTRL = mmio(Address + 0x00000048, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u3) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clk_sys" = 0, // desc:
            @"clksrc_pll_sys" = 1, // desc:
            @"clksrc_pll_usb" = 2, // desc:
            @"rosc_clksrc_ph" = 3, // desc:
            @"xosc_clksrc" = 4, // desc:
            @"clksrc_gpin0" = 5, // desc:
            @"clksrc_gpin1" = 6, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 80 Indicates which src is currently selected (one-hot)
    pub const CLK_PERI_SELECTED = mmio(Address + 0x00000050, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 84 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_USB_CTRL = mmio(Address + 0x00000054, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u3) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_usb" = 0, // desc:
            @"clksrc_pll_sys" = 1, // desc:
            @"rosc_clksrc_ph" = 2, // desc:
            @"xosc_clksrc" = 3, // desc:
            @"clksrc_gpin0" = 4, // desc:
            @"clksrc_gpin1" = 5, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 88 Clock divisor, can be changed on-the-fly
    pub const CLK_USB_DIV = mmio(Address + 0x00000058, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        INT: u2, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
    });
    // byte offset: 92 Indicates which src is currently selected (one-hot)
    pub const CLK_USB_SELECTED = mmio(Address + 0x0000005c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 96 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_ADC_CTRL = mmio(Address + 0x00000060, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u3) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_usb" = 0, // desc:
            @"clksrc_pll_sys" = 1, // desc:
            @"rosc_clksrc_ph" = 2, // desc:
            @"xosc_clksrc" = 3, // desc:
            @"clksrc_gpin0" = 4, // desc:
            @"clksrc_gpin1" = 5, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 100 Clock divisor, can be changed on-the-fly
    pub const CLK_ADC_DIV = mmio(Address + 0x00000064, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        INT: u2, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
    });
    // byte offset: 104 Indicates which src is currently selected (one-hot)
    pub const CLK_ADC_SELECTED = mmio(Address + 0x00000068, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 108 Clock control, can be changed on-the-fly (except for auxsrc)
    pub const CLK_RTC_CTRL = mmio(Address + 0x0000006c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        AUXSRC: enum(u3) { // bit offset: 5 desc: Selects the auxiliary clock source, will glitch when switching
            @"clksrc_pll_usb" = 0, // desc:
            @"clksrc_pll_sys" = 1, // desc:
            @"rosc_clksrc_ph" = 2, // desc:
            @"xosc_clksrc" = 3, // desc:
            @"clksrc_gpin0" = 4, // desc:
            @"clksrc_gpin1" = 5, // desc:
            _, // non-exhaustive
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        KILL: u1, // bit offset: 10 desc: Asynchronously kills the clock generator
        ENABLE: u1, // bit offset: 11 desc: Starts and stops the clock generator cleanly
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        PHASE: u2, // bit offset: 16 desc: This delays the enable signal by up to 3 cycles of the input clock\n This must be set before the clock is enabled to have any effect
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        NUDGE: u1, // bit offset: 20 desc: An edge on this signal shifts the phase of the output by 1 cycle of the input clock\n This can be done at any time
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 112 Clock divisor, can be changed on-the-fly
    pub const CLK_RTC_DIV = mmio(Address + 0x00000070, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional component of the divisor
        INT: u24, // bit offset: 8 desc: Integer component of the divisor, 0 -> divide by 2^16
    });
    // byte offset: 116 Indicates which src is currently selected (one-hot)
    pub const CLK_RTC_SELECTED = mmio(Address + 0x00000074, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 120
    pub const CLK_SYS_RESUS_CTRL = mmio(Address + 0x00000078, 32, packed struct {
        TIMEOUT: u8, // bit offset: 0 desc: This is expressed as a number of clk_ref cycles\n and must be >= 2x clk_ref_freq/min_clk_tst_freq
        ENABLE: u1, // bit offset: 8 desc: Enable resus
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        FRCE: u1, // bit offset: 12 desc: Force a resus, for test purposes only
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        CLEAR: u1, // bit offset: 16 desc: For clearing the resus after the fault that triggered it has been corrected
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
    });
    // byte offset: 124
    pub const CLK_SYS_RESUS_STATUS = mmio(Address + 0x0000007c, 32, packed struct {
        RESUSSED: u1, // bit offset: 0 desc: Clock has been resuscitated, correct the error then send ctrl_clear=1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 128 Reference clock frequency in kHz
    pub const FC0_REF_KHZ = mmio(Address + 0x00000080, 32, packed struct {
        FC0_REF_KHZ: u20, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
    // byte offset: 132 Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
    pub const FC0_MIN_KHZ = mmio(Address + 0x00000084, 32, packed struct {
        FC0_MIN_KHZ: u25, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
    // byte offset: 136 Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
    pub const FC0_MAX_KHZ = mmio(Address + 0x00000088, 32, packed struct {
        FC0_MAX_KHZ: u25, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
    // byte offset: 140 Delays the start of frequency counting to allow the mux to settle\n Delay is measured in multiples of the reference clock period
    pub const FC0_DELAY = mmio(Address + 0x0000008c, 32, packed struct {
        FC0_DELAY: u3, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 144 The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval\n The default gives a test interval of 250us
    pub const FC0_INTERVAL = mmio(Address + 0x00000090, 32, packed struct {
        FC0_INTERVAL: u4, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 148 Clock sent to frequency counter, set to 0 when not required\n Writing to this register initiates the frequency count
    pub const FC0_SRC = mmio(Address + 0x00000094, 32, packed struct {
        FC0_SRC: enum(u8) { // bit offset: 0 desc:
            @"NULL" = 0, // desc:
            @"pll_sys_clksrc_primary" = 1, // desc:
            @"pll_usb_clksrc_primary" = 2, // desc:
            @"rosc_clksrc" = 3, // desc:
            @"rosc_clksrc_ph" = 4, // desc:
            @"xosc_clksrc" = 5, // desc:
            @"clksrc_gpin0" = 6, // desc:
            @"clksrc_gpin1" = 7, // desc:
            @"clk_ref" = 8, // desc:
            @"clk_sys" = 9, // desc:
            @"clk_peri" = 10, // desc:
            @"clk_usb" = 11, // desc:
            @"clk_adc" = 12, // desc:
            @"clk_rtc" = 13, // desc:
            _, // non-exhaustive
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 152 Frequency counter status
    pub const FC0_STATUS = mmio(Address + 0x00000098, 32, packed struct {
        PASS: u1, // bit offset: 0 desc: Test passed
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        DONE: u1, // bit offset: 4 desc: Test complete
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        RUNNING: u1, // bit offset: 8 desc: Test running
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        WAITING: u1, // bit offset: 12 desc: Waiting for test clock to start
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        FAIL: u1, // bit offset: 16 desc: Test failed
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        SLOW: u1, // bit offset: 20 desc: Test clock slower than expected, only valid when status_done=1
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        FAST: u1, // bit offset: 24 desc: Test clock faster than expected, only valid when status_done=1
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        DIED: u1, // bit offset: 28 desc: Test clock stopped during test
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
    });
    // byte offset: 156 Result of frequency measurement, only valid when status_done=1
    pub const FC0_RESULT = mmio(Address + 0x0000009c, 32, packed struct {
        FRAC: u5, // bit offset: 0 desc:
        KHZ: u25, // bit offset: 5 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 160 enable clock in wake mode
    pub const WAKE_EN0 = mmio(Address + 0x000000a0, 32, packed struct {
        clk_sys_clocks: u1, // bit offset: 0 desc:
        clk_adc_adc: u1, // bit offset: 1 desc:
        clk_sys_adc: u1, // bit offset: 2 desc:
        clk_sys_busctrl: u1, // bit offset: 3 desc:
        clk_sys_busfabric: u1, // bit offset: 4 desc:
        clk_sys_dma: u1, // bit offset: 5 desc:
        clk_sys_i2c0: u1, // bit offset: 6 desc:
        clk_sys_i2c1: u1, // bit offset: 7 desc:
        clk_sys_io: u1, // bit offset: 8 desc:
        clk_sys_jtag: u1, // bit offset: 9 desc:
        clk_sys_vreg_and_chip_reset: u1, // bit offset: 10 desc:
        clk_sys_pads: u1, // bit offset: 11 desc:
        clk_sys_pio0: u1, // bit offset: 12 desc:
        clk_sys_pio1: u1, // bit offset: 13 desc:
        clk_sys_pll_sys: u1, // bit offset: 14 desc:
        clk_sys_pll_usb: u1, // bit offset: 15 desc:
        clk_sys_psm: u1, // bit offset: 16 desc:
        clk_sys_pwm: u1, // bit offset: 17 desc:
        clk_sys_resets: u1, // bit offset: 18 desc:
        clk_sys_rom: u1, // bit offset: 19 desc:
        clk_sys_rosc: u1, // bit offset: 20 desc:
        clk_rtc_rtc: u1, // bit offset: 21 desc:
        clk_sys_rtc: u1, // bit offset: 22 desc:
        clk_sys_sio: u1, // bit offset: 23 desc:
        clk_peri_spi0: u1, // bit offset: 24 desc:
        clk_sys_spi0: u1, // bit offset: 25 desc:
        clk_peri_spi1: u1, // bit offset: 26 desc:
        clk_sys_spi1: u1, // bit offset: 27 desc:
        clk_sys_sram0: u1, // bit offset: 28 desc:
        clk_sys_sram1: u1, // bit offset: 29 desc:
        clk_sys_sram2: u1, // bit offset: 30 desc:
        clk_sys_sram3: u1, // bit offset: 31 desc:
    });
    // byte offset: 164 enable clock in wake mode
    pub const WAKE_EN1 = mmio(Address + 0x000000a4, 32, packed struct {
        clk_sys_sram4: u1, // bit offset: 0 desc:
        clk_sys_sram5: u1, // bit offset: 1 desc:
        clk_sys_syscfg: u1, // bit offset: 2 desc:
        clk_sys_sysinfo: u1, // bit offset: 3 desc:
        clk_sys_tbman: u1, // bit offset: 4 desc:
        clk_sys_timer: u1, // bit offset: 5 desc:
        clk_peri_uart0: u1, // bit offset: 6 desc:
        clk_sys_uart0: u1, // bit offset: 7 desc:
        clk_peri_uart1: u1, // bit offset: 8 desc:
        clk_sys_uart1: u1, // bit offset: 9 desc:
        clk_sys_usbctrl: u1, // bit offset: 10 desc:
        clk_usb_usbctrl: u1, // bit offset: 11 desc:
        clk_sys_watchdog: u1, // bit offset: 12 desc:
        clk_sys_xip: u1, // bit offset: 13 desc:
        clk_sys_xosc: u1, // bit offset: 14 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
    });
    // byte offset: 168 enable clock in sleep mode
    pub const SLEEP_EN0 = mmio(Address + 0x000000a8, 32, packed struct {
        clk_sys_clocks: u1, // bit offset: 0 desc:
        clk_adc_adc: u1, // bit offset: 1 desc:
        clk_sys_adc: u1, // bit offset: 2 desc:
        clk_sys_busctrl: u1, // bit offset: 3 desc:
        clk_sys_busfabric: u1, // bit offset: 4 desc:
        clk_sys_dma: u1, // bit offset: 5 desc:
        clk_sys_i2c0: u1, // bit offset: 6 desc:
        clk_sys_i2c1: u1, // bit offset: 7 desc:
        clk_sys_io: u1, // bit offset: 8 desc:
        clk_sys_jtag: u1, // bit offset: 9 desc:
        clk_sys_vreg_and_chip_reset: u1, // bit offset: 10 desc:
        clk_sys_pads: u1, // bit offset: 11 desc:
        clk_sys_pio0: u1, // bit offset: 12 desc:
        clk_sys_pio1: u1, // bit offset: 13 desc:
        clk_sys_pll_sys: u1, // bit offset: 14 desc:
        clk_sys_pll_usb: u1, // bit offset: 15 desc:
        clk_sys_psm: u1, // bit offset: 16 desc:
        clk_sys_pwm: u1, // bit offset: 17 desc:
        clk_sys_resets: u1, // bit offset: 18 desc:
        clk_sys_rom: u1, // bit offset: 19 desc:
        clk_sys_rosc: u1, // bit offset: 20 desc:
        clk_rtc_rtc: u1, // bit offset: 21 desc:
        clk_sys_rtc: u1, // bit offset: 22 desc:
        clk_sys_sio: u1, // bit offset: 23 desc:
        clk_peri_spi0: u1, // bit offset: 24 desc:
        clk_sys_spi0: u1, // bit offset: 25 desc:
        clk_peri_spi1: u1, // bit offset: 26 desc:
        clk_sys_spi1: u1, // bit offset: 27 desc:
        clk_sys_sram0: u1, // bit offset: 28 desc:
        clk_sys_sram1: u1, // bit offset: 29 desc:
        clk_sys_sram2: u1, // bit offset: 30 desc:
        clk_sys_sram3: u1, // bit offset: 31 desc:
    });
    // byte offset: 172 enable clock in sleep mode
    pub const SLEEP_EN1 = mmio(Address + 0x000000ac, 32, packed struct {
        clk_sys_sram4: u1, // bit offset: 0 desc:
        clk_sys_sram5: u1, // bit offset: 1 desc:
        clk_sys_syscfg: u1, // bit offset: 2 desc:
        clk_sys_sysinfo: u1, // bit offset: 3 desc:
        clk_sys_tbman: u1, // bit offset: 4 desc:
        clk_sys_timer: u1, // bit offset: 5 desc:
        clk_peri_uart0: u1, // bit offset: 6 desc:
        clk_sys_uart0: u1, // bit offset: 7 desc:
        clk_peri_uart1: u1, // bit offset: 8 desc:
        clk_sys_uart1: u1, // bit offset: 9 desc:
        clk_sys_usbctrl: u1, // bit offset: 10 desc:
        clk_usb_usbctrl: u1, // bit offset: 11 desc:
        clk_sys_watchdog: u1, // bit offset: 12 desc:
        clk_sys_xip: u1, // bit offset: 13 desc:
        clk_sys_xosc: u1, // bit offset: 14 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
    });
    // byte offset: 176 indicates the state of the clock enable
    pub const ENABLED0 = mmio(Address + 0x000000b0, 32, packed struct {
        clk_sys_clocks: u1, // bit offset: 0 desc:
        clk_adc_adc: u1, // bit offset: 1 desc:
        clk_sys_adc: u1, // bit offset: 2 desc:
        clk_sys_busctrl: u1, // bit offset: 3 desc:
        clk_sys_busfabric: u1, // bit offset: 4 desc:
        clk_sys_dma: u1, // bit offset: 5 desc:
        clk_sys_i2c0: u1, // bit offset: 6 desc:
        clk_sys_i2c1: u1, // bit offset: 7 desc:
        clk_sys_io: u1, // bit offset: 8 desc:
        clk_sys_jtag: u1, // bit offset: 9 desc:
        clk_sys_vreg_and_chip_reset: u1, // bit offset: 10 desc:
        clk_sys_pads: u1, // bit offset: 11 desc:
        clk_sys_pio0: u1, // bit offset: 12 desc:
        clk_sys_pio1: u1, // bit offset: 13 desc:
        clk_sys_pll_sys: u1, // bit offset: 14 desc:
        clk_sys_pll_usb: u1, // bit offset: 15 desc:
        clk_sys_psm: u1, // bit offset: 16 desc:
        clk_sys_pwm: u1, // bit offset: 17 desc:
        clk_sys_resets: u1, // bit offset: 18 desc:
        clk_sys_rom: u1, // bit offset: 19 desc:
        clk_sys_rosc: u1, // bit offset: 20 desc:
        clk_rtc_rtc: u1, // bit offset: 21 desc:
        clk_sys_rtc: u1, // bit offset: 22 desc:
        clk_sys_sio: u1, // bit offset: 23 desc:
        clk_peri_spi0: u1, // bit offset: 24 desc:
        clk_sys_spi0: u1, // bit offset: 25 desc:
        clk_peri_spi1: u1, // bit offset: 26 desc:
        clk_sys_spi1: u1, // bit offset: 27 desc:
        clk_sys_sram0: u1, // bit offset: 28 desc:
        clk_sys_sram1: u1, // bit offset: 29 desc:
        clk_sys_sram2: u1, // bit offset: 30 desc:
        clk_sys_sram3: u1, // bit offset: 31 desc:
    });
    // byte offset: 180 indicates the state of the clock enable
    pub const ENABLED1 = mmio(Address + 0x000000b4, 32, packed struct {
        clk_sys_sram4: u1, // bit offset: 0 desc:
        clk_sys_sram5: u1, // bit offset: 1 desc:
        clk_sys_syscfg: u1, // bit offset: 2 desc:
        clk_sys_sysinfo: u1, // bit offset: 3 desc:
        clk_sys_tbman: u1, // bit offset: 4 desc:
        clk_sys_timer: u1, // bit offset: 5 desc:
        clk_peri_uart0: u1, // bit offset: 6 desc:
        clk_sys_uart0: u1, // bit offset: 7 desc:
        clk_peri_uart1: u1, // bit offset: 8 desc:
        clk_sys_uart1: u1, // bit offset: 9 desc:
        clk_sys_usbctrl: u1, // bit offset: 10 desc:
        clk_usb_usbctrl: u1, // bit offset: 11 desc:
        clk_sys_watchdog: u1, // bit offset: 12 desc:
        clk_sys_xip: u1, // bit offset: 13 desc:
        clk_sys_xosc: u1, // bit offset: 14 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
    });
    // byte offset: 184 Raw Interrupts
    pub const INTR = mmio(Address + 0x000000b8, 32, packed struct {
        CLK_SYS_RESUS: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 188 Interrupt Enable
    pub const INTE = mmio(Address + 0x000000bc, 32, packed struct {
        CLK_SYS_RESUS: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 192 Interrupt Force
    pub const INTF = mmio(Address + 0x000000c0, 32, packed struct {
        CLK_SYS_RESUS: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 196 Interrupt status after masking & forcing
    pub const INTS = mmio(Address + 0x000000c4, 32, packed struct {
        CLK_SYS_RESUS: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
};
pub const RESETS = extern struct {
    pub const Address: u32 = 0x4000c000;
    // byte offset: 0 Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted.
    pub const RESET = mmio(Address + 0x00000000, 32, packed struct {
        adc: u1, // bit offset: 0 desc:
        busctrl: u1, // bit offset: 1 desc:
        dma: u1, // bit offset: 2 desc:
        i2c0: u1, // bit offset: 3 desc:
        i2c1: u1, // bit offset: 4 desc:
        io_bank0: u1, // bit offset: 5 desc:
        io_qspi: u1, // bit offset: 6 desc:
        jtag: u1, // bit offset: 7 desc:
        pads_bank0: u1, // bit offset: 8 desc:
        pads_qspi: u1, // bit offset: 9 desc:
        pio0: u1, // bit offset: 10 desc:
        pio1: u1, // bit offset: 11 desc:
        pll_sys: u1, // bit offset: 12 desc:
        pll_usb: u1, // bit offset: 13 desc:
        pwm: u1, // bit offset: 14 desc:
        rtc: u1, // bit offset: 15 desc:
        spi0: u1, // bit offset: 16 desc:
        spi1: u1, // bit offset: 17 desc:
        syscfg: u1, // bit offset: 18 desc:
        sysinfo: u1, // bit offset: 19 desc:
        tbman: u1, // bit offset: 20 desc:
        timer: u1, // bit offset: 21 desc:
        uart0: u1, // bit offset: 22 desc:
        uart1: u1, // bit offset: 23 desc:
        usbctrl: u1, // bit offset: 24 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
    // byte offset: 4 Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires.
    pub const WDSEL = mmio(Address + 0x00000004, 32, packed struct {
        adc: u1, // bit offset: 0 desc:
        busctrl: u1, // bit offset: 1 desc:
        dma: u1, // bit offset: 2 desc:
        i2c0: u1, // bit offset: 3 desc:
        i2c1: u1, // bit offset: 4 desc:
        io_bank0: u1, // bit offset: 5 desc:
        io_qspi: u1, // bit offset: 6 desc:
        jtag: u1, // bit offset: 7 desc:
        pads_bank0: u1, // bit offset: 8 desc:
        pads_qspi: u1, // bit offset: 9 desc:
        pio0: u1, // bit offset: 10 desc:
        pio1: u1, // bit offset: 11 desc:
        pll_sys: u1, // bit offset: 12 desc:
        pll_usb: u1, // bit offset: 13 desc:
        pwm: u1, // bit offset: 14 desc:
        rtc: u1, // bit offset: 15 desc:
        spi0: u1, // bit offset: 16 desc:
        spi1: u1, // bit offset: 17 desc:
        syscfg: u1, // bit offset: 18 desc:
        sysinfo: u1, // bit offset: 19 desc:
        tbman: u1, // bit offset: 20 desc:
        timer: u1, // bit offset: 21 desc:
        uart0: u1, // bit offset: 22 desc:
        uart1: u1, // bit offset: 23 desc:
        usbctrl: u1, // bit offset: 24 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
    // byte offset: 8 Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed.
    pub const RESET_DONE = mmio(Address + 0x00000008, 32, packed struct {
        adc: u1, // bit offset: 0 desc:
        busctrl: u1, // bit offset: 1 desc:
        dma: u1, // bit offset: 2 desc:
        i2c0: u1, // bit offset: 3 desc:
        i2c1: u1, // bit offset: 4 desc:
        io_bank0: u1, // bit offset: 5 desc:
        io_qspi: u1, // bit offset: 6 desc:
        jtag: u1, // bit offset: 7 desc:
        pads_bank0: u1, // bit offset: 8 desc:
        pads_qspi: u1, // bit offset: 9 desc:
        pio0: u1, // bit offset: 10 desc:
        pio1: u1, // bit offset: 11 desc:
        pll_sys: u1, // bit offset: 12 desc:
        pll_usb: u1, // bit offset: 13 desc:
        pwm: u1, // bit offset: 14 desc:
        rtc: u1, // bit offset: 15 desc:
        spi0: u1, // bit offset: 16 desc:
        spi1: u1, // bit offset: 17 desc:
        syscfg: u1, // bit offset: 18 desc:
        sysinfo: u1, // bit offset: 19 desc:
        tbman: u1, // bit offset: 20 desc:
        timer: u1, // bit offset: 21 desc:
        uart0: u1, // bit offset: 22 desc:
        uart1: u1, // bit offset: 23 desc:
        usbctrl: u1, // bit offset: 24 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
};
pub const PSM = extern struct {
    pub const Address: u32 = 0x40010000;
    // byte offset: 0 Force block out of reset (i.e. power it on)
    pub const FRCE_ON = mmio(Address + 0x00000000, 32, packed struct {
        rosc: u1, // bit offset: 0 desc:
        xosc: u1, // bit offset: 1 desc:
        clocks: u1, // bit offset: 2 desc:
        resets: u1, // bit offset: 3 desc:
        busfabric: u1, // bit offset: 4 desc:
        rom: u1, // bit offset: 5 desc:
        sram0: u1, // bit offset: 6 desc:
        sram1: u1, // bit offset: 7 desc:
        sram2: u1, // bit offset: 8 desc:
        sram3: u1, // bit offset: 9 desc:
        sram4: u1, // bit offset: 10 desc:
        sram5: u1, // bit offset: 11 desc:
        xip: u1, // bit offset: 12 desc:
        vreg_and_chip_reset: u1, // bit offset: 13 desc:
        sio: u1, // bit offset: 14 desc:
        proc0: u1, // bit offset: 15 desc:
        proc1: u1, // bit offset: 16 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
    });
    // byte offset: 4 Force into reset (i.e. power it off)
    pub const FRCE_OFF = mmio(Address + 0x00000004, 32, packed struct {
        rosc: u1, // bit offset: 0 desc:
        xosc: u1, // bit offset: 1 desc:
        clocks: u1, // bit offset: 2 desc:
        resets: u1, // bit offset: 3 desc:
        busfabric: u1, // bit offset: 4 desc:
        rom: u1, // bit offset: 5 desc:
        sram0: u1, // bit offset: 6 desc:
        sram1: u1, // bit offset: 7 desc:
        sram2: u1, // bit offset: 8 desc:
        sram3: u1, // bit offset: 9 desc:
        sram4: u1, // bit offset: 10 desc:
        sram5: u1, // bit offset: 11 desc:
        xip: u1, // bit offset: 12 desc:
        vreg_and_chip_reset: u1, // bit offset: 13 desc:
        sio: u1, // bit offset: 14 desc:
        proc0: u1, // bit offset: 15 desc:
        proc1: u1, // bit offset: 16 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
    });
    // byte offset: 8 Set to 1 if this peripheral should be reset when the watchdog fires.
    pub const WDSEL = mmio(Address + 0x00000008, 32, packed struct {
        rosc: u1, // bit offset: 0 desc:
        xosc: u1, // bit offset: 1 desc:
        clocks: u1, // bit offset: 2 desc:
        resets: u1, // bit offset: 3 desc:
        busfabric: u1, // bit offset: 4 desc:
        rom: u1, // bit offset: 5 desc:
        sram0: u1, // bit offset: 6 desc:
        sram1: u1, // bit offset: 7 desc:
        sram2: u1, // bit offset: 8 desc:
        sram3: u1, // bit offset: 9 desc:
        sram4: u1, // bit offset: 10 desc:
        sram5: u1, // bit offset: 11 desc:
        xip: u1, // bit offset: 12 desc:
        vreg_and_chip_reset: u1, // bit offset: 13 desc:
        sio: u1, // bit offset: 14 desc:
        proc0: u1, // bit offset: 15 desc:
        proc1: u1, // bit offset: 16 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
    });
    // byte offset: 12 Indicates the peripheral's registers are ready to access.
    pub const DONE = mmio(Address + 0x0000000c, 32, packed struct {
        rosc: u1, // bit offset: 0 desc:
        xosc: u1, // bit offset: 1 desc:
        clocks: u1, // bit offset: 2 desc:
        resets: u1, // bit offset: 3 desc:
        busfabric: u1, // bit offset: 4 desc:
        rom: u1, // bit offset: 5 desc:
        sram0: u1, // bit offset: 6 desc:
        sram1: u1, // bit offset: 7 desc:
        sram2: u1, // bit offset: 8 desc:
        sram3: u1, // bit offset: 9 desc:
        sram4: u1, // bit offset: 10 desc:
        sram5: u1, // bit offset: 11 desc:
        xip: u1, // bit offset: 12 desc:
        vreg_and_chip_reset: u1, // bit offset: 13 desc:
        sio: u1, // bit offset: 14 desc:
        proc0: u1, // bit offset: 15 desc:
        proc1: u1, // bit offset: 16 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
    });
};
pub const IO_BANK0 = extern struct {
    pub const Address: u32 = 0x40014000;
    // byte offset: 0 GPIO status
    pub const GPIO0_STATUS = mmio(Address + 0x00000000, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 4 GPIO control including function select and overrides.
    pub const GPIO0_CTRL = mmio(Address + 0x00000004, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"jtag_tck" = 0, // desc:
            @"spi0_rx" = 1, // desc:
            @"uart0_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_0" = 4, // desc:
            @"sio_0" = 5, // desc:
            @"pio0_0" = 6, // desc:
            @"pio1_0" = 7, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 GPIO status
    pub const GPIO1_STATUS = mmio(Address + 0x00000008, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 12 GPIO control including function select and overrides.
    pub const GPIO1_CTRL = mmio(Address + 0x0000000c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"jtag_tms" = 0, // desc:
            @"spi0_ss_n" = 1, // desc:
            @"uart0_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_0" = 4, // desc:
            @"sio_1" = 5, // desc:
            @"pio0_1" = 6, // desc:
            @"pio1_1" = 7, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 GPIO status
    pub const GPIO2_STATUS = mmio(Address + 0x00000010, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 20 GPIO control including function select and overrides.
    pub const GPIO2_CTRL = mmio(Address + 0x00000014, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"jtag_tdi" = 0, // desc:
            @"spi0_sclk" = 1, // desc:
            @"uart0_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_1" = 4, // desc:
            @"sio_2" = 5, // desc:
            @"pio0_2" = 6, // desc:
            @"pio1_2" = 7, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 GPIO status
    pub const GPIO3_STATUS = mmio(Address + 0x00000018, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 28 GPIO control including function select and overrides.
    pub const GPIO3_CTRL = mmio(Address + 0x0000001c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"jtag_tdo" = 0, // desc:
            @"spi0_tx" = 1, // desc:
            @"uart0_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_1" = 4, // desc:
            @"sio_3" = 5, // desc:
            @"pio0_3" = 6, // desc:
            @"pio1_3" = 7, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 GPIO status
    pub const GPIO4_STATUS = mmio(Address + 0x00000020, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 36 GPIO control including function select and overrides.
    pub const GPIO4_CTRL = mmio(Address + 0x00000024, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_rx" = 1, // desc:
            @"uart1_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_2" = 4, // desc:
            @"sio_4" = 5, // desc:
            @"pio0_4" = 6, // desc:
            @"pio1_4" = 7, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 GPIO status
    pub const GPIO5_STATUS = mmio(Address + 0x00000028, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 44 GPIO control including function select and overrides.
    pub const GPIO5_CTRL = mmio(Address + 0x0000002c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_ss_n" = 1, // desc:
            @"uart1_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_2" = 4, // desc:
            @"sio_5" = 5, // desc:
            @"pio0_5" = 6, // desc:
            @"pio1_5" = 7, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 GPIO status
    pub const GPIO6_STATUS = mmio(Address + 0x00000030, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 52 GPIO control including function select and overrides.
    pub const GPIO6_CTRL = mmio(Address + 0x00000034, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_sclk" = 1, // desc:
            @"uart1_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_3" = 4, // desc:
            @"sio_6" = 5, // desc:
            @"pio0_6" = 6, // desc:
            @"pio1_6" = 7, // desc:
            @"usb_muxing_extphy_softcon" = 8, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 56 GPIO status
    pub const GPIO7_STATUS = mmio(Address + 0x00000038, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 60 GPIO control including function select and overrides.
    pub const GPIO7_CTRL = mmio(Address + 0x0000003c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_tx" = 1, // desc:
            @"uart1_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_3" = 4, // desc:
            @"sio_7" = 5, // desc:
            @"pio0_7" = 6, // desc:
            @"pio1_7" = 7, // desc:
            @"usb_muxing_extphy_oe_n" = 8, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 64 GPIO status
    pub const GPIO8_STATUS = mmio(Address + 0x00000040, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 68 GPIO control including function select and overrides.
    pub const GPIO8_CTRL = mmio(Address + 0x00000044, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_rx" = 1, // desc:
            @"uart1_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_4" = 4, // desc:
            @"sio_8" = 5, // desc:
            @"pio0_8" = 6, // desc:
            @"pio1_8" = 7, // desc:
            @"usb_muxing_extphy_rcv" = 8, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 72 GPIO status
    pub const GPIO9_STATUS = mmio(Address + 0x00000048, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 76 GPIO control including function select and overrides.
    pub const GPIO9_CTRL = mmio(Address + 0x0000004c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_ss_n" = 1, // desc:
            @"uart1_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_4" = 4, // desc:
            @"sio_9" = 5, // desc:
            @"pio0_9" = 6, // desc:
            @"pio1_9" = 7, // desc:
            @"usb_muxing_extphy_vp" = 8, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 80 GPIO status
    pub const GPIO10_STATUS = mmio(Address + 0x00000050, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 84 GPIO control including function select and overrides.
    pub const GPIO10_CTRL = mmio(Address + 0x00000054, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_sclk" = 1, // desc:
            @"uart1_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_5" = 4, // desc:
            @"sio_10" = 5, // desc:
            @"pio0_10" = 6, // desc:
            @"pio1_10" = 7, // desc:
            @"usb_muxing_extphy_vm" = 8, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 88 GPIO status
    pub const GPIO11_STATUS = mmio(Address + 0x00000058, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 92 GPIO control including function select and overrides.
    pub const GPIO11_CTRL = mmio(Address + 0x0000005c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_tx" = 1, // desc:
            @"uart1_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_5" = 4, // desc:
            @"sio_11" = 5, // desc:
            @"pio0_11" = 6, // desc:
            @"pio1_11" = 7, // desc:
            @"usb_muxing_extphy_suspnd" = 8, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 96 GPIO status
    pub const GPIO12_STATUS = mmio(Address + 0x00000060, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 100 GPIO control including function select and overrides.
    pub const GPIO12_CTRL = mmio(Address + 0x00000064, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_rx" = 1, // desc:
            @"uart0_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_6" = 4, // desc:
            @"sio_12" = 5, // desc:
            @"pio0_12" = 6, // desc:
            @"pio1_12" = 7, // desc:
            @"usb_muxing_extphy_speed" = 8, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 104 GPIO status
    pub const GPIO13_STATUS = mmio(Address + 0x00000068, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 108 GPIO control including function select and overrides.
    pub const GPIO13_CTRL = mmio(Address + 0x0000006c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_ss_n" = 1, // desc:
            @"uart0_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_6" = 4, // desc:
            @"sio_13" = 5, // desc:
            @"pio0_13" = 6, // desc:
            @"pio1_13" = 7, // desc:
            @"usb_muxing_extphy_vpo" = 8, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 GPIO status
    pub const GPIO14_STATUS = mmio(Address + 0x00000070, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 116 GPIO control including function select and overrides.
    pub const GPIO14_CTRL = mmio(Address + 0x00000074, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_sclk" = 1, // desc:
            @"uart0_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_7" = 4, // desc:
            @"sio_14" = 5, // desc:
            @"pio0_14" = 6, // desc:
            @"pio1_14" = 7, // desc:
            @"usb_muxing_extphy_vmo" = 8, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 120 GPIO status
    pub const GPIO15_STATUS = mmio(Address + 0x00000078, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 124 GPIO control including function select and overrides.
    pub const GPIO15_CTRL = mmio(Address + 0x0000007c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_tx" = 1, // desc:
            @"uart0_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_7" = 4, // desc:
            @"sio_15" = 5, // desc:
            @"pio0_15" = 6, // desc:
            @"pio1_15" = 7, // desc:
            @"usb_muxing_digital_dp" = 8, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 128 GPIO status
    pub const GPIO16_STATUS = mmio(Address + 0x00000080, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 132 GPIO control including function select and overrides.
    pub const GPIO16_CTRL = mmio(Address + 0x00000084, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_rx" = 1, // desc:
            @"uart0_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_0" = 4, // desc:
            @"sio_16" = 5, // desc:
            @"pio0_16" = 6, // desc:
            @"pio1_16" = 7, // desc:
            @"usb_muxing_digital_dm" = 8, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 136 GPIO status
    pub const GPIO17_STATUS = mmio(Address + 0x00000088, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 140 GPIO control including function select and overrides.
    pub const GPIO17_CTRL = mmio(Address + 0x0000008c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_ss_n" = 1, // desc:
            @"uart0_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_0" = 4, // desc:
            @"sio_17" = 5, // desc:
            @"pio0_17" = 6, // desc:
            @"pio1_17" = 7, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 144 GPIO status
    pub const GPIO18_STATUS = mmio(Address + 0x00000090, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 148 GPIO control including function select and overrides.
    pub const GPIO18_CTRL = mmio(Address + 0x00000094, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_sclk" = 1, // desc:
            @"uart0_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_1" = 4, // desc:
            @"sio_18" = 5, // desc:
            @"pio0_18" = 6, // desc:
            @"pio1_18" = 7, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 152 GPIO status
    pub const GPIO19_STATUS = mmio(Address + 0x00000098, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 156 GPIO control including function select and overrides.
    pub const GPIO19_CTRL = mmio(Address + 0x0000009c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_tx" = 1, // desc:
            @"uart0_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_1" = 4, // desc:
            @"sio_19" = 5, // desc:
            @"pio0_19" = 6, // desc:
            @"pio1_19" = 7, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 160 GPIO status
    pub const GPIO20_STATUS = mmio(Address + 0x000000a0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 164 GPIO control including function select and overrides.
    pub const GPIO20_CTRL = mmio(Address + 0x000000a4, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_rx" = 1, // desc:
            @"uart1_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_2" = 4, // desc:
            @"sio_20" = 5, // desc:
            @"pio0_20" = 6, // desc:
            @"pio1_20" = 7, // desc:
            @"clocks_gpin_0" = 8, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 168 GPIO status
    pub const GPIO21_STATUS = mmio(Address + 0x000000a8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 172 GPIO control including function select and overrides.
    pub const GPIO21_CTRL = mmio(Address + 0x000000ac, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_ss_n" = 1, // desc:
            @"uart1_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_2" = 4, // desc:
            @"sio_21" = 5, // desc:
            @"pio0_21" = 6, // desc:
            @"pio1_21" = 7, // desc:
            @"clocks_gpout_0" = 8, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 176 GPIO status
    pub const GPIO22_STATUS = mmio(Address + 0x000000b0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 180 GPIO control including function select and overrides.
    pub const GPIO22_CTRL = mmio(Address + 0x000000b4, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_sclk" = 1, // desc:
            @"uart1_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_3" = 4, // desc:
            @"sio_22" = 5, // desc:
            @"pio0_22" = 6, // desc:
            @"pio1_22" = 7, // desc:
            @"clocks_gpin_1" = 8, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 184 GPIO status
    pub const GPIO23_STATUS = mmio(Address + 0x000000b8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 188 GPIO control including function select and overrides.
    pub const GPIO23_CTRL = mmio(Address + 0x000000bc, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi0_tx" = 1, // desc:
            @"uart1_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_3" = 4, // desc:
            @"sio_23" = 5, // desc:
            @"pio0_23" = 6, // desc:
            @"pio1_23" = 7, // desc:
            @"clocks_gpout_1" = 8, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 192 GPIO status
    pub const GPIO24_STATUS = mmio(Address + 0x000000c0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 196 GPIO control including function select and overrides.
    pub const GPIO24_CTRL = mmio(Address + 0x000000c4, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_rx" = 1, // desc:
            @"uart1_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_4" = 4, // desc:
            @"sio_24" = 5, // desc:
            @"pio0_24" = 6, // desc:
            @"pio1_24" = 7, // desc:
            @"clocks_gpout_2" = 8, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 200 GPIO status
    pub const GPIO25_STATUS = mmio(Address + 0x000000c8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 204 GPIO control including function select and overrides.
    pub const GPIO25_CTRL = mmio(Address + 0x000000cc, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_ss_n" = 1, // desc:
            @"uart1_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_4" = 4, // desc:
            @"sio_25" = 5, // desc:
            @"pio0_25" = 6, // desc:
            @"pio1_25" = 7, // desc:
            @"clocks_gpout_3" = 8, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 208 GPIO status
    pub const GPIO26_STATUS = mmio(Address + 0x000000d0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 212 GPIO control including function select and overrides.
    pub const GPIO26_CTRL = mmio(Address + 0x000000d4, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_sclk" = 1, // desc:
            @"uart1_cts" = 2, // desc:
            @"i2c1_sda" = 3, // desc:
            @"pwm_a_5" = 4, // desc:
            @"sio_26" = 5, // desc:
            @"pio0_26" = 6, // desc:
            @"pio1_26" = 7, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 216 GPIO status
    pub const GPIO27_STATUS = mmio(Address + 0x000000d8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 220 GPIO control including function select and overrides.
    pub const GPIO27_CTRL = mmio(Address + 0x000000dc, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_tx" = 1, // desc:
            @"uart1_rts" = 2, // desc:
            @"i2c1_scl" = 3, // desc:
            @"pwm_b_5" = 4, // desc:
            @"sio_27" = 5, // desc:
            @"pio0_27" = 6, // desc:
            @"pio1_27" = 7, // desc:
            @"usb_muxing_overcurr_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 224 GPIO status
    pub const GPIO28_STATUS = mmio(Address + 0x000000e0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 228 GPIO control including function select and overrides.
    pub const GPIO28_CTRL = mmio(Address + 0x000000e4, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_rx" = 1, // desc:
            @"uart0_tx" = 2, // desc:
            @"i2c0_sda" = 3, // desc:
            @"pwm_a_6" = 4, // desc:
            @"sio_28" = 5, // desc:
            @"pio0_28" = 6, // desc:
            @"pio1_28" = 7, // desc:
            @"usb_muxing_vbus_detect" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 232 GPIO status
    pub const GPIO29_STATUS = mmio(Address + 0x000000e8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 236 GPIO control including function select and overrides.
    pub const GPIO29_CTRL = mmio(Address + 0x000000ec, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"spi1_ss_n" = 1, // desc:
            @"uart0_rx" = 2, // desc:
            @"i2c0_scl" = 3, // desc:
            @"pwm_b_6" = 4, // desc:
            @"sio_29" = 5, // desc:
            @"pio0_29" = 6, // desc:
            @"pio1_29" = 7, // desc:
            @"usb_muxing_vbus_en" = 9, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 240 Raw Interrupts
    pub const INTR0 = mmio(Address + 0x000000f0, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 244 Raw Interrupts
    pub const INTR1 = mmio(Address + 0x000000f4, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 248 Raw Interrupts
    pub const INTR2 = mmio(Address + 0x000000f8, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 252 Raw Interrupts
    pub const INTR3 = mmio(Address + 0x000000fc, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 256 Interrupt Enable for proc0
    pub const PROC0_INTE0 = mmio(Address + 0x00000100, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 260 Interrupt Enable for proc0
    pub const PROC0_INTE1 = mmio(Address + 0x00000104, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 264 Interrupt Enable for proc0
    pub const PROC0_INTE2 = mmio(Address + 0x00000108, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 268 Interrupt Enable for proc0
    pub const PROC0_INTE3 = mmio(Address + 0x0000010c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 272 Interrupt Force for proc0
    pub const PROC0_INTF0 = mmio(Address + 0x00000110, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 276 Interrupt Force for proc0
    pub const PROC0_INTF1 = mmio(Address + 0x00000114, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 280 Interrupt Force for proc0
    pub const PROC0_INTF2 = mmio(Address + 0x00000118, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 284 Interrupt Force for proc0
    pub const PROC0_INTF3 = mmio(Address + 0x0000011c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 288 Interrupt status after masking & forcing for proc0
    pub const PROC0_INTS0 = mmio(Address + 0x00000120, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 292 Interrupt status after masking & forcing for proc0
    pub const PROC0_INTS1 = mmio(Address + 0x00000124, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 296 Interrupt status after masking & forcing for proc0
    pub const PROC0_INTS2 = mmio(Address + 0x00000128, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 300 Interrupt status after masking & forcing for proc0
    pub const PROC0_INTS3 = mmio(Address + 0x0000012c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 304 Interrupt Enable for proc1
    pub const PROC1_INTE0 = mmio(Address + 0x00000130, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 308 Interrupt Enable for proc1
    pub const PROC1_INTE1 = mmio(Address + 0x00000134, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 312 Interrupt Enable for proc1
    pub const PROC1_INTE2 = mmio(Address + 0x00000138, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 316 Interrupt Enable for proc1
    pub const PROC1_INTE3 = mmio(Address + 0x0000013c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 320 Interrupt Force for proc1
    pub const PROC1_INTF0 = mmio(Address + 0x00000140, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 324 Interrupt Force for proc1
    pub const PROC1_INTF1 = mmio(Address + 0x00000144, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 328 Interrupt Force for proc1
    pub const PROC1_INTF2 = mmio(Address + 0x00000148, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 332 Interrupt Force for proc1
    pub const PROC1_INTF3 = mmio(Address + 0x0000014c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 336 Interrupt status after masking & forcing for proc1
    pub const PROC1_INTS0 = mmio(Address + 0x00000150, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 340 Interrupt status after masking & forcing for proc1
    pub const PROC1_INTS1 = mmio(Address + 0x00000154, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 344 Interrupt status after masking & forcing for proc1
    pub const PROC1_INTS2 = mmio(Address + 0x00000158, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 348 Interrupt status after masking & forcing for proc1
    pub const PROC1_INTS3 = mmio(Address + 0x0000015c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 352 Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE0 = mmio(Address + 0x00000160, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 356 Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE1 = mmio(Address + 0x00000164, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 360 Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE2 = mmio(Address + 0x00000168, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 364 Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE3 = mmio(Address + 0x0000016c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 368 Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF0 = mmio(Address + 0x00000170, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 372 Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF1 = mmio(Address + 0x00000174, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 376 Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF2 = mmio(Address + 0x00000178, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 380 Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF3 = mmio(Address + 0x0000017c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 384 Interrupt status after masking & forcing for dormant_wake
    pub const DORMANT_WAKE_INTS0 = mmio(Address + 0x00000180, 32, packed struct {
        GPIO0_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO0_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO0_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO0_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO1_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO1_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO1_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO1_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO2_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO2_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO2_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO2_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO3_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO3_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO3_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO3_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO4_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO4_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO4_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO4_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO5_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO5_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO5_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO5_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO6_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO6_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO6_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO6_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO7_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO7_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO7_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO7_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 388 Interrupt status after masking & forcing for dormant_wake
    pub const DORMANT_WAKE_INTS1 = mmio(Address + 0x00000184, 32, packed struct {
        GPIO8_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO8_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO8_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO8_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO9_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO9_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO9_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO9_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO10_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO10_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO10_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO10_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO11_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO11_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO11_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO11_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO12_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO12_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO12_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO12_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO13_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO13_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO13_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO13_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO14_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO14_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO14_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO14_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO15_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO15_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO15_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO15_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 392 Interrupt status after masking & forcing for dormant_wake
    pub const DORMANT_WAKE_INTS2 = mmio(Address + 0x00000188, 32, packed struct {
        GPIO16_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO16_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO16_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO16_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO17_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO17_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO17_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO17_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO18_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO18_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO18_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO18_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO19_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO19_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO19_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO19_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO20_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO20_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO20_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO20_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO21_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO21_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO21_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO21_EDGE_HIGH: u1, // bit offset: 23 desc:
        GPIO22_LEVEL_LOW: u1, // bit offset: 24 desc:
        GPIO22_LEVEL_HIGH: u1, // bit offset: 25 desc:
        GPIO22_EDGE_LOW: u1, // bit offset: 26 desc:
        GPIO22_EDGE_HIGH: u1, // bit offset: 27 desc:
        GPIO23_LEVEL_LOW: u1, // bit offset: 28 desc:
        GPIO23_LEVEL_HIGH: u1, // bit offset: 29 desc:
        GPIO23_EDGE_LOW: u1, // bit offset: 30 desc:
        GPIO23_EDGE_HIGH: u1, // bit offset: 31 desc:
    });
    // byte offset: 396 Interrupt status after masking & forcing for dormant_wake
    pub const DORMANT_WAKE_INTS3 = mmio(Address + 0x0000018c, 32, packed struct {
        GPIO24_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO24_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO24_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO24_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO25_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO25_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO25_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO25_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO26_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO26_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO26_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO26_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO27_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO27_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO27_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO27_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO28_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO28_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO28_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO28_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO29_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO29_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO29_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO29_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
};
pub const IO_QSPI = extern struct {
    pub const Address: u32 = 0x40018000;
    // byte offset: 0 GPIO status
    pub const GPIO_QSPI_SCLK_STATUS = mmio(Address + 0x00000000, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 4 GPIO control including function select and overrides.
    pub const GPIO_QSPI_SCLK_CTRL = mmio(Address + 0x00000004, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"xip_sclk" = 0, // desc:
            @"sio_30" = 5, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 GPIO status
    pub const GPIO_QSPI_SS_STATUS = mmio(Address + 0x00000008, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 12 GPIO control including function select and overrides.
    pub const GPIO_QSPI_SS_CTRL = mmio(Address + 0x0000000c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"xip_ss_n" = 0, // desc:
            @"sio_31" = 5, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 GPIO status
    pub const GPIO_QSPI_SD0_STATUS = mmio(Address + 0x00000010, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 20 GPIO control including function select and overrides.
    pub const GPIO_QSPI_SD0_CTRL = mmio(Address + 0x00000014, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"xip_sd0" = 0, // desc:
            @"sio_32" = 5, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 GPIO status
    pub const GPIO_QSPI_SD1_STATUS = mmio(Address + 0x00000018, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 28 GPIO control including function select and overrides.
    pub const GPIO_QSPI_SD1_CTRL = mmio(Address + 0x0000001c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"xip_sd1" = 0, // desc:
            @"sio_33" = 5, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 GPIO status
    pub const GPIO_QSPI_SD2_STATUS = mmio(Address + 0x00000020, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 36 GPIO control including function select and overrides.
    pub const GPIO_QSPI_SD2_CTRL = mmio(Address + 0x00000024, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"xip_sd2" = 0, // desc:
            @"sio_34" = 5, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 GPIO status
    pub const GPIO_QSPI_SD3_STATUS = mmio(Address + 0x00000028, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        OUTFROMPERI: u1, // bit offset: 8 desc: output signal from selected peripheral, before register override is applied
        OUTTOPAD: u1, // bit offset: 9 desc: output signal to pad after register override is applied
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        OEFROMPERI: u1, // bit offset: 12 desc: output enable from selected peripheral, before register override is applied
        OETOPAD: u1, // bit offset: 13 desc: output enable to pad after register override is applied
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        INFROMPAD: u1, // bit offset: 17 desc: input signal from pad, before override is applied
        reserved13: u1 = 0,
        INTOPERI: u1, // bit offset: 19 desc: input signal to peripheral, after override is applied
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IRQFROMPAD: u1, // bit offset: 24 desc: interrupt from pad before override is applied
        reserved18: u1 = 0,
        IRQTOPROC: u1, // bit offset: 26 desc: interrupt to processors, after override is applied
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 44 GPIO control including function select and overrides.
    pub const GPIO_QSPI_SD3_CTRL = mmio(Address + 0x0000002c, 32, packed struct {
        FUNCSEL: enum(u5) { // bit offset: 0 desc: 0-31 -> selects pin function according to the gpio table\n 31 == NULL
            @"xip_sd3" = 0, // desc:
            @"sio_35" = 5, // desc:
            @"null" = 31, // desc:
            _, // non-exhaustive
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        OUTOVER: enum(u2) { // bit offset: 8 desc:
            @"NORMAL" = 0, // desc: drive output from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output from inverse of peripheral signal selected by funcsel
            @"LOW" = 2, // desc: drive output low
            @"HIGH" = 3, // desc: drive output high
        },
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        OEOVER: enum(u2) { // bit offset: 12 desc:
            @"NORMAL" = 0, // desc: drive output enable from peripheral signal selected by funcsel
            @"INVERT" = 1, // desc: drive output enable from inverse of peripheral signal selected by funcsel
            @"DISABLE" = 2, // desc: disable output
            @"ENABLE" = 3, // desc: enable output
        },
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        INOVER: enum(u2) { // bit offset: 16 desc:
            @"NORMAL" = 0, // desc: don't invert the peri input
            @"INVERT" = 1, // desc: invert the peri input
            @"LOW" = 2, // desc: drive peri input low
            @"HIGH" = 3, // desc: drive peri input high
        },
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        IRQOVER: enum(u2) { // bit offset: 28 desc:
            @"NORMAL" = 0, // desc: don't invert the interrupt
            @"INVERT" = 1, // desc: invert the interrupt
            @"LOW" = 2, // desc: drive interrupt low
            @"HIGH" = 3, // desc: drive interrupt high
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 Raw Interrupts
    pub const INTR = mmio(Address + 0x00000030, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 52 Interrupt Enable for proc0
    pub const PROC0_INTE = mmio(Address + 0x00000034, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 56 Interrupt Force for proc0
    pub const PROC0_INTF = mmio(Address + 0x00000038, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 60 Interrupt status after masking & forcing for proc0
    pub const PROC0_INTS = mmio(Address + 0x0000003c, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 64 Interrupt Enable for proc1
    pub const PROC1_INTE = mmio(Address + 0x00000040, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 68 Interrupt Force for proc1
    pub const PROC1_INTF = mmio(Address + 0x00000044, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 72 Interrupt status after masking & forcing for proc1
    pub const PROC1_INTS = mmio(Address + 0x00000048, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 76 Interrupt Enable for dormant_wake
    pub const DORMANT_WAKE_INTE = mmio(Address + 0x0000004c, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 80 Interrupt Force for dormant_wake
    pub const DORMANT_WAKE_INTF = mmio(Address + 0x00000050, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 84 Interrupt status after masking & forcing for dormant_wake
    pub const DORMANT_WAKE_INTS = mmio(Address + 0x00000054, 32, packed struct {
        GPIO_QSPI_SCLK_LEVEL_LOW: u1, // bit offset: 0 desc:
        GPIO_QSPI_SCLK_LEVEL_HIGH: u1, // bit offset: 1 desc:
        GPIO_QSPI_SCLK_EDGE_LOW: u1, // bit offset: 2 desc:
        GPIO_QSPI_SCLK_EDGE_HIGH: u1, // bit offset: 3 desc:
        GPIO_QSPI_SS_LEVEL_LOW: u1, // bit offset: 4 desc:
        GPIO_QSPI_SS_LEVEL_HIGH: u1, // bit offset: 5 desc:
        GPIO_QSPI_SS_EDGE_LOW: u1, // bit offset: 6 desc:
        GPIO_QSPI_SS_EDGE_HIGH: u1, // bit offset: 7 desc:
        GPIO_QSPI_SD0_LEVEL_LOW: u1, // bit offset: 8 desc:
        GPIO_QSPI_SD0_LEVEL_HIGH: u1, // bit offset: 9 desc:
        GPIO_QSPI_SD0_EDGE_LOW: u1, // bit offset: 10 desc:
        GPIO_QSPI_SD0_EDGE_HIGH: u1, // bit offset: 11 desc:
        GPIO_QSPI_SD1_LEVEL_LOW: u1, // bit offset: 12 desc:
        GPIO_QSPI_SD1_LEVEL_HIGH: u1, // bit offset: 13 desc:
        GPIO_QSPI_SD1_EDGE_LOW: u1, // bit offset: 14 desc:
        GPIO_QSPI_SD1_EDGE_HIGH: u1, // bit offset: 15 desc:
        GPIO_QSPI_SD2_LEVEL_LOW: u1, // bit offset: 16 desc:
        GPIO_QSPI_SD2_LEVEL_HIGH: u1, // bit offset: 17 desc:
        GPIO_QSPI_SD2_EDGE_LOW: u1, // bit offset: 18 desc:
        GPIO_QSPI_SD2_EDGE_HIGH: u1, // bit offset: 19 desc:
        GPIO_QSPI_SD3_LEVEL_LOW: u1, // bit offset: 20 desc:
        GPIO_QSPI_SD3_LEVEL_HIGH: u1, // bit offset: 21 desc:
        GPIO_QSPI_SD3_EDGE_LOW: u1, // bit offset: 22 desc:
        GPIO_QSPI_SD3_EDGE_HIGH: u1, // bit offset: 23 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
};
pub const PADS_BANK0 = extern struct {
    pub const Address: u32 = 0x4001c000;
    // byte offset: 0 Voltage select. Per bank control
    pub const VOLTAGE_SELECT = mmio(Address + 0x00000000, 32, packed struct {
        VOLTAGE_SELECT: enum(u1) { // bit offset: 0 desc:
            @"3v3" = 0, // desc: Set voltage to 3.3V (DVDD >= 2V5)
            @"1v8" = 1, // desc: Set voltage to 1.8V (DVDD <= 1V8)
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 4 Pad control register
    pub const GPIO0 = mmio(Address + 0x00000004, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 8 Pad control register
    pub const GPIO1 = mmio(Address + 0x00000008, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 12 Pad control register
    pub const GPIO2 = mmio(Address + 0x0000000c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 16 Pad control register
    pub const GPIO3 = mmio(Address + 0x00000010, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 20 Pad control register
    pub const GPIO4 = mmio(Address + 0x00000014, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 24 Pad control register
    pub const GPIO5 = mmio(Address + 0x00000018, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 28 Pad control register
    pub const GPIO6 = mmio(Address + 0x0000001c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 32 Pad control register
    pub const GPIO7 = mmio(Address + 0x00000020, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 36 Pad control register
    pub const GPIO8 = mmio(Address + 0x00000024, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 40 Pad control register
    pub const GPIO9 = mmio(Address + 0x00000028, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 44 Pad control register
    pub const GPIO10 = mmio(Address + 0x0000002c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 48 Pad control register
    pub const GPIO11 = mmio(Address + 0x00000030, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 52 Pad control register
    pub const GPIO12 = mmio(Address + 0x00000034, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 56 Pad control register
    pub const GPIO13 = mmio(Address + 0x00000038, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 60 Pad control register
    pub const GPIO14 = mmio(Address + 0x0000003c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 64 Pad control register
    pub const GPIO15 = mmio(Address + 0x00000040, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 68 Pad control register
    pub const GPIO16 = mmio(Address + 0x00000044, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 72 Pad control register
    pub const GPIO17 = mmio(Address + 0x00000048, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 76 Pad control register
    pub const GPIO18 = mmio(Address + 0x0000004c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 80 Pad control register
    pub const GPIO19 = mmio(Address + 0x00000050, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 84 Pad control register
    pub const GPIO20 = mmio(Address + 0x00000054, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 88 Pad control register
    pub const GPIO21 = mmio(Address + 0x00000058, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 92 Pad control register
    pub const GPIO22 = mmio(Address + 0x0000005c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 96 Pad control register
    pub const GPIO23 = mmio(Address + 0x00000060, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 100 Pad control register
    pub const GPIO24 = mmio(Address + 0x00000064, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 104 Pad control register
    pub const GPIO25 = mmio(Address + 0x00000068, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 108 Pad control register
    pub const GPIO26 = mmio(Address + 0x0000006c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 112 Pad control register
    pub const GPIO27 = mmio(Address + 0x00000070, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 116 Pad control register
    pub const GPIO28 = mmio(Address + 0x00000074, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 120 Pad control register
    pub const GPIO29 = mmio(Address + 0x00000078, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 124 Pad control register
    pub const SWCLK = mmio(Address + 0x0000007c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 128 Pad control register
    pub const SWD = mmio(Address + 0x00000080, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const PADS_QSPI = extern struct {
    pub const Address: u32 = 0x40020000;
    // byte offset: 0 Voltage select. Per bank control
    pub const VOLTAGE_SELECT = mmio(Address + 0x00000000, 32, packed struct {
        VOLTAGE_SELECT: enum(u1) { // bit offset: 0 desc:
            @"3v3" = 0, // desc: Set voltage to 3.3V (DVDD >= 2V5)
            @"1v8" = 1, // desc: Set voltage to 1.8V (DVDD <= 1V8)
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 4 Pad control register
    pub const GPIO_QSPI_SCLK = mmio(Address + 0x00000004, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 8 Pad control register
    pub const GPIO_QSPI_SD0 = mmio(Address + 0x00000008, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 12 Pad control register
    pub const GPIO_QSPI_SD1 = mmio(Address + 0x0000000c, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 16 Pad control register
    pub const GPIO_QSPI_SD2 = mmio(Address + 0x00000010, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 20 Pad control register
    pub const GPIO_QSPI_SD3 = mmio(Address + 0x00000014, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 24 Pad control register
    pub const GPIO_QSPI_SS = mmio(Address + 0x00000018, 32, packed struct {
        SLEWFAST: u1, // bit offset: 0 desc: Slew rate control. 1 = Fast, 0 = Slow
        SCHMITT: u1, // bit offset: 1 desc: Enable schmitt trigger
        PDE: u1, // bit offset: 2 desc: Pull down enable
        PUE: u1, // bit offset: 3 desc: Pull up enable
        DRIVE: enum(u2) { // bit offset: 4 desc: Drive strength.
            @"2mA" = 0, // desc:
            @"4mA" = 1, // desc:
            @"8mA" = 2, // desc:
            @"12mA" = 3, // desc:
        },
        IE: u1, // bit offset: 6 desc: Input enable
        OD: u1, // bit offset: 7 desc: Output disable. Has priority over output enable from peripherals
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const XOSC = extern struct {
    pub const Address: u32 = 0x40024000;
    // byte offset: 0 Crystal Oscillator Control
    pub const CTRL = mmio(Address + 0x00000000, 32, packed struct {
        FREQ_RANGE: enum(u12) { // bit offset: 0 desc: Frequency range. This resets to 0xAA0 and cannot be changed.
            @"1_15MHZ" = 2720, // desc:
            @"RESERVED_1" = 2721, // desc:
            @"RESERVED_2" = 2722, // desc:
            @"RESERVED_3" = 2723, // desc:
            _, // non-exhaustive
        },
        ENABLE: enum(u12) { // bit offset: 12 desc: On power-up this field is initialised to DISABLE and the chip runs from the ROSC.\n If the chip has subsequently been programmed to run from the XOSC then setting this field to DISABLE may lock-up the chip. If this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature.\n The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.
            @"DISABLE" = 3358, // desc:
            @"ENABLE" = 4011, // desc:
            _, // non-exhaustive
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 4 Crystal Oscillator Status
    pub const STATUS = mmio(Address + 0x00000004, 32, packed struct {
        FREQ_RANGE: enum(u2) { // bit offset: 0 desc: The current frequency range setting, always reads 0
            @"1_15MHZ" = 0, // desc:
            @"RESERVED_1" = 1, // desc:
            @"RESERVED_2" = 2, // desc:
            @"RESERVED_3" = 3, // desc:
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        ENABLED: u1, // bit offset: 12 desc: Oscillator is enabled but not necessarily running and stable, resets to 0
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        BADWRITE: u1, // bit offset: 24 desc: An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        reserved24: u1 = 0,
        reserved25: u1 = 0,
        reserved26: u1 = 0,
        STABLE: u1, // bit offset: 31 desc: Oscillator is running and stable
    });
    // byte offset: 8 Crystal Oscillator pause control\n This is used to save power by pausing the XOSC\n On power-up this field is initialised to WAKE\n An invalid write will also select WAKE\n WARNING: stop the PLLs before selecting dormant mode\n WARNING: setup the irq before selecting dormant mode
    pub const DORMANT = mmio(Address + 0x00000008, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 12 Controls the startup delay
    pub const STARTUP = mmio(Address + 0x0000000c, 32, packed struct {
        DELAY: u14, // bit offset: 0 desc: in multiples of 256*xtal_period
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        X4: u1, // bit offset: 20 desc: Multiplies the startup_delay by 4. This is of little value to the user given that the delay can be programmed directly
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 28 A down counter running at the xosc frequency which counts to zero and stops.\n To start the counter write a non-zero value.\n Can be used for short software pauses when setting up time sensitive hardware.
    pub const COUNT = mmio(Address + 0x0000001c, 32, packed struct {
        COUNT: u8, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const PLL_SYS = extern struct {
    pub const Address: u32 = 0x40028000;
    // byte offset: 0 Control and Status\n GENERAL CONSTRAINTS:\n Reference clock frequency min=5MHz, max=800MHz\n Feedback divider min=16, max=320\n VCO frequency min=400MHz, max=1600MHz
    pub const CS = mmio(Address + 0x00000000, 32, packed struct {
        REFDIV: u6, // bit offset: 0 desc: Divides the PLL input reference clock.\n Behaviour is undefined for div=0.\n PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        BYPASS: u1, // bit offset: 8 desc: Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        LOCK: u1, // bit offset: 31 desc: PLL is locked
    });
    // byte offset: 4 Controls the PLL power modes.
    pub const PWR = mmio(Address + 0x00000004, 32, packed struct {
        PD: u1, // bit offset: 0 desc: PLL powerdown\n To save power set high when PLL output not required.
        reserved0: u1 = 0,
        DSMPD: u1, // bit offset: 2 desc: PLL DSM powerdown\n Nothing is achieved by setting this low.
        POSTDIVPD: u1, // bit offset: 3 desc: PLL post divider powerdown\n To save power set high when PLL output not required or bypass=1.
        reserved1: u1 = 0,
        VCOPD: u1, // bit offset: 5 desc: PLL VCO powerdown\n To save power set high when PLL output not required or bypass=1.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 8 Feedback divisor\n (note: this PLL does not support fractional division)
    pub const FBDIV_INT = mmio(Address + 0x00000008, 32, packed struct {
        FBDIV_INT: u12, // bit offset: 0 desc: see ctrl reg description for constraints
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 12 Controls the PLL post dividers for the primary output\n (note: this PLL does not have a secondary output)\n the primary output is driven from VCO divided by postdiv1*postdiv2
    pub const PRIM = mmio(Address + 0x0000000c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        POSTDIV2: u3, // bit offset: 12 desc: divide by 1-7
        reserved12: u1 = 0,
        POSTDIV1: u3, // bit offset: 16 desc: divide by 1-7
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
    });
};
pub const PLL_USB = extern struct {
    pub const Address: u32 = 0x4002c000;
    // byte offset: 0 Control and Status\n GENERAL CONSTRAINTS:\n Reference clock frequency min=5MHz, max=800MHz\n Feedback divider min=16, max=320\n VCO frequency min=400MHz, max=1600MHz
    pub const CS = mmio(Address + 0x00000000, 32, packed struct {
        REFDIV: u6, // bit offset: 0 desc: Divides the PLL input reference clock.\n Behaviour is undefined for div=0.\n PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        BYPASS: u1, // bit offset: 8 desc: Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        LOCK: u1, // bit offset: 31 desc: PLL is locked
    });
    // byte offset: 4 Controls the PLL power modes.
    pub const PWR = mmio(Address + 0x00000004, 32, packed struct {
        PD: u1, // bit offset: 0 desc: PLL powerdown\n To save power set high when PLL output not required.
        reserved0: u1 = 0,
        DSMPD: u1, // bit offset: 2 desc: PLL DSM powerdown\n Nothing is achieved by setting this low.
        POSTDIVPD: u1, // bit offset: 3 desc: PLL post divider powerdown\n To save power set high when PLL output not required or bypass=1.
        reserved1: u1 = 0,
        VCOPD: u1, // bit offset: 5 desc: PLL VCO powerdown\n To save power set high when PLL output not required or bypass=1.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 8 Feedback divisor\n (note: this PLL does not support fractional division)
    pub const FBDIV_INT = mmio(Address + 0x00000008, 32, packed struct {
        FBDIV_INT: u12, // bit offset: 0 desc: see ctrl reg description for constraints
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 12 Controls the PLL post dividers for the primary output\n (note: this PLL does not have a secondary output)\n the primary output is driven from VCO divided by postdiv1*postdiv2
    pub const PRIM = mmio(Address + 0x0000000c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        POSTDIV2: u3, // bit offset: 12 desc: divide by 1-7
        reserved12: u1 = 0,
        POSTDIV1: u3, // bit offset: 16 desc: divide by 1-7
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
    });
};
pub const BUSCTRL = extern struct {
    pub const Address: u32 = 0x40030000;
    // byte offset: 0 Set the priority of each master for bus arbitration.
    pub const BUS_PRIORITY = mmio(Address + 0x00000000, 32, packed struct {
        PROC0: u1, // bit offset: 0 desc: 0 - low priority, 1 - high priority
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        PROC1: u1, // bit offset: 4 desc: 0 - low priority, 1 - high priority
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        DMA_R: u1, // bit offset: 8 desc: 0 - low priority, 1 - high priority
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        DMA_W: u1, // bit offset: 12 desc: 0 - low priority, 1 - high priority
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
    });
    // byte offset: 4 Bus priority acknowledge
    pub const BUS_PRIORITY_ACK = mmio(Address + 0x00000004, 32, packed struct {
        BUS_PRIORITY_ACK: u1, // bit offset: 0 desc: Goes to 1 once all arbiters have registered the new global priority levels.\n Arbiters update their local priority when servicing a new nonsequential access.\n In normal circumstances this will happen almost immediately.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 8 Bus fabric performance counter 0
    pub const PERFCTR0 = mmio(Address + 0x00000008, 32, packed struct {
        PERFCTR0: u24, // bit offset: 0 desc: Busfabric saturating performance counter 0\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 12 Bus fabric performance event select for PERFCTR0
    pub const PERFSEL0 = mmio(Address + 0x0000000c, 32, packed struct {
        PERFSEL0: u5, // bit offset: 0 desc: Select a performance event for PERFCTR0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 16 Bus fabric performance counter 1
    pub const PERFCTR1 = mmio(Address + 0x00000010, 32, packed struct {
        PERFCTR1: u24, // bit offset: 0 desc: Busfabric saturating performance counter 1\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 20 Bus fabric performance event select for PERFCTR1
    pub const PERFSEL1 = mmio(Address + 0x00000014, 32, packed struct {
        PERFSEL1: u5, // bit offset: 0 desc: Select a performance event for PERFCTR1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 24 Bus fabric performance counter 2
    pub const PERFCTR2 = mmio(Address + 0x00000018, 32, packed struct {
        PERFCTR2: u24, // bit offset: 0 desc: Busfabric saturating performance counter 2\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL2
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 28 Bus fabric performance event select for PERFCTR2
    pub const PERFSEL2 = mmio(Address + 0x0000001c, 32, packed struct {
        PERFSEL2: u5, // bit offset: 0 desc: Select a performance event for PERFCTR2
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 32 Bus fabric performance counter 3
    pub const PERFCTR3 = mmio(Address + 0x00000020, 32, packed struct {
        PERFCTR3: u24, // bit offset: 0 desc: Busfabric saturating performance counter 3\n Count some event signal from the busfabric arbiters.\n Write any value to clear. Select an event to count using PERFSEL3
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 36 Bus fabric performance event select for PERFCTR3
    pub const PERFSEL3 = mmio(Address + 0x00000024, 32, packed struct {
        PERFSEL3: u5, // bit offset: 0 desc: Select a performance event for PERFCTR3
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
};
pub const UART0 = extern struct {
    pub const Address: u32 = 0x40034000;
    // byte offset: 0 Data Register, UARTDR
    pub const UARTDR = mmio(Address + 0x00000000, 32, packed struct {
        DATA: u8, // bit offset: 0 desc: Receive (read) data character. Transmit (write) data character.
        FE: u1, // bit offset: 8 desc: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1, // bit offset: 9 desc: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
        BE: u1, // bit offset: 10 desc: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
        OE: u1, // bit offset: 11 desc: Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 4 Receive Status Register/Error Clear Register, UARTRSR/UARTECR
    pub const UARTRSR = mmio(Address + 0x00000004, 32, packed struct {
        FE: u1, // bit offset: 0 desc: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1, // bit offset: 1 desc: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        BE: u1, // bit offset: 2 desc: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
        OE: u1, // bit offset: 3 desc: Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 24 Flag Register, UARTFR
    pub const UARTFR = mmio(Address + 0x00000018, 32, packed struct {
        CTS: u1, // bit offset: 0 desc: Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
        DSR: u1, // bit offset: 1 desc: Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
        DCD: u1, // bit offset: 2 desc: Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
        BUSY: u1, // bit offset: 3 desc: UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
        RXFE: u1, // bit offset: 4 desc: Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
        TXFF: u1, // bit offset: 5 desc: Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
        RXFF: u1, // bit offset: 6 desc: Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
        TXFE: u1, // bit offset: 7 desc: Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
        RI: u1, // bit offset: 8 desc: Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
    });
    // byte offset: 32 IrDA Low-Power Counter Register, UARTILPR
    pub const UARTILPR = mmio(Address + 0x00000020, 32, packed struct {
        ILPDVSR: u8, // bit offset: 0 desc: 8-bit low-power divisor value. These bits are cleared to 0 at reset.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 36 Integer Baud Rate Register, UARTIBRD
    pub const UARTIBRD = mmio(Address + 0x00000024, 32, packed struct {
        BAUD_DIVINT: u16, // bit offset: 0 desc: The integer baud rate divisor. These bits are cleared to 0 on reset.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 40 Fractional Baud Rate Register, UARTFBRD
    pub const UARTFBRD = mmio(Address + 0x00000028, 32, packed struct {
        BAUD_DIVFRAC: u6, // bit offset: 0 desc: The fractional baud rate divisor. These bits are cleared to 0 on reset.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 44 Line Control Register, UARTLCR_H
    pub const UARTLCR_H = mmio(Address + 0x0000002c, 32, packed struct {
        BRK: u1, // bit offset: 0 desc: Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
        PEN: u1, // bit offset: 1 desc: Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
        EPS: u1, // bit offset: 2 desc: Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
        STP2: u1, // bit offset: 3 desc: Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
        FEN: u1, // bit offset: 4 desc: Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
        WLEN: u2, // bit offset: 5 desc: Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
        SPS: u1, // bit offset: 7 desc: Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 48 Control Register, UARTCR
    pub const UARTCR = mmio(Address + 0x00000030, 32, packed struct {
        UARTEN: u1, // bit offset: 0 desc: UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
        SIREN: u1, // bit offset: 1 desc: SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
        SIRLP: u1, // bit offset: 2 desc: SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        LBE: u1, // bit offset: 7 desc: Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
        TXE: u1, // bit offset: 8 desc: Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
        RXE: u1, // bit offset: 9 desc: Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
        DTR: u1, // bit offset: 10 desc: Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
        RTS: u1, // bit offset: 11 desc: Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
        OUT1: u1, // bit offset: 12 desc: This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
        OUT2: u1, // bit offset: 13 desc: This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
        RTSEN: u1, // bit offset: 14 desc: RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
        CTSEN: u1, // bit offset: 15 desc: CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 52 Interrupt FIFO Level Select Register, UARTIFLS
    pub const UARTIFLS = mmio(Address + 0x00000034, 32, packed struct {
        TXIFLSEL: u3, // bit offset: 0 desc: Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
        RXIFLSEL: u3, // bit offset: 3 desc: Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 56 Interrupt Mask Set/Clear Register, UARTIMSC
    pub const UARTIMSC = mmio(Address + 0x00000038, 32, packed struct {
        RIMIM: u1, // bit offset: 0 desc: nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
        CTSMIM: u1, // bit offset: 1 desc: nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
        DCDMIM: u1, // bit offset: 2 desc: nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
        DSRMIM: u1, // bit offset: 3 desc: nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
        RXIM: u1, // bit offset: 4 desc: Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
        TXIM: u1, // bit offset: 5 desc: Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
        RTIM: u1, // bit offset: 6 desc: Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
        FEIM: u1, // bit offset: 7 desc: Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
        PEIM: u1, // bit offset: 8 desc: Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
        BEIM: u1, // bit offset: 9 desc: Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
        OEIM: u1, // bit offset: 10 desc: Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 60 Raw Interrupt Status Register, UARTRIS
    pub const UARTRIS = mmio(Address + 0x0000003c, 32, packed struct {
        RIRMIS: u1, // bit offset: 0 desc: nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
        CTSRMIS: u1, // bit offset: 1 desc: nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
        DCDRMIS: u1, // bit offset: 2 desc: nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
        DSRRMIS: u1, // bit offset: 3 desc: nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
        RXRIS: u1, // bit offset: 4 desc: Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
        TXRIS: u1, // bit offset: 5 desc: Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
        RTRIS: u1, // bit offset: 6 desc: Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
        FERIS: u1, // bit offset: 7 desc: Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
        PERIS: u1, // bit offset: 8 desc: Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
        BERIS: u1, // bit offset: 9 desc: Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
        OERIS: u1, // bit offset: 10 desc: Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 64 Masked Interrupt Status Register, UARTMIS
    pub const UARTMIS = mmio(Address + 0x00000040, 32, packed struct {
        RIMMIS: u1, // bit offset: 0 desc: nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
        CTSMMIS: u1, // bit offset: 1 desc: nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
        DCDMMIS: u1, // bit offset: 2 desc: nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
        DSRMMIS: u1, // bit offset: 3 desc: nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
        RXMIS: u1, // bit offset: 4 desc: Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
        TXMIS: u1, // bit offset: 5 desc: Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
        RTMIS: u1, // bit offset: 6 desc: Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
        FEMIS: u1, // bit offset: 7 desc: Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
        PEMIS: u1, // bit offset: 8 desc: Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
        BEMIS: u1, // bit offset: 9 desc: Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
        OEMIS: u1, // bit offset: 10 desc: Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 68 Interrupt Clear Register, UARTICR
    pub const UARTICR = mmio(Address + 0x00000044, 32, packed struct {
        RIMIC: u1, // bit offset: 0 desc: nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
        CTSMIC: u1, // bit offset: 1 desc: nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
        DCDMIC: u1, // bit offset: 2 desc: nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
        DSRMIC: u1, // bit offset: 3 desc: nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
        RXIC: u1, // bit offset: 4 desc: Receive interrupt clear. Clears the UARTRXINTR interrupt.
        TXIC: u1, // bit offset: 5 desc: Transmit interrupt clear. Clears the UARTTXINTR interrupt.
        RTIC: u1, // bit offset: 6 desc: Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
        FEIC: u1, // bit offset: 7 desc: Framing error interrupt clear. Clears the UARTFEINTR interrupt.
        PEIC: u1, // bit offset: 8 desc: Parity error interrupt clear. Clears the UARTPEINTR interrupt.
        BEIC: u1, // bit offset: 9 desc: Break error interrupt clear. Clears the UARTBEINTR interrupt.
        OEIC: u1, // bit offset: 10 desc: Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 72 DMA Control Register, UARTDMACR
    pub const UARTDMACR = mmio(Address + 0x00000048, 32, packed struct {
        RXDMAE: u1, // bit offset: 0 desc: Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        TXDMAE: u1, // bit offset: 1 desc: Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        DMAONERR: u1, // bit offset: 2 desc: DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 4064 UARTPeriphID0 Register
    pub const UARTPERIPHID0 = mmio(Address + 0x00000fe0, 32, packed struct {
        PARTNUMBER0: u8, // bit offset: 0 desc: These bits read back as 0x11
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4068 UARTPeriphID1 Register
    pub const UARTPERIPHID1 = mmio(Address + 0x00000fe4, 32, packed struct {
        PARTNUMBER1: u4, // bit offset: 0 desc: These bits read back as 0x0
        DESIGNER0: u4, // bit offset: 4 desc: These bits read back as 0x1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4072 UARTPeriphID2 Register
    pub const UARTPERIPHID2 = mmio(Address + 0x00000fe8, 32, packed struct {
        DESIGNER1: u4, // bit offset: 0 desc: These bits read back as 0x4
        REVISION: u4, // bit offset: 4 desc: This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4076 UARTPeriphID3 Register
    pub const UARTPERIPHID3 = mmio(Address + 0x00000fec, 32, packed struct {
        CONFIGURATION: u8, // bit offset: 0 desc: These bits read back as 0x00
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4080 UARTPCellID0 Register
    pub const UARTPCELLID0 = mmio(Address + 0x00000ff0, 32, packed struct {
        UARTPCELLID0: u8, // bit offset: 0 desc: These bits read back as 0x0D
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4084 UARTPCellID1 Register
    pub const UARTPCELLID1 = mmio(Address + 0x00000ff4, 32, packed struct {
        UARTPCELLID1: u8, // bit offset: 0 desc: These bits read back as 0xF0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4088 UARTPCellID2 Register
    pub const UARTPCELLID2 = mmio(Address + 0x00000ff8, 32, packed struct {
        UARTPCELLID2: u8, // bit offset: 0 desc: These bits read back as 0x05
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4092 UARTPCellID3 Register
    pub const UARTPCELLID3 = mmio(Address + 0x00000ffc, 32, packed struct {
        UARTPCELLID3: u8, // bit offset: 0 desc: These bits read back as 0xB1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const UART1 = extern struct {
    pub const Address: u32 = 0x40038000;
    // byte offset: 0 Data Register, UARTDR
    pub const UARTDR = mmio(Address + 0x00000000, 32, packed struct {
        DATA: u8, // bit offset: 0 desc: Receive (read) data character. Transmit (write) data character.
        FE: u1, // bit offset: 8 desc: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1, // bit offset: 9 desc: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
        BE: u1, // bit offset: 10 desc: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
        OE: u1, // bit offset: 11 desc: Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 4 Receive Status Register/Error Clear Register, UARTRSR/UARTECR
    pub const UARTRSR = mmio(Address + 0x00000004, 32, packed struct {
        FE: u1, // bit offset: 0 desc: Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        PE: u1, // bit offset: 1 desc: Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
        BE: u1, // bit offset: 2 desc: Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
        OE: u1, // bit offset: 3 desc: Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 24 Flag Register, UARTFR
    pub const UARTFR = mmio(Address + 0x00000018, 32, packed struct {
        CTS: u1, // bit offset: 0 desc: Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
        DSR: u1, // bit offset: 1 desc: Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
        DCD: u1, // bit offset: 2 desc: Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
        BUSY: u1, // bit offset: 3 desc: UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
        RXFE: u1, // bit offset: 4 desc: Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
        TXFF: u1, // bit offset: 5 desc: Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
        RXFF: u1, // bit offset: 6 desc: Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
        TXFE: u1, // bit offset: 7 desc: Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
        RI: u1, // bit offset: 8 desc: Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
    });
    // byte offset: 32 IrDA Low-Power Counter Register, UARTILPR
    pub const UARTILPR = mmio(Address + 0x00000020, 32, packed struct {
        ILPDVSR: u8, // bit offset: 0 desc: 8-bit low-power divisor value. These bits are cleared to 0 at reset.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 36 Integer Baud Rate Register, UARTIBRD
    pub const UARTIBRD = mmio(Address + 0x00000024, 32, packed struct {
        BAUD_DIVINT: u16, // bit offset: 0 desc: The integer baud rate divisor. These bits are cleared to 0 on reset.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 40 Fractional Baud Rate Register, UARTFBRD
    pub const UARTFBRD = mmio(Address + 0x00000028, 32, packed struct {
        BAUD_DIVFRAC: u6, // bit offset: 0 desc: The fractional baud rate divisor. These bits are cleared to 0 on reset.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 44 Line Control Register, UARTLCR_H
    pub const UARTLCR_H = mmio(Address + 0x0000002c, 32, packed struct {
        BRK: u1, // bit offset: 0 desc: Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
        PEN: u1, // bit offset: 1 desc: Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
        EPS: u1, // bit offset: 2 desc: Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
        STP2: u1, // bit offset: 3 desc: Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
        FEN: u1, // bit offset: 4 desc: Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
        WLEN: u2, // bit offset: 5 desc: Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
        SPS: u1, // bit offset: 7 desc: Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 48 Control Register, UARTCR
    pub const UARTCR = mmio(Address + 0x00000030, 32, packed struct {
        UARTEN: u1, // bit offset: 0 desc: UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
        SIREN: u1, // bit offset: 1 desc: SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
        SIRLP: u1, // bit offset: 2 desc: SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        LBE: u1, // bit offset: 7 desc: Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
        TXE: u1, // bit offset: 8 desc: Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
        RXE: u1, // bit offset: 9 desc: Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
        DTR: u1, // bit offset: 10 desc: Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
        RTS: u1, // bit offset: 11 desc: Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
        OUT1: u1, // bit offset: 12 desc: This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
        OUT2: u1, // bit offset: 13 desc: This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
        RTSEN: u1, // bit offset: 14 desc: RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
        CTSEN: u1, // bit offset: 15 desc: CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 52 Interrupt FIFO Level Select Register, UARTIFLS
    pub const UARTIFLS = mmio(Address + 0x00000034, 32, packed struct {
        TXIFLSEL: u3, // bit offset: 0 desc: Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
        RXIFLSEL: u3, // bit offset: 3 desc: Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 56 Interrupt Mask Set/Clear Register, UARTIMSC
    pub const UARTIMSC = mmio(Address + 0x00000038, 32, packed struct {
        RIMIM: u1, // bit offset: 0 desc: nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
        CTSMIM: u1, // bit offset: 1 desc: nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
        DCDMIM: u1, // bit offset: 2 desc: nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
        DSRMIM: u1, // bit offset: 3 desc: nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
        RXIM: u1, // bit offset: 4 desc: Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
        TXIM: u1, // bit offset: 5 desc: Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
        RTIM: u1, // bit offset: 6 desc: Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
        FEIM: u1, // bit offset: 7 desc: Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
        PEIM: u1, // bit offset: 8 desc: Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
        BEIM: u1, // bit offset: 9 desc: Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
        OEIM: u1, // bit offset: 10 desc: Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 60 Raw Interrupt Status Register, UARTRIS
    pub const UARTRIS = mmio(Address + 0x0000003c, 32, packed struct {
        RIRMIS: u1, // bit offset: 0 desc: nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
        CTSRMIS: u1, // bit offset: 1 desc: nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
        DCDRMIS: u1, // bit offset: 2 desc: nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
        DSRRMIS: u1, // bit offset: 3 desc: nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
        RXRIS: u1, // bit offset: 4 desc: Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
        TXRIS: u1, // bit offset: 5 desc: Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
        RTRIS: u1, // bit offset: 6 desc: Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
        FERIS: u1, // bit offset: 7 desc: Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
        PERIS: u1, // bit offset: 8 desc: Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
        BERIS: u1, // bit offset: 9 desc: Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
        OERIS: u1, // bit offset: 10 desc: Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 64 Masked Interrupt Status Register, UARTMIS
    pub const UARTMIS = mmio(Address + 0x00000040, 32, packed struct {
        RIMMIS: u1, // bit offset: 0 desc: nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
        CTSMMIS: u1, // bit offset: 1 desc: nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
        DCDMMIS: u1, // bit offset: 2 desc: nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
        DSRMMIS: u1, // bit offset: 3 desc: nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
        RXMIS: u1, // bit offset: 4 desc: Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
        TXMIS: u1, // bit offset: 5 desc: Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
        RTMIS: u1, // bit offset: 6 desc: Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
        FEMIS: u1, // bit offset: 7 desc: Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
        PEMIS: u1, // bit offset: 8 desc: Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
        BEMIS: u1, // bit offset: 9 desc: Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
        OEMIS: u1, // bit offset: 10 desc: Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 68 Interrupt Clear Register, UARTICR
    pub const UARTICR = mmio(Address + 0x00000044, 32, packed struct {
        RIMIC: u1, // bit offset: 0 desc: nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
        CTSMIC: u1, // bit offset: 1 desc: nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
        DCDMIC: u1, // bit offset: 2 desc: nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
        DSRMIC: u1, // bit offset: 3 desc: nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
        RXIC: u1, // bit offset: 4 desc: Receive interrupt clear. Clears the UARTRXINTR interrupt.
        TXIC: u1, // bit offset: 5 desc: Transmit interrupt clear. Clears the UARTTXINTR interrupt.
        RTIC: u1, // bit offset: 6 desc: Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
        FEIC: u1, // bit offset: 7 desc: Framing error interrupt clear. Clears the UARTFEINTR interrupt.
        PEIC: u1, // bit offset: 8 desc: Parity error interrupt clear. Clears the UARTPEINTR interrupt.
        BEIC: u1, // bit offset: 9 desc: Break error interrupt clear. Clears the UARTBEINTR interrupt.
        OEIC: u1, // bit offset: 10 desc: Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 72 DMA Control Register, UARTDMACR
    pub const UARTDMACR = mmio(Address + 0x00000048, 32, packed struct {
        RXDMAE: u1, // bit offset: 0 desc: Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        TXDMAE: u1, // bit offset: 1 desc: Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        DMAONERR: u1, // bit offset: 2 desc: DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 4064 UARTPeriphID0 Register
    pub const UARTPERIPHID0 = mmio(Address + 0x00000fe0, 32, packed struct {
        PARTNUMBER0: u8, // bit offset: 0 desc: These bits read back as 0x11
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4068 UARTPeriphID1 Register
    pub const UARTPERIPHID1 = mmio(Address + 0x00000fe4, 32, packed struct {
        PARTNUMBER1: u4, // bit offset: 0 desc: These bits read back as 0x0
        DESIGNER0: u4, // bit offset: 4 desc: These bits read back as 0x1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4072 UARTPeriphID2 Register
    pub const UARTPERIPHID2 = mmio(Address + 0x00000fe8, 32, packed struct {
        DESIGNER1: u4, // bit offset: 0 desc: These bits read back as 0x4
        REVISION: u4, // bit offset: 4 desc: This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4076 UARTPeriphID3 Register
    pub const UARTPERIPHID3 = mmio(Address + 0x00000fec, 32, packed struct {
        CONFIGURATION: u8, // bit offset: 0 desc: These bits read back as 0x00
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4080 UARTPCellID0 Register
    pub const UARTPCELLID0 = mmio(Address + 0x00000ff0, 32, packed struct {
        UARTPCELLID0: u8, // bit offset: 0 desc: These bits read back as 0x0D
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4084 UARTPCellID1 Register
    pub const UARTPCELLID1 = mmio(Address + 0x00000ff4, 32, packed struct {
        UARTPCELLID1: u8, // bit offset: 0 desc: These bits read back as 0xF0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4088 UARTPCellID2 Register
    pub const UARTPCELLID2 = mmio(Address + 0x00000ff8, 32, packed struct {
        UARTPCELLID2: u8, // bit offset: 0 desc: These bits read back as 0x05
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4092 UARTPCellID3 Register
    pub const UARTPCELLID3 = mmio(Address + 0x00000ffc, 32, packed struct {
        UARTPCELLID3: u8, // bit offset: 0 desc: These bits read back as 0xB1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const SPI0 = extern struct {
    pub const Address: u32 = 0x4003c000;
    // byte offset: 0 Control register 0, SSPCR0 on page 3-4
    pub const SSPCR0 = mmio(Address + 0x00000000, 32, packed struct {
        DSS: u4, // bit offset: 0 desc: Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
        FRF: u2, // bit offset: 4 desc: Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
        SPO: u1, // bit offset: 6 desc: SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SPH: u1, // bit offset: 7 desc: SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SCR: u8, // bit offset: 8 desc: Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 4 Control register 1, SSPCR1 on page 3-5
    pub const SSPCR1 = mmio(Address + 0x00000004, 32, packed struct {
        LBM: u1, // bit offset: 0 desc: Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
        SSE: u1, // bit offset: 1 desc: Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
        MS: u1, // bit offset: 2 desc: Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
        SOD: u1, // bit offset: 3 desc: Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 8 Data register, SSPDR on page 3-6
    pub const SSPDR = mmio(Address + 0x00000008, 32, packed struct {
        DATA: u16, // bit offset: 0 desc: Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 12 Status register, SSPSR on page 3-7
    pub const SSPSR = mmio(Address + 0x0000000c, 32, packed struct {
        TFE: u1, // bit offset: 0 desc: Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
        TNF: u1, // bit offset: 1 desc: Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
        RNE: u1, // bit offset: 2 desc: Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
        RFF: u1, // bit offset: 3 desc: Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
        BSY: u1, // bit offset: 4 desc: PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 16 Clock prescale register, SSPCPSR on page 3-8
    pub const SSPCPSR = mmio(Address + 0x00000010, 32, packed struct {
        CPSDVSR: u8, // bit offset: 0 desc: Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 20 Interrupt mask set or clear register, SSPIMSC on page 3-9
    pub const SSPIMSC = mmio(Address + 0x00000014, 32, packed struct {
        RORIM: u1, // bit offset: 0 desc: Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
        RTIM: u1, // bit offset: 1 desc: Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
        RXIM: u1, // bit offset: 2 desc: Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
        TXIM: u1, // bit offset: 3 desc: Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 24 Raw interrupt status register, SSPRIS on page 3-10
    pub const SSPRIS = mmio(Address + 0x00000018, 32, packed struct {
        RORRIS: u1, // bit offset: 0 desc: Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
        RTRIS: u1, // bit offset: 1 desc: Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
        RXRIS: u1, // bit offset: 2 desc: Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
        TXRIS: u1, // bit offset: 3 desc: Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 28 Masked interrupt status register, SSPMIS on page 3-11
    pub const SSPMIS = mmio(Address + 0x0000001c, 32, packed struct {
        RORMIS: u1, // bit offset: 0 desc: Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
        RTMIS: u1, // bit offset: 1 desc: Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
        RXMIS: u1, // bit offset: 2 desc: Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
        TXMIS: u1, // bit offset: 3 desc: Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 32 Interrupt clear register, SSPICR on page 3-11
    pub const SSPICR = mmio(Address + 0x00000020, 32, packed struct {
        RORIC: u1, // bit offset: 0 desc: Clears the SSPRORINTR interrupt
        RTIC: u1, // bit offset: 1 desc: Clears the SSPRTINTR interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 36 DMA control register, SSPDMACR on page 3-12
    pub const SSPDMACR = mmio(Address + 0x00000024, 32, packed struct {
        RXDMAE: u1, // bit offset: 0 desc: Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        TXDMAE: u1, // bit offset: 1 desc: Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 4064 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID0 = mmio(Address + 0x00000fe0, 32, packed struct {
        PARTNUMBER0: u8, // bit offset: 0 desc: These bits read back as 0x22
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4068 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID1 = mmio(Address + 0x00000fe4, 32, packed struct {
        PARTNUMBER1: u4, // bit offset: 0 desc: These bits read back as 0x0
        DESIGNER0: u4, // bit offset: 4 desc: These bits read back as 0x1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4072 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID2 = mmio(Address + 0x00000fe8, 32, packed struct {
        DESIGNER1: u4, // bit offset: 0 desc: These bits read back as 0x4
        REVISION: u4, // bit offset: 4 desc: These bits return the peripheral revision
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4076 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID3 = mmio(Address + 0x00000fec, 32, packed struct {
        CONFIGURATION: u8, // bit offset: 0 desc: These bits read back as 0x00
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4080 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID0 = mmio(Address + 0x00000ff0, 32, packed struct {
        SSPPCELLID0: u8, // bit offset: 0 desc: These bits read back as 0x0D
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4084 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID1 = mmio(Address + 0x00000ff4, 32, packed struct {
        SSPPCELLID1: u8, // bit offset: 0 desc: These bits read back as 0xF0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4088 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID2 = mmio(Address + 0x00000ff8, 32, packed struct {
        SSPPCELLID2: u8, // bit offset: 0 desc: These bits read back as 0x05
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4092 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID3 = mmio(Address + 0x00000ffc, 32, packed struct {
        SSPPCELLID3: u8, // bit offset: 0 desc: These bits read back as 0xB1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const SPI1 = extern struct {
    pub const Address: u32 = 0x40040000;
    // byte offset: 0 Control register 0, SSPCR0 on page 3-4
    pub const SSPCR0 = mmio(Address + 0x00000000, 32, packed struct {
        DSS: u4, // bit offset: 0 desc: Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
        FRF: u2, // bit offset: 4 desc: Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
        SPO: u1, // bit offset: 6 desc: SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SPH: u1, // bit offset: 7 desc: SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
        SCR: u8, // bit offset: 8 desc: Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 4 Control register 1, SSPCR1 on page 3-5
    pub const SSPCR1 = mmio(Address + 0x00000004, 32, packed struct {
        LBM: u1, // bit offset: 0 desc: Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
        SSE: u1, // bit offset: 1 desc: Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
        MS: u1, // bit offset: 2 desc: Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
        SOD: u1, // bit offset: 3 desc: Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 8 Data register, SSPDR on page 3-6
    pub const SSPDR = mmio(Address + 0x00000008, 32, packed struct {
        DATA: u16, // bit offset: 0 desc: Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 12 Status register, SSPSR on page 3-7
    pub const SSPSR = mmio(Address + 0x0000000c, 32, packed struct {
        TFE: u1, // bit offset: 0 desc: Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
        TNF: u1, // bit offset: 1 desc: Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
        RNE: u1, // bit offset: 2 desc: Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
        RFF: u1, // bit offset: 3 desc: Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
        BSY: u1, // bit offset: 4 desc: PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 16 Clock prescale register, SSPCPSR on page 3-8
    pub const SSPCPSR = mmio(Address + 0x00000010, 32, packed struct {
        CPSDVSR: u8, // bit offset: 0 desc: Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 20 Interrupt mask set or clear register, SSPIMSC on page 3-9
    pub const SSPIMSC = mmio(Address + 0x00000014, 32, packed struct {
        RORIM: u1, // bit offset: 0 desc: Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
        RTIM: u1, // bit offset: 1 desc: Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
        RXIM: u1, // bit offset: 2 desc: Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
        TXIM: u1, // bit offset: 3 desc: Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 24 Raw interrupt status register, SSPRIS on page 3-10
    pub const SSPRIS = mmio(Address + 0x00000018, 32, packed struct {
        RORRIS: u1, // bit offset: 0 desc: Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
        RTRIS: u1, // bit offset: 1 desc: Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
        RXRIS: u1, // bit offset: 2 desc: Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
        TXRIS: u1, // bit offset: 3 desc: Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 28 Masked interrupt status register, SSPMIS on page 3-11
    pub const SSPMIS = mmio(Address + 0x0000001c, 32, packed struct {
        RORMIS: u1, // bit offset: 0 desc: Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
        RTMIS: u1, // bit offset: 1 desc: Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
        RXMIS: u1, // bit offset: 2 desc: Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
        TXMIS: u1, // bit offset: 3 desc: Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 32 Interrupt clear register, SSPICR on page 3-11
    pub const SSPICR = mmio(Address + 0x00000020, 32, packed struct {
        RORIC: u1, // bit offset: 0 desc: Clears the SSPRORINTR interrupt
        RTIC: u1, // bit offset: 1 desc: Clears the SSPRTINTR interrupt
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 36 DMA control register, SSPDMACR on page 3-12
    pub const SSPDMACR = mmio(Address + 0x00000024, 32, packed struct {
        RXDMAE: u1, // bit offset: 0 desc: Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
        TXDMAE: u1, // bit offset: 1 desc: Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 4064 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID0 = mmio(Address + 0x00000fe0, 32, packed struct {
        PARTNUMBER0: u8, // bit offset: 0 desc: These bits read back as 0x22
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4068 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID1 = mmio(Address + 0x00000fe4, 32, packed struct {
        PARTNUMBER1: u4, // bit offset: 0 desc: These bits read back as 0x0
        DESIGNER0: u4, // bit offset: 4 desc: These bits read back as 0x1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4072 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID2 = mmio(Address + 0x00000fe8, 32, packed struct {
        DESIGNER1: u4, // bit offset: 0 desc: These bits read back as 0x4
        REVISION: u4, // bit offset: 4 desc: These bits return the peripheral revision
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4076 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
    pub const SSPPERIPHID3 = mmio(Address + 0x00000fec, 32, packed struct {
        CONFIGURATION: u8, // bit offset: 0 desc: These bits read back as 0x00
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4080 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID0 = mmio(Address + 0x00000ff0, 32, packed struct {
        SSPPCELLID0: u8, // bit offset: 0 desc: These bits read back as 0x0D
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4084 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID1 = mmio(Address + 0x00000ff4, 32, packed struct {
        SSPPCELLID1: u8, // bit offset: 0 desc: These bits read back as 0xF0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4088 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID2 = mmio(Address + 0x00000ff8, 32, packed struct {
        SSPPCELLID2: u8, // bit offset: 0 desc: These bits read back as 0x05
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4092 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
    pub const SSPPCELLID3 = mmio(Address + 0x00000ffc, 32, packed struct {
        SSPPCELLID3: u8, // bit offset: 0 desc: These bits read back as 0xB1
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const I2C0 = extern struct {
    pub const Address: u32 = 0x40044000;
    // byte offset: 0 I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
    pub const IC_CON = mmio(Address + 0x00000000, 32, packed struct {
        MASTER_MODE: enum(u1) { // bit offset: 0 desc: This bit controls whether the DW_apb_i2c master is enabled.\n\n NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.
            @"DISABLED" = 0, // desc: Master mode is disabled
            @"ENABLED" = 1, // desc: Master mode is enabled
        },
        SPEED: enum(u2) { // bit offset: 1 desc: These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n 1: standard mode (100 kbit/s)\n\n 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n 3: high speed mode (3.4 Mbit/s)\n\n Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
            @"STANDARD" = 1, // desc: Standard Speed mode of operation
            @"FAST" = 2, // desc: Fast or Fast Plus mode of operation
            @"HIGH" = 3, // desc: High Speed mode of operation
            _, // non-exhaustive
        },
        IC_10BITADDR_SLAVE: enum(u1) { // bit offset: 3 desc: When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
            @"ADDR_7BITS" = 0, // desc: Slave 7Bit addressing
            @"ADDR_10BITS" = 1, // desc: Slave 10Bit addressing
        },
        IC_10BITADDR_MASTER: enum(u1) { // bit offset: 4 desc: Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
            @"ADDR_7BITS" = 0, // desc: Master 7Bit addressing mode
            @"ADDR_10BITS" = 1, // desc: Master 10Bit addressing mode
        },
        IC_RESTART_EN: enum(u1) { // bit offset: 5 desc: Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n Reset value: ENABLED
            @"DISABLED" = 0, // desc: Master restart disabled
            @"ENABLED" = 1, // desc: Master restart enabled
        },
        IC_SLAVE_DISABLE: enum(u1) { // bit offset: 6 desc: This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.
            @"SLAVE_ENABLED" = 0, // desc: Slave mode is enabled
            @"SLAVE_DISABLED" = 1, // desc: Slave mode is disabled
        },
        STOP_DET_IFADDRESSED: enum(u1) { // bit offset: 7 desc: In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed. - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).
            @"DISABLED" = 0, // desc: slave issues STOP_DET intr always
            @"ENABLED" = 1, // desc: slave issues STOP_DET intr only if addressed
        },
        TX_EMPTY_CTRL: enum(u1) { // bit offset: 8 desc: This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
            @"DISABLED" = 0, // desc: Default behaviour of TX_EMPTY interrupt
            @"ENABLED" = 1, // desc: Controlled generation of TX_EMPTY interrupt
        },
        RX_FIFO_FULL_HLD_CTRL: enum(u1) { // bit offset: 9 desc: This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
            @"DISABLED" = 0, // desc: Overflow when RX_FIFO is full
            @"ENABLED" = 1, // desc: Hold bus when RX_FIFO is full
        },
        STOP_DET_IF_MASTER_ACTIVE: u1, // bit offset: 10 desc: Master issues the STOP_DET interrupt irrespective of whether master is active or not
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 4 I2C Target Address Register\n\n This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
    pub const IC_TAR = mmio(Address + 0x00000004, 32, packed struct {
        IC_TAR: u10, // bit offset: 0 desc: This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.
        GC_OR_START: enum(u1) { // bit offset: 10 desc: If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
            @"GENERAL_CALL" = 0, // desc: GENERAL_CALL byte transmission
            @"START_BYTE" = 1, // desc: START byte transmission
        },
        SPECIAL: enum(u1) { // bit offset: 11 desc: This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
            @"DISABLED" = 0, // desc: Disables programming of GENERAL_CALL or START_BYTE transmission
            @"ENABLED" = 1, // desc: Enables programming of GENERAL_CALL or START_BYTE transmission
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 8 I2C Slave Address Register
    pub const IC_SAR = mmio(Address + 0x00000008, 32, packed struct {
        IC_SAR: u10, // bit offset: 0 desc: The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
    });
    // byte offset: 16 I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n The size of the register changes as follows:\n\n Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
    pub const IC_DATA_CMD = mmio(Address + 0x00000010, 32, packed struct {
        DAT: u8, // bit offset: 0 desc: This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n Reset value: 0x0
        CMD: enum(u1) { // bit offset: 8 desc: This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset value: 0x0
            @"WRITE" = 0, // desc: Master Write Command
            @"READ" = 1, // desc: Master Read Command
        },
        STOP: enum(u1) { // bit offset: 9 desc: This bit controls whether a STOP is issued after the byte is sent or received.\n\n - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0
            @"DISABLE" = 0, // desc: Don't Issue STOP after this command
            @"ENABLE" = 1, // desc: Issue STOP after this command
        },
        RESTART: enum(u1) { // bit offset: 10 desc: This bit controls whether a RESTART is issued before the byte is sent or received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n Reset value: 0x0
            @"DISABLE" = 0, // desc: Don't Issue RESTART before this command
            @"ENABLE" = 1, // desc: Issue RESTART before this command
        },
        FIRST_DATA_BYTE: enum(u1) { // bit offset: 11 desc: Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.\n\n Reset value : 0x0\n\n NOTE: In case of APB_DATA_WIDTH=8,\n\n 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.\n\n 2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).\n\n 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status.
            @"INACTIVE" = 0, // desc: Sequential data byte received
            @"ACTIVE" = 1, // desc: Non sequential data byte received
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 20 Standard Speed I2C Clock SCL High Count Register
    pub const IC_SS_SCL_HCNT = mmio(Address + 0x00000014, 32, packed struct {
        IC_SS_SCL_HCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 24 Standard Speed I2C Clock SCL Low Count Register
    pub const IC_SS_SCL_LCNT = mmio(Address + 0x00000018, 32, packed struct {
        IC_SS_SCL_LCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 28 Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
    pub const IC_FS_SCL_HCNT = mmio(Address + 0x0000001c, 32, packed struct {
        IC_FS_SCL_HCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 32 Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
    pub const IC_FS_SCL_LCNT = mmio(Address + 0x00000020, 32, packed struct {
        IC_FS_SCL_LCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 44 I2C Interrupt Status Register\n\n Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
    pub const IC_INTR_STAT = mmio(Address + 0x0000002c, 32, packed struct {
        R_RX_UNDER: enum(u1) { // bit offset: 0 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_UNDER interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_UNDER interrupt is active
        },
        R_RX_OVER: enum(u1) { // bit offset: 1 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RX_OVER interrupt is active
        },
        R_RX_FULL: enum(u1) { // bit offset: 2 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RX_FULL interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RX_FULL interrupt is active
        },
        R_TX_OVER: enum(u1) { // bit offset: 3 desc: See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_TX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: R_TX_OVER interrupt is active
        },
        R_TX_EMPTY: enum(u1) { // bit offset: 4 desc: See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_TX_EMPTY interrupt is inactive
            @"ACTIVE" = 1, // desc: R_TX_EMPTY interrupt is active
        },
        R_RD_REQ: enum(u1) { // bit offset: 5 desc: See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RD_REQ interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RD_REQ interrupt is active
        },
        R_TX_ABRT: enum(u1) { // bit offset: 6 desc: See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_TX_ABRT interrupt is inactive
            @"ACTIVE" = 1, // desc: R_TX_ABRT interrupt is active
        },
        R_RX_DONE: enum(u1) { // bit offset: 7 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RX_DONE interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RX_DONE interrupt is active
        },
        R_ACTIVITY: enum(u1) { // bit offset: 8 desc: See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_ACTIVITY interrupt is inactive
            @"ACTIVE" = 1, // desc: R_ACTIVITY interrupt is active
        },
        R_STOP_DET: enum(u1) { // bit offset: 9 desc: See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_STOP_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: R_STOP_DET interrupt is active
        },
        R_START_DET: enum(u1) { // bit offset: 10 desc: See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_START_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: R_START_DET interrupt is active
        },
        R_GEN_CALL: enum(u1) { // bit offset: 11 desc: See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_GEN_CALL interrupt is inactive
            @"ACTIVE" = 1, // desc: R_GEN_CALL interrupt is active
        },
        R_RESTART_DET: enum(u1) { // bit offset: 12 desc: See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RESTART_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RESTART_DET interrupt is active
        },
        R_MASTER_ON_HOLD: enum(u1) { // bit offset: 13 desc: See IC_RAW_INTR_STAT for a detailed description of R_MASTER_ON_HOLD bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_MASTER_ON_HOLD interrupt is inactive
            @"ACTIVE" = 1, // desc: R_MASTER_ON_HOLD interrupt is active
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
    });
    // byte offset: 48 I2C Interrupt Mask Register.\n\n These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
    pub const IC_INTR_MASK = mmio(Address + 0x00000030, 32, packed struct {
        M_RX_UNDER: enum(u1) { // bit offset: 0 desc: This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_UNDER interrupt is masked
            @"DISABLED" = 1, // desc: RX_UNDER interrupt is unmasked
        },
        M_RX_OVER: enum(u1) { // bit offset: 1 desc: This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_OVER interrupt is masked
            @"DISABLED" = 1, // desc: RX_OVER interrupt is unmasked
        },
        M_RX_FULL: enum(u1) { // bit offset: 2 desc: This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_FULL interrupt is masked
            @"DISABLED" = 1, // desc: RX_FULL interrupt is unmasked
        },
        M_TX_OVER: enum(u1) { // bit offset: 3 desc: This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: TX_OVER interrupt is masked
            @"DISABLED" = 1, // desc: TX_OVER interrupt is unmasked
        },
        M_TX_EMPTY: enum(u1) { // bit offset: 4 desc: This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: TX_EMPTY interrupt is masked
            @"DISABLED" = 1, // desc: TX_EMPTY interrupt is unmasked
        },
        M_RD_REQ: enum(u1) { // bit offset: 5 desc: This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RD_REQ interrupt is masked
            @"DISABLED" = 1, // desc: RD_REQ interrupt is unmasked
        },
        M_TX_ABRT: enum(u1) { // bit offset: 6 desc: This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: TX_ABORT interrupt is masked
            @"DISABLED" = 1, // desc: TX_ABORT interrupt is unmasked
        },
        M_RX_DONE: enum(u1) { // bit offset: 7 desc: This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_DONE interrupt is masked
            @"DISABLED" = 1, // desc: RX_DONE interrupt is unmasked
        },
        M_ACTIVITY: enum(u1) { // bit offset: 8 desc: This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: ACTIVITY interrupt is masked
            @"DISABLED" = 1, // desc: ACTIVITY interrupt is unmasked
        },
        M_STOP_DET: enum(u1) { // bit offset: 9 desc: This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: STOP_DET interrupt is masked
            @"DISABLED" = 1, // desc: STOP_DET interrupt is unmasked
        },
        M_START_DET: enum(u1) { // bit offset: 10 desc: This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: START_DET interrupt is masked
            @"DISABLED" = 1, // desc: START_DET interrupt is unmasked
        },
        M_GEN_CALL: enum(u1) { // bit offset: 11 desc: This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: GEN_CALL interrupt is masked
            @"DISABLED" = 1, // desc: GEN_CALL interrupt is unmasked
        },
        M_RESTART_DET: enum(u1) { // bit offset: 12 desc: This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: RESTART_DET interrupt is masked
            @"DISABLED" = 1, // desc: RESTART_DET interrupt is unmasked
        },
        M_MASTER_ON_HOLD_READ_ONLY: enum(u1) { // bit offset: 13 desc: This M_MASTER_ON_HOLD_read_only bit masks the R_MASTER_ON_HOLD interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: MASTER_ON_HOLD interrupt is masked
            @"DISABLED" = 1, // desc: MASTER_ON_HOLD interrupt is unmasked
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
    });
    // byte offset: 52 I2C Raw Interrupt Status Register\n\n Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
    pub const IC_RAW_INTR_STAT = mmio(Address + 0x00000034, 32, packed struct {
        RX_UNDER: enum(u1) { // bit offset: 0 desc: Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_UNDER interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_UNDER interrupt is active
        },
        RX_OVER: enum(u1) { // bit offset: 1 desc: Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_OVER interrupt is active
        },
        RX_FULL: enum(u1) { // bit offset: 2 desc: Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_FULL interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_FULL interrupt is active
        },
        TX_OVER: enum(u1) { // bit offset: 3 desc: Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: TX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: TX_OVER interrupt is active
        },
        TX_EMPTY: enum(u1) { // bit offset: 4 desc: The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.\n\n Reset value: 0x0.
            @"INACTIVE" = 0, // desc: TX_EMPTY interrupt is inactive
            @"ACTIVE" = 1, // desc: TX_EMPTY interrupt is active
        },
        RD_REQ: enum(u1) { // bit offset: 5 desc: This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RD_REQ interrupt is inactive
            @"ACTIVE" = 1, // desc: RD_REQ interrupt is active
        },
        TX_ABRT: enum(u1) { // bit offset: 6 desc: This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.\n\n Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: TX_ABRT interrupt is inactive
            @"ACTIVE" = 1, // desc: TX_ABRT interrupt is active
        },
        RX_DONE: enum(u1) { // bit offset: 7 desc: When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_DONE interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_DONE interrupt is active
        },
        ACTIVITY: enum(u1) { // bit offset: 8 desc: This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RAW_INTR_ACTIVITY interrupt is inactive
            @"ACTIVE" = 1, // desc: RAW_INTR_ACTIVITY interrupt is active
        },
        STOP_DET: enum(u1) { // bit offset: 9 desc: Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1 (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0
            @"INACTIVE" = 0, // desc: STOP_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: STOP_DET interrupt is active
        },
        START_DET: enum(u1) { // bit offset: 10 desc: Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: START_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: START_DET interrupt is active
        },
        GEN_CALL: enum(u1) { // bit offset: 11 desc: Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: GEN_CALL interrupt is inactive
            @"ACTIVE" = 1, // desc: GEN_CALL interrupt is active
        },
        RESTART_DET: enum(u1) { // bit offset: 12 desc: Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RESTART_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: RESTART_DET interrupt is active
        },
        MASTER_ON_HOLD: enum(u1) { // bit offset: 13 desc: Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: MASTER_ON_HOLD interrupt is inactive
            @"ACTIVE" = 1, // desc: MASTER_ON_HOLD interrupt is active
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
    });
    // byte offset: 56 I2C Receive FIFO Threshold Register
    pub const IC_RX_TL = mmio(Address + 0x00000038, 32, packed struct {
        RX_TL: u8, // bit offset: 0 desc: Receive FIFO Threshold Level.\n\n Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 60 I2C Transmit FIFO Threshold Register
    pub const IC_TX_TL = mmio(Address + 0x0000003c, 32, packed struct {
        TX_TL: u8, // bit offset: 0 desc: Transmit FIFO Threshold Level.\n\n Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 64 Clear Combined and Individual Interrupt Register
    pub const IC_CLR_INTR = mmio(Address + 0x00000040, 32, packed struct {
        CLR_INTR: u1, // bit offset: 0 desc: Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 68 Clear RX_UNDER Interrupt Register
    pub const IC_CLR_RX_UNDER = mmio(Address + 0x00000044, 32, packed struct {
        CLR_RX_UNDER: u1, // bit offset: 0 desc: Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 72 Clear RX_OVER Interrupt Register
    pub const IC_CLR_RX_OVER = mmio(Address + 0x00000048, 32, packed struct {
        CLR_RX_OVER: u1, // bit offset: 0 desc: Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 76 Clear TX_OVER Interrupt Register
    pub const IC_CLR_TX_OVER = mmio(Address + 0x0000004c, 32, packed struct {
        CLR_TX_OVER: u1, // bit offset: 0 desc: Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 80 Clear RD_REQ Interrupt Register
    pub const IC_CLR_RD_REQ = mmio(Address + 0x00000050, 32, packed struct {
        CLR_RD_REQ: u1, // bit offset: 0 desc: Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 84 Clear TX_ABRT Interrupt Register
    pub const IC_CLR_TX_ABRT = mmio(Address + 0x00000054, 32, packed struct {
        CLR_TX_ABRT: u1, // bit offset: 0 desc: Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 88 Clear RX_DONE Interrupt Register
    pub const IC_CLR_RX_DONE = mmio(Address + 0x00000058, 32, packed struct {
        CLR_RX_DONE: u1, // bit offset: 0 desc: Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 92 Clear ACTIVITY Interrupt Register
    pub const IC_CLR_ACTIVITY = mmio(Address + 0x0000005c, 32, packed struct {
        CLR_ACTIVITY: u1, // bit offset: 0 desc: Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 96 Clear STOP_DET Interrupt Register
    pub const IC_CLR_STOP_DET = mmio(Address + 0x00000060, 32, packed struct {
        CLR_STOP_DET: u1, // bit offset: 0 desc: Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 100 Clear START_DET Interrupt Register
    pub const IC_CLR_START_DET = mmio(Address + 0x00000064, 32, packed struct {
        CLR_START_DET: u1, // bit offset: 0 desc: Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 104 Clear GEN_CALL Interrupt Register
    pub const IC_CLR_GEN_CALL = mmio(Address + 0x00000068, 32, packed struct {
        CLR_GEN_CALL: u1, // bit offset: 0 desc: Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 108 I2C Enable Register
    pub const IC_ENABLE = mmio(Address + 0x0000006c, 32, packed struct {
        ENABLE: enum(u1) { // bit offset: 0 desc: Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
            @"DISABLED" = 0, // desc: I2C is disabled
            @"ENABLED" = 1, // desc: I2C is enabled
        },
        ABORT: enum(u1) { // bit offset: 1 desc: When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n Reset value: 0x0
            @"DISABLE" = 0, // desc: ABORT operation not in progress
            @"ENABLED" = 1, // desc: ABORT operation in progress
        },
        TX_CMD_BLOCK: enum(u1) { // bit offset: 2 desc: In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
            @"NOT_BLOCKED" = 0, // desc: Tx Command execution not blocked
            @"BLOCKED" = 1, // desc: Tx Command execution blocked
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 112 I2C Status Register\n\n This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
    pub const IC_STATUS = mmio(Address + 0x00000070, 32, packed struct {
        ACTIVITY: enum(u1) { // bit offset: 0 desc: I2C Activity Status. Reset value: 0x0
            @"INACTIVE" = 0, // desc: I2C is idle
            @"ACTIVE" = 1, // desc: I2C is active
        },
        TFNF: enum(u1) { // bit offset: 1 desc: Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
            @"FULL" = 0, // desc: Tx FIFO is full
            @"NOT_FULL" = 1, // desc: Tx FIFO not full
        },
        TFE: enum(u1) { // bit offset: 2 desc: Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
            @"NON_EMPTY" = 0, // desc: Tx FIFO not empty
            @"EMPTY" = 1, // desc: Tx FIFO is empty
        },
        RFNE: enum(u1) { // bit offset: 3 desc: Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
            @"EMPTY" = 0, // desc: Rx FIFO is empty
            @"NOT_EMPTY" = 1, // desc: Rx FIFO not empty
        },
        RFF: enum(u1) { // bit offset: 4 desc: Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
            @"NOT_FULL" = 0, // desc: Rx FIFO not full
            @"FULL" = 1, // desc: Rx FIFO is full
        },
        MST_ACTIVITY: enum(u1) { // bit offset: 5 desc: Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n Reset value: 0x0
            @"IDLE" = 0, // desc: Master is idle
            @"ACTIVE" = 1, // desc: Master not idle
        },
        SLV_ACTIVITY: enum(u1) { // bit offset: 6 desc: Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
            @"IDLE" = 0, // desc: Slave is idle
            @"ACTIVE" = 1, // desc: Slave not idle
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
    });
    // byte offset: 116 I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
    pub const IC_TXFLR = mmio(Address + 0x00000074, 32, packed struct {
        TXFLR: u5, // bit offset: 0 desc: Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 120 I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
    pub const IC_RXFLR = mmio(Address + 0x00000078, 32, packed struct {
        RXFLR: u5, // bit offset: 0 desc: Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 124 I2C SDA Hold Time Length Register\n\n The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n Writes to this register succeed only when IC_ENABLE[0]=0.\n\n The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one cycle in master mode, seven cycles in slave mode for the value to be implemented.\n\n The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
    pub const IC_SDA_HOLD = mmio(Address + 0x0000007c, 32, packed struct {
        IC_SDA_TX_HOLD: u16, // bit offset: 0 desc: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n Reset value: IC_DEFAULT_SDA_HOLD[15:0].
        IC_SDA_RX_HOLD: u8, // bit offset: 16 desc: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n Reset value: IC_DEFAULT_SDA_HOLD[23:16].
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 128 I2C Transmit Abort Source Register\n\n This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
    pub const IC_TX_ABRT_SOURCE = mmio(Address + 0x00000080, 32, packed struct {
        ABRT_7B_ADDR_NOACK: enum(u1) { // bit offset: 0 desc: This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"INACTIVE" = 0, // desc: This abort is not generated
            @"ACTIVE" = 1, // desc: This abort is generated because of NOACK for 7-bit address
        },
        ABRT_10ADDR1_NOACK: enum(u1) { // bit offset: 1 desc: This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"INACTIVE" = 0, // desc: This abort is not generated
            @"ACTIVE" = 1, // desc: Byte 1 of 10Bit Address not ACKed by any slave
        },
        ABRT_10ADDR2_NOACK: enum(u1) { // bit offset: 2 desc: This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"INACTIVE" = 0, // desc: This abort is not generated
            @"ACTIVE" = 1, // desc: Byte 2 of 10Bit Address not ACKed by any slave
        },
        ABRT_TXDATA_NOACK: enum(u1) { // bit offset: 3 desc: This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_TXDATA_NOACK_VOID" = 0, // desc: Transmitted data non-ACKed by addressed slave-scenario not present
            @"ABRT_TXDATA_NOACK_GENERATED" = 1, // desc: Transmitted data not ACKed by addressed slave
        },
        ABRT_GCALL_NOACK: enum(u1) { // bit offset: 4 desc: This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_GCALL_NOACK_VOID" = 0, // desc: GCALL not ACKed by any slave-scenario not present
            @"ABRT_GCALL_NOACK_GENERATED" = 1, // desc: GCALL not ACKed by any slave
        },
        ABRT_GCALL_READ: enum(u1) { // bit offset: 5 desc: This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_GCALL_READ_VOID" = 0, // desc: GCALL is followed by read from bus-scenario not present
            @"ABRT_GCALL_READ_GENERATED" = 1, // desc: GCALL is followed by read from bus
        },
        ABRT_HS_ACKDET: enum(u1) { // bit offset: 6 desc: This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
            @"ABRT_HS_ACK_VOID" = 0, // desc: HS Master code ACKed in HS Mode- scenario not present
            @"ABRT_HS_ACK_GENERATED" = 1, // desc: HS Master code ACKed in HS Mode
        },
        ABRT_SBYTE_ACKDET: enum(u1) { // bit offset: 7 desc: This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
            @"ABRT_SBYTE_ACKDET_VOID" = 0, // desc: ACK detected for START byte- scenario not present
            @"ABRT_SBYTE_ACKDET_GENERATED" = 1, // desc: ACK detected for START byte
        },
        ABRT_HS_NORSTRT: enum(u1) { // bit offset: 8 desc: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"ABRT_HS_NORSTRT_VOID" = 0, // desc: User trying to switch Master to HS mode when RESTART disabled- scenario not present
            @"ABRT_HS_NORSTRT_GENERATED" = 1, // desc: User trying to switch Master to HS mode when RESTART disabled
        },
        ABRT_SBYTE_NORSTRT: enum(u1) { // bit offset: 9 desc: To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
            @"ABRT_SBYTE_NORSTRT_VOID" = 0, // desc: User trying to send START byte when RESTART disabled- scenario not present
            @"ABRT_SBYTE_NORSTRT_GENERATED" = 1, // desc: User trying to send START byte when RESTART disabled
        },
        ABRT_10B_RD_NORSTRT: enum(u1) { // bit offset: 10 desc: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Receiver
            @"ABRT_10B_RD_VOID" = 0, // desc: Master not trying to read in 10Bit addressing mode when RESTART disabled
            @"ABRT_10B_RD_GENERATED" = 1, // desc: Master trying to read in 10Bit addressing mode when RESTART disabled
        },
        ABRT_MASTER_DIS: enum(u1) { // bit offset: 11 desc: This field indicates that the User tries to initiate a Master operation with the Master mode disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"ABRT_MASTER_DIS_VOID" = 0, // desc: User initiating master operation when MASTER disabled- scenario not present
            @"ABRT_MASTER_DIS_GENERATED" = 1, // desc: User initiating master operation when MASTER disabled
        },
        ARB_LOST: enum(u1) { // bit offset: 12 desc: This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
            @"ABRT_LOST_VOID" = 0, // desc: Master or Slave-Transmitter lost arbitration- scenario not present
            @"ABRT_LOST_GENERATED" = 1, // desc: Master or Slave-Transmitter lost arbitration
        },
        ABRT_SLVFLUSH_TXFIFO: enum(u1) { // bit offset: 13 desc: This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
            @"ABRT_SLVFLUSH_TXFIFO_VOID" = 0, // desc: Slave flushes existing data in TX-FIFO upon getting read command- scenario not present
            @"ABRT_SLVFLUSH_TXFIFO_GENERATED" = 1, // desc: Slave flushes existing data in TX-FIFO upon getting read command
        },
        ABRT_SLV_ARBLOST: enum(u1) { // bit offset: 14 desc: This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
            @"ABRT_SLV_ARBLOST_VOID" = 0, // desc: Slave lost arbitration to remote master- scenario not present
            @"ABRT_SLV_ARBLOST_GENERATED" = 1, // desc: Slave lost arbitration to remote master
        },
        ABRT_SLVRD_INTX: enum(u1) { // bit offset: 15 desc: 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
            @"ABRT_SLVRD_INTX_VOID" = 0, // desc: Slave trying to transmit to remote master in read mode- scenario not present
            @"ABRT_SLVRD_INTX_GENERATED" = 1, // desc: Slave trying to transmit to remote master in read mode
        },
        ABRT_USER_ABRT: enum(u1) { // bit offset: 16 desc: This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_USER_ABRT_VOID" = 0, // desc: Transfer abort detected by master- scenario not present
            @"ABRT_USER_ABRT_GENERATED" = 1, // desc: Transfer abort detected by master
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        TX_FLUSH_CNT: u9, // bit offset: 23 desc: This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
    });
    // byte offset: 132 Generate Slave Data NACK Register\n\n The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
    pub const IC_SLV_DATA_NACK_ONLY = mmio(Address + 0x00000084, 32, packed struct {
        NACK: enum(u1) { // bit offset: 0 desc: Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0
            @"DISABLED" = 0, // desc: Slave receiver generates NACK normally
            @"ENABLED" = 1, // desc: Slave receiver generates NACK upon data reception only
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 136 DMA Control Register\n\n The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
    pub const IC_DMA_CR = mmio(Address + 0x00000088, 32, packed struct {
        RDMAE: enum(u1) { // bit offset: 0 desc: Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
            @"DISABLED" = 0, // desc: Receive FIFO DMA channel disabled
            @"ENABLED" = 1, // desc: Receive FIFO DMA channel enabled
        },
        TDMAE: enum(u1) { // bit offset: 1 desc: Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
            @"DISABLED" = 0, // desc: transmit FIFO DMA channel disabled
            @"ENABLED" = 1, // desc: Transmit FIFO DMA channel enabled
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 140 DMA Transmit Data Level Register
    pub const IC_DMA_TDLR = mmio(Address + 0x0000008c, 32, packed struct {
        DMATDL: u4, // bit offset: 0 desc: Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 144 I2C Receive Data Level Register
    pub const IC_DMA_RDLR = mmio(Address + 0x00000090, 32, packed struct {
        DMARDL: u4, // bit offset: 0 desc: Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 148 I2C SDA Setup Register\n\n This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
    pub const IC_SDA_SETUP = mmio(Address + 0x00000094, 32, packed struct {
        SDA_SETUP: u8, // bit offset: 0 desc: SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 152 I2C ACK General Call Register\n\n The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n This register is applicable only when the DW_apb_i2c is in slave mode.
    pub const IC_ACK_GENERAL_CALL = mmio(Address + 0x00000098, 32, packed struct {
        ACK_GEN_CALL: enum(u1) { // bit offset: 0 desc: ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
            @"DISABLED" = 0, // desc: Generate NACK for a General Call
            @"ENABLED" = 1, // desc: Generate ACK for a General Call
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 156 I2C Enable Status Register\n\n The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
    pub const IC_ENABLE_STATUS = mmio(Address + 0x0000009c, 32, packed struct {
        IC_EN: enum(u1) { // bit offset: 0 desc: ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n Reset value: 0x0
            @"DISABLED" = 0, // desc: I2C disabled
            @"ENABLED" = 1, // desc: I2C enabled
        },
        SLV_DISABLED_WHILE_BUSY: enum(u1) { // bit offset: 1 desc: Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:\n\n (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;\n\n OR,\n\n (b) address and data bytes of the Slave-Receiver operation from a remote master.\n\n When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: Slave is disabled when it is idle
            @"ACTIVE" = 1, // desc: Slave is disabled when it is active
        },
        SLV_RX_DATA_LOST: enum(u1) { // bit offset: 2 desc: Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: Slave RX Data is not lost
            @"ACTIVE" = 1, // desc: Slave RX Data is lost
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 160 I2C SS, FS or FM+ spike suppression limit\n\n This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
    pub const IC_FS_SPKLEN = mmio(Address + 0x000000a0, 32, packed struct {
        IC_FS_SPKLEN: u8, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 168 Clear RESTART_DET Interrupt Register
    pub const IC_CLR_RESTART_DET = mmio(Address + 0x000000a8, 32, packed struct {
        CLR_RESTART_DET: u1, // bit offset: 0 desc: Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 244 Component Parameter Register 1\n\n Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
    pub const IC_COMP_PARAM_1 = mmio(Address + 0x000000f4, 32, packed struct {
        APB_DATA_WIDTH: u2, // bit offset: 0 desc: APB data bus width is 32 bits
        MAX_SPEED_MODE: u2, // bit offset: 2 desc: MAX SPEED MODE = FAST MODE
        HC_COUNT_VALUES: u1, // bit offset: 4 desc: Programmable count values for each mode.
        INTR_IO: u1, // bit offset: 5 desc: COMBINED Interrupt outputs
        HAS_DMA: u1, // bit offset: 6 desc: DMA handshaking signals are enabled
        ADD_ENCODED_PARAMS: u1, // bit offset: 7 desc: Encoded parameters not visible
        RX_BUFFER_DEPTH: u8, // bit offset: 8 desc: RX Buffer Depth = 16
        TX_BUFFER_DEPTH: u8, // bit offset: 16 desc: TX Buffer Depth = 16
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 248 I2C Component Version Register
    pub const IC_COMP_VERSION = mmio(Address + 0x000000f8, 32, packed struct {
        IC_COMP_VERSION: u32, // bit offset: 0 desc:
    });
    // byte offset: 252 I2C Component Type Register
    pub const IC_COMP_TYPE = mmio(Address + 0x000000fc, 32, packed struct {
        IC_COMP_TYPE: u32, // bit offset: 0 desc: Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number.
    });
};
pub const I2C1 = extern struct {
    pub const Address: u32 = 0x40048000;
    // byte offset: 0 I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
    pub const IC_CON = mmio(Address + 0x00000000, 32, packed struct {
        MASTER_MODE: enum(u1) { // bit offset: 0 desc: This bit controls whether the DW_apb_i2c master is enabled.\n\n NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.
            @"DISABLED" = 0, // desc: Master mode is disabled
            @"ENABLED" = 1, // desc: Master mode is enabled
        },
        SPEED: enum(u2) { // bit offset: 1 desc: These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n 1: standard mode (100 kbit/s)\n\n 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n 3: high speed mode (3.4 Mbit/s)\n\n Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
            @"STANDARD" = 1, // desc: Standard Speed mode of operation
            @"FAST" = 2, // desc: Fast or Fast Plus mode of operation
            @"HIGH" = 3, // desc: High Speed mode of operation
            _, // non-exhaustive
        },
        IC_10BITADDR_SLAVE: enum(u1) { // bit offset: 3 desc: When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
            @"ADDR_7BITS" = 0, // desc: Slave 7Bit addressing
            @"ADDR_10BITS" = 1, // desc: Slave 10Bit addressing
        },
        IC_10BITADDR_MASTER: enum(u1) { // bit offset: 4 desc: Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
            @"ADDR_7BITS" = 0, // desc: Master 7Bit addressing mode
            @"ADDR_10BITS" = 1, // desc: Master 10Bit addressing mode
        },
        IC_RESTART_EN: enum(u1) { // bit offset: 5 desc: Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n Reset value: ENABLED
            @"DISABLED" = 0, // desc: Master restart disabled
            @"ENABLED" = 1, // desc: Master restart enabled
        },
        IC_SLAVE_DISABLE: enum(u1) { // bit offset: 6 desc: This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.
            @"SLAVE_ENABLED" = 0, // desc: Slave mode is enabled
            @"SLAVE_DISABLED" = 1, // desc: Slave mode is disabled
        },
        STOP_DET_IFADDRESSED: enum(u1) { // bit offset: 7 desc: In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed. - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).
            @"DISABLED" = 0, // desc: slave issues STOP_DET intr always
            @"ENABLED" = 1, // desc: slave issues STOP_DET intr only if addressed
        },
        TX_EMPTY_CTRL: enum(u1) { // bit offset: 8 desc: This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
            @"DISABLED" = 0, // desc: Default behaviour of TX_EMPTY interrupt
            @"ENABLED" = 1, // desc: Controlled generation of TX_EMPTY interrupt
        },
        RX_FIFO_FULL_HLD_CTRL: enum(u1) { // bit offset: 9 desc: This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
            @"DISABLED" = 0, // desc: Overflow when RX_FIFO is full
            @"ENABLED" = 1, // desc: Hold bus when RX_FIFO is full
        },
        STOP_DET_IF_MASTER_ACTIVE: u1, // bit offset: 10 desc: Master issues the STOP_DET interrupt irrespective of whether master is active or not
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 4 I2C Target Address Register\n\n This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
    pub const IC_TAR = mmio(Address + 0x00000004, 32, packed struct {
        IC_TAR: u10, // bit offset: 0 desc: This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.
        GC_OR_START: enum(u1) { // bit offset: 10 desc: If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
            @"GENERAL_CALL" = 0, // desc: GENERAL_CALL byte transmission
            @"START_BYTE" = 1, // desc: START byte transmission
        },
        SPECIAL: enum(u1) { // bit offset: 11 desc: This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
            @"DISABLED" = 0, // desc: Disables programming of GENERAL_CALL or START_BYTE transmission
            @"ENABLED" = 1, // desc: Enables programming of GENERAL_CALL or START_BYTE transmission
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 8 I2C Slave Address Register
    pub const IC_SAR = mmio(Address + 0x00000008, 32, packed struct {
        IC_SAR: u10, // bit offset: 0 desc: The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
    });
    // byte offset: 16 I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n The size of the register changes as follows:\n\n Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
    pub const IC_DATA_CMD = mmio(Address + 0x00000010, 32, packed struct {
        DAT: u8, // bit offset: 0 desc: This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n Reset value: 0x0
        CMD: enum(u1) { // bit offset: 8 desc: This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset value: 0x0
            @"WRITE" = 0, // desc: Master Write Command
            @"READ" = 1, // desc: Master Read Command
        },
        STOP: enum(u1) { // bit offset: 9 desc: This bit controls whether a STOP is issued after the byte is sent or received.\n\n - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0
            @"DISABLE" = 0, // desc: Don't Issue STOP after this command
            @"ENABLE" = 1, // desc: Issue STOP after this command
        },
        RESTART: enum(u1) { // bit offset: 10 desc: This bit controls whether a RESTART is issued before the byte is sent or received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n Reset value: 0x0
            @"DISABLE" = 0, // desc: Don't Issue RESTART before this command
            @"ENABLE" = 1, // desc: Issue RESTART before this command
        },
        FIRST_DATA_BYTE: enum(u1) { // bit offset: 11 desc: Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.\n\n Reset value : 0x0\n\n NOTE: In case of APB_DATA_WIDTH=8,\n\n 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.\n\n 2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).\n\n 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status.
            @"INACTIVE" = 0, // desc: Sequential data byte received
            @"ACTIVE" = 1, // desc: Non sequential data byte received
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 20 Standard Speed I2C Clock SCL High Count Register
    pub const IC_SS_SCL_HCNT = mmio(Address + 0x00000014, 32, packed struct {
        IC_SS_SCL_HCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 24 Standard Speed I2C Clock SCL Low Count Register
    pub const IC_SS_SCL_LCNT = mmio(Address + 0x00000018, 32, packed struct {
        IC_SS_SCL_LCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 28 Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
    pub const IC_FS_SCL_HCNT = mmio(Address + 0x0000001c, 32, packed struct {
        IC_FS_SCL_HCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 32 Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
    pub const IC_FS_SCL_LCNT = mmio(Address + 0x00000020, 32, packed struct {
        IC_FS_SCL_LCNT: u16, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 44 I2C Interrupt Status Register\n\n Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
    pub const IC_INTR_STAT = mmio(Address + 0x0000002c, 32, packed struct {
        R_RX_UNDER: enum(u1) { // bit offset: 0 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_UNDER interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_UNDER interrupt is active
        },
        R_RX_OVER: enum(u1) { // bit offset: 1 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RX_OVER interrupt is active
        },
        R_RX_FULL: enum(u1) { // bit offset: 2 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RX_FULL interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RX_FULL interrupt is active
        },
        R_TX_OVER: enum(u1) { // bit offset: 3 desc: See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_TX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: R_TX_OVER interrupt is active
        },
        R_TX_EMPTY: enum(u1) { // bit offset: 4 desc: See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_TX_EMPTY interrupt is inactive
            @"ACTIVE" = 1, // desc: R_TX_EMPTY interrupt is active
        },
        R_RD_REQ: enum(u1) { // bit offset: 5 desc: See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RD_REQ interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RD_REQ interrupt is active
        },
        R_TX_ABRT: enum(u1) { // bit offset: 6 desc: See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_TX_ABRT interrupt is inactive
            @"ACTIVE" = 1, // desc: R_TX_ABRT interrupt is active
        },
        R_RX_DONE: enum(u1) { // bit offset: 7 desc: See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RX_DONE interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RX_DONE interrupt is active
        },
        R_ACTIVITY: enum(u1) { // bit offset: 8 desc: See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_ACTIVITY interrupt is inactive
            @"ACTIVE" = 1, // desc: R_ACTIVITY interrupt is active
        },
        R_STOP_DET: enum(u1) { // bit offset: 9 desc: See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_STOP_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: R_STOP_DET interrupt is active
        },
        R_START_DET: enum(u1) { // bit offset: 10 desc: See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_START_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: R_START_DET interrupt is active
        },
        R_GEN_CALL: enum(u1) { // bit offset: 11 desc: See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_GEN_CALL interrupt is inactive
            @"ACTIVE" = 1, // desc: R_GEN_CALL interrupt is active
        },
        R_RESTART_DET: enum(u1) { // bit offset: 12 desc: See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_RESTART_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: R_RESTART_DET interrupt is active
        },
        R_MASTER_ON_HOLD: enum(u1) { // bit offset: 13 desc: See IC_RAW_INTR_STAT for a detailed description of R_MASTER_ON_HOLD bit.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: R_MASTER_ON_HOLD interrupt is inactive
            @"ACTIVE" = 1, // desc: R_MASTER_ON_HOLD interrupt is active
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
    });
    // byte offset: 48 I2C Interrupt Mask Register.\n\n These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
    pub const IC_INTR_MASK = mmio(Address + 0x00000030, 32, packed struct {
        M_RX_UNDER: enum(u1) { // bit offset: 0 desc: This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_UNDER interrupt is masked
            @"DISABLED" = 1, // desc: RX_UNDER interrupt is unmasked
        },
        M_RX_OVER: enum(u1) { // bit offset: 1 desc: This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_OVER interrupt is masked
            @"DISABLED" = 1, // desc: RX_OVER interrupt is unmasked
        },
        M_RX_FULL: enum(u1) { // bit offset: 2 desc: This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_FULL interrupt is masked
            @"DISABLED" = 1, // desc: RX_FULL interrupt is unmasked
        },
        M_TX_OVER: enum(u1) { // bit offset: 3 desc: This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: TX_OVER interrupt is masked
            @"DISABLED" = 1, // desc: TX_OVER interrupt is unmasked
        },
        M_TX_EMPTY: enum(u1) { // bit offset: 4 desc: This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: TX_EMPTY interrupt is masked
            @"DISABLED" = 1, // desc: TX_EMPTY interrupt is unmasked
        },
        M_RD_REQ: enum(u1) { // bit offset: 5 desc: This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RD_REQ interrupt is masked
            @"DISABLED" = 1, // desc: RD_REQ interrupt is unmasked
        },
        M_TX_ABRT: enum(u1) { // bit offset: 6 desc: This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: TX_ABORT interrupt is masked
            @"DISABLED" = 1, // desc: TX_ABORT interrupt is unmasked
        },
        M_RX_DONE: enum(u1) { // bit offset: 7 desc: This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: RX_DONE interrupt is masked
            @"DISABLED" = 1, // desc: RX_DONE interrupt is unmasked
        },
        M_ACTIVITY: enum(u1) { // bit offset: 8 desc: This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: ACTIVITY interrupt is masked
            @"DISABLED" = 1, // desc: ACTIVITY interrupt is unmasked
        },
        M_STOP_DET: enum(u1) { // bit offset: 9 desc: This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: STOP_DET interrupt is masked
            @"DISABLED" = 1, // desc: STOP_DET interrupt is unmasked
        },
        M_START_DET: enum(u1) { // bit offset: 10 desc: This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: START_DET interrupt is masked
            @"DISABLED" = 1, // desc: START_DET interrupt is unmasked
        },
        M_GEN_CALL: enum(u1) { // bit offset: 11 desc: This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n Reset value: 0x1
            @"ENABLED" = 0, // desc: GEN_CALL interrupt is masked
            @"DISABLED" = 1, // desc: GEN_CALL interrupt is unmasked
        },
        M_RESTART_DET: enum(u1) { // bit offset: 12 desc: This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: RESTART_DET interrupt is masked
            @"DISABLED" = 1, // desc: RESTART_DET interrupt is unmasked
        },
        M_MASTER_ON_HOLD_READ_ONLY: enum(u1) { // bit offset: 13 desc: This M_MASTER_ON_HOLD_read_only bit masks the R_MASTER_ON_HOLD interrupt in IC_INTR_STAT register.\n\n Reset value: 0x0
            @"ENABLED" = 0, // desc: MASTER_ON_HOLD interrupt is masked
            @"DISABLED" = 1, // desc: MASTER_ON_HOLD interrupt is unmasked
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
    });
    // byte offset: 52 I2C Raw Interrupt Status Register\n\n Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
    pub const IC_RAW_INTR_STAT = mmio(Address + 0x00000034, 32, packed struct {
        RX_UNDER: enum(u1) { // bit offset: 0 desc: Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_UNDER interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_UNDER interrupt is active
        },
        RX_OVER: enum(u1) { // bit offset: 1 desc: Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_OVER interrupt is active
        },
        RX_FULL: enum(u1) { // bit offset: 2 desc: Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_FULL interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_FULL interrupt is active
        },
        TX_OVER: enum(u1) { // bit offset: 3 desc: Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: TX_OVER interrupt is inactive
            @"ACTIVE" = 1, // desc: TX_OVER interrupt is active
        },
        TX_EMPTY: enum(u1) { // bit offset: 4 desc: The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.\n\n Reset value: 0x0.
            @"INACTIVE" = 0, // desc: TX_EMPTY interrupt is inactive
            @"ACTIVE" = 1, // desc: TX_EMPTY interrupt is active
        },
        RD_REQ: enum(u1) { // bit offset: 5 desc: This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RD_REQ interrupt is inactive
            @"ACTIVE" = 1, // desc: RD_REQ interrupt is active
        },
        TX_ABRT: enum(u1) { // bit offset: 6 desc: This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.\n\n Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: TX_ABRT interrupt is inactive
            @"ACTIVE" = 1, // desc: TX_ABRT interrupt is active
        },
        RX_DONE: enum(u1) { // bit offset: 7 desc: When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RX_DONE interrupt is inactive
            @"ACTIVE" = 1, // desc: RX_DONE interrupt is active
        },
        ACTIVITY: enum(u1) { // bit offset: 8 desc: This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RAW_INTR_ACTIVITY interrupt is inactive
            @"ACTIVE" = 1, // desc: RAW_INTR_ACTIVITY interrupt is active
        },
        STOP_DET: enum(u1) { // bit offset: 9 desc: Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1 (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0
            @"INACTIVE" = 0, // desc: STOP_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: STOP_DET interrupt is active
        },
        START_DET: enum(u1) { // bit offset: 10 desc: Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: START_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: START_DET interrupt is active
        },
        GEN_CALL: enum(u1) { // bit offset: 11 desc: Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: GEN_CALL interrupt is inactive
            @"ACTIVE" = 1, // desc: GEN_CALL interrupt is active
        },
        RESTART_DET: enum(u1) { // bit offset: 12 desc: Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: RESTART_DET interrupt is inactive
            @"ACTIVE" = 1, // desc: RESTART_DET interrupt is active
        },
        MASTER_ON_HOLD: enum(u1) { // bit offset: 13 desc: Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: MASTER_ON_HOLD interrupt is inactive
            @"ACTIVE" = 1, // desc: MASTER_ON_HOLD interrupt is active
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
    });
    // byte offset: 56 I2C Receive FIFO Threshold Register
    pub const IC_RX_TL = mmio(Address + 0x00000038, 32, packed struct {
        RX_TL: u8, // bit offset: 0 desc: Receive FIFO Threshold Level.\n\n Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 60 I2C Transmit FIFO Threshold Register
    pub const IC_TX_TL = mmio(Address + 0x0000003c, 32, packed struct {
        TX_TL: u8, // bit offset: 0 desc: Transmit FIFO Threshold Level.\n\n Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 64 Clear Combined and Individual Interrupt Register
    pub const IC_CLR_INTR = mmio(Address + 0x00000040, 32, packed struct {
        CLR_INTR: u1, // bit offset: 0 desc: Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 68 Clear RX_UNDER Interrupt Register
    pub const IC_CLR_RX_UNDER = mmio(Address + 0x00000044, 32, packed struct {
        CLR_RX_UNDER: u1, // bit offset: 0 desc: Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 72 Clear RX_OVER Interrupt Register
    pub const IC_CLR_RX_OVER = mmio(Address + 0x00000048, 32, packed struct {
        CLR_RX_OVER: u1, // bit offset: 0 desc: Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 76 Clear TX_OVER Interrupt Register
    pub const IC_CLR_TX_OVER = mmio(Address + 0x0000004c, 32, packed struct {
        CLR_TX_OVER: u1, // bit offset: 0 desc: Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 80 Clear RD_REQ Interrupt Register
    pub const IC_CLR_RD_REQ = mmio(Address + 0x00000050, 32, packed struct {
        CLR_RD_REQ: u1, // bit offset: 0 desc: Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 84 Clear TX_ABRT Interrupt Register
    pub const IC_CLR_TX_ABRT = mmio(Address + 0x00000054, 32, packed struct {
        CLR_TX_ABRT: u1, // bit offset: 0 desc: Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 88 Clear RX_DONE Interrupt Register
    pub const IC_CLR_RX_DONE = mmio(Address + 0x00000058, 32, packed struct {
        CLR_RX_DONE: u1, // bit offset: 0 desc: Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 92 Clear ACTIVITY Interrupt Register
    pub const IC_CLR_ACTIVITY = mmio(Address + 0x0000005c, 32, packed struct {
        CLR_ACTIVITY: u1, // bit offset: 0 desc: Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 96 Clear STOP_DET Interrupt Register
    pub const IC_CLR_STOP_DET = mmio(Address + 0x00000060, 32, packed struct {
        CLR_STOP_DET: u1, // bit offset: 0 desc: Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 100 Clear START_DET Interrupt Register
    pub const IC_CLR_START_DET = mmio(Address + 0x00000064, 32, packed struct {
        CLR_START_DET: u1, // bit offset: 0 desc: Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 104 Clear GEN_CALL Interrupt Register
    pub const IC_CLR_GEN_CALL = mmio(Address + 0x00000068, 32, packed struct {
        CLR_GEN_CALL: u1, // bit offset: 0 desc: Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 108 I2C Enable Register
    pub const IC_ENABLE = mmio(Address + 0x0000006c, 32, packed struct {
        ENABLE: enum(u1) { // bit offset: 0 desc: Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
            @"DISABLED" = 0, // desc: I2C is disabled
            @"ENABLED" = 1, // desc: I2C is enabled
        },
        ABORT: enum(u1) { // bit offset: 1 desc: When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n Reset value: 0x0
            @"DISABLE" = 0, // desc: ABORT operation not in progress
            @"ENABLED" = 1, // desc: ABORT operation in progress
        },
        TX_CMD_BLOCK: enum(u1) { // bit offset: 2 desc: In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
            @"NOT_BLOCKED" = 0, // desc: Tx Command execution not blocked
            @"BLOCKED" = 1, // desc: Tx Command execution blocked
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 112 I2C Status Register\n\n This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
    pub const IC_STATUS = mmio(Address + 0x00000070, 32, packed struct {
        ACTIVITY: enum(u1) { // bit offset: 0 desc: I2C Activity Status. Reset value: 0x0
            @"INACTIVE" = 0, // desc: I2C is idle
            @"ACTIVE" = 1, // desc: I2C is active
        },
        TFNF: enum(u1) { // bit offset: 1 desc: Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
            @"FULL" = 0, // desc: Tx FIFO is full
            @"NOT_FULL" = 1, // desc: Tx FIFO not full
        },
        TFE: enum(u1) { // bit offset: 2 desc: Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
            @"NON_EMPTY" = 0, // desc: Tx FIFO not empty
            @"EMPTY" = 1, // desc: Tx FIFO is empty
        },
        RFNE: enum(u1) { // bit offset: 3 desc: Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
            @"EMPTY" = 0, // desc: Rx FIFO is empty
            @"NOT_EMPTY" = 1, // desc: Rx FIFO not empty
        },
        RFF: enum(u1) { // bit offset: 4 desc: Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
            @"NOT_FULL" = 0, // desc: Rx FIFO not full
            @"FULL" = 1, // desc: Rx FIFO is full
        },
        MST_ACTIVITY: enum(u1) { // bit offset: 5 desc: Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n Reset value: 0x0
            @"IDLE" = 0, // desc: Master is idle
            @"ACTIVE" = 1, // desc: Master not idle
        },
        SLV_ACTIVITY: enum(u1) { // bit offset: 6 desc: Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
            @"IDLE" = 0, // desc: Slave is idle
            @"ACTIVE" = 1, // desc: Slave not idle
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
    });
    // byte offset: 116 I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
    pub const IC_TXFLR = mmio(Address + 0x00000074, 32, packed struct {
        TXFLR: u5, // bit offset: 0 desc: Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 120 I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
    pub const IC_RXFLR = mmio(Address + 0x00000078, 32, packed struct {
        RXFLR: u5, // bit offset: 0 desc: Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 124 I2C SDA Hold Time Length Register\n\n The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n Writes to this register succeed only when IC_ENABLE[0]=0.\n\n The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one cycle in master mode, seven cycles in slave mode for the value to be implemented.\n\n The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
    pub const IC_SDA_HOLD = mmio(Address + 0x0000007c, 32, packed struct {
        IC_SDA_TX_HOLD: u16, // bit offset: 0 desc: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n Reset value: IC_DEFAULT_SDA_HOLD[15:0].
        IC_SDA_RX_HOLD: u8, // bit offset: 16 desc: Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n Reset value: IC_DEFAULT_SDA_HOLD[23:16].
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 128 I2C Transmit Abort Source Register\n\n This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
    pub const IC_TX_ABRT_SOURCE = mmio(Address + 0x00000080, 32, packed struct {
        ABRT_7B_ADDR_NOACK: enum(u1) { // bit offset: 0 desc: This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"INACTIVE" = 0, // desc: This abort is not generated
            @"ACTIVE" = 1, // desc: This abort is generated because of NOACK for 7-bit address
        },
        ABRT_10ADDR1_NOACK: enum(u1) { // bit offset: 1 desc: This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"INACTIVE" = 0, // desc: This abort is not generated
            @"ACTIVE" = 1, // desc: Byte 1 of 10Bit Address not ACKed by any slave
        },
        ABRT_10ADDR2_NOACK: enum(u1) { // bit offset: 2 desc: This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"INACTIVE" = 0, // desc: This abort is not generated
            @"ACTIVE" = 1, // desc: Byte 2 of 10Bit Address not ACKed by any slave
        },
        ABRT_TXDATA_NOACK: enum(u1) { // bit offset: 3 desc: This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_TXDATA_NOACK_VOID" = 0, // desc: Transmitted data non-ACKed by addressed slave-scenario not present
            @"ABRT_TXDATA_NOACK_GENERATED" = 1, // desc: Transmitted data not ACKed by addressed slave
        },
        ABRT_GCALL_NOACK: enum(u1) { // bit offset: 4 desc: This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_GCALL_NOACK_VOID" = 0, // desc: GCALL not ACKed by any slave-scenario not present
            @"ABRT_GCALL_NOACK_GENERATED" = 1, // desc: GCALL not ACKed by any slave
        },
        ABRT_GCALL_READ: enum(u1) { // bit offset: 5 desc: This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_GCALL_READ_VOID" = 0, // desc: GCALL is followed by read from bus-scenario not present
            @"ABRT_GCALL_READ_GENERATED" = 1, // desc: GCALL is followed by read from bus
        },
        ABRT_HS_ACKDET: enum(u1) { // bit offset: 6 desc: This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
            @"ABRT_HS_ACK_VOID" = 0, // desc: HS Master code ACKed in HS Mode- scenario not present
            @"ABRT_HS_ACK_GENERATED" = 1, // desc: HS Master code ACKed in HS Mode
        },
        ABRT_SBYTE_ACKDET: enum(u1) { // bit offset: 7 desc: This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
            @"ABRT_SBYTE_ACKDET_VOID" = 0, // desc: ACK detected for START byte- scenario not present
            @"ABRT_SBYTE_ACKDET_GENERATED" = 1, // desc: ACK detected for START byte
        },
        ABRT_HS_NORSTRT: enum(u1) { // bit offset: 8 desc: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"ABRT_HS_NORSTRT_VOID" = 0, // desc: User trying to switch Master to HS mode when RESTART disabled- scenario not present
            @"ABRT_HS_NORSTRT_GENERATED" = 1, // desc: User trying to switch Master to HS mode when RESTART disabled
        },
        ABRT_SBYTE_NORSTRT: enum(u1) { // bit offset: 9 desc: To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master
            @"ABRT_SBYTE_NORSTRT_VOID" = 0, // desc: User trying to send START byte when RESTART disabled- scenario not present
            @"ABRT_SBYTE_NORSTRT_GENERATED" = 1, // desc: User trying to send START byte when RESTART disabled
        },
        ABRT_10B_RD_NORSTRT: enum(u1) { // bit offset: 10 desc: This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Receiver
            @"ABRT_10B_RD_VOID" = 0, // desc: Master not trying to read in 10Bit addressing mode when RESTART disabled
            @"ABRT_10B_RD_GENERATED" = 1, // desc: Master trying to read in 10Bit addressing mode when RESTART disabled
        },
        ABRT_MASTER_DIS: enum(u1) { // bit offset: 11 desc: This field indicates that the User tries to initiate a Master operation with the Master mode disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            @"ABRT_MASTER_DIS_VOID" = 0, // desc: User initiating master operation when MASTER disabled- scenario not present
            @"ABRT_MASTER_DIS_GENERATED" = 1, // desc: User initiating master operation when MASTER disabled
        },
        ARB_LOST: enum(u1) { // bit offset: 12 desc: This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
            @"ABRT_LOST_VOID" = 0, // desc: Master or Slave-Transmitter lost arbitration- scenario not present
            @"ABRT_LOST_GENERATED" = 1, // desc: Master or Slave-Transmitter lost arbitration
        },
        ABRT_SLVFLUSH_TXFIFO: enum(u1) { // bit offset: 13 desc: This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
            @"ABRT_SLVFLUSH_TXFIFO_VOID" = 0, // desc: Slave flushes existing data in TX-FIFO upon getting read command- scenario not present
            @"ABRT_SLVFLUSH_TXFIFO_GENERATED" = 1, // desc: Slave flushes existing data in TX-FIFO upon getting read command
        },
        ABRT_SLV_ARBLOST: enum(u1) { // bit offset: 14 desc: This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
            @"ABRT_SLV_ARBLOST_VOID" = 0, // desc: Slave lost arbitration to remote master- scenario not present
            @"ABRT_SLV_ARBLOST_GENERATED" = 1, // desc: Slave lost arbitration to remote master
        },
        ABRT_SLVRD_INTX: enum(u1) { // bit offset: 15 desc: 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Slave-Transmitter
            @"ABRT_SLVRD_INTX_VOID" = 0, // desc: Slave trying to transmit to remote master in read mode- scenario not present
            @"ABRT_SLVRD_INTX_GENERATED" = 1, // desc: Slave trying to transmit to remote master in read mode
        },
        ABRT_USER_ABRT: enum(u1) { // bit offset: 16 desc: This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter
            @"ABRT_USER_ABRT_VOID" = 0, // desc: Transfer abort detected by master- scenario not present
            @"ABRT_USER_ABRT_GENERATED" = 1, // desc: Transfer abort detected by master
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        TX_FLUSH_CNT: u9, // bit offset: 23 desc: This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
    });
    // byte offset: 132 Generate Slave Data NACK Register\n\n The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
    pub const IC_SLV_DATA_NACK_ONLY = mmio(Address + 0x00000084, 32, packed struct {
        NACK: enum(u1) { // bit offset: 0 desc: Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0
            @"DISABLED" = 0, // desc: Slave receiver generates NACK normally
            @"ENABLED" = 1, // desc: Slave receiver generates NACK upon data reception only
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 136 DMA Control Register\n\n The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
    pub const IC_DMA_CR = mmio(Address + 0x00000088, 32, packed struct {
        RDMAE: enum(u1) { // bit offset: 0 desc: Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
            @"DISABLED" = 0, // desc: Receive FIFO DMA channel disabled
            @"ENABLED" = 1, // desc: Receive FIFO DMA channel enabled
        },
        TDMAE: enum(u1) { // bit offset: 1 desc: Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
            @"DISABLED" = 0, // desc: transmit FIFO DMA channel disabled
            @"ENABLED" = 1, // desc: Transmit FIFO DMA channel enabled
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 140 DMA Transmit Data Level Register
    pub const IC_DMA_TDLR = mmio(Address + 0x0000008c, 32, packed struct {
        DMATDL: u4, // bit offset: 0 desc: Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 144 I2C Receive Data Level Register
    pub const IC_DMA_RDLR = mmio(Address + 0x00000090, 32, packed struct {
        DMARDL: u4, // bit offset: 0 desc: Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 148 I2C SDA Setup Register\n\n This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
    pub const IC_SDA_SETUP = mmio(Address + 0x00000094, 32, packed struct {
        SDA_SETUP: u8, // bit offset: 0 desc: SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 152 I2C ACK General Call Register\n\n The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n This register is applicable only when the DW_apb_i2c is in slave mode.
    pub const IC_ACK_GENERAL_CALL = mmio(Address + 0x00000098, 32, packed struct {
        ACK_GEN_CALL: enum(u1) { // bit offset: 0 desc: ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
            @"DISABLED" = 0, // desc: Generate NACK for a General Call
            @"ENABLED" = 1, // desc: Generate ACK for a General Call
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 156 I2C Enable Status Register\n\n The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
    pub const IC_ENABLE_STATUS = mmio(Address + 0x0000009c, 32, packed struct {
        IC_EN: enum(u1) { // bit offset: 0 desc: ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n Reset value: 0x0
            @"DISABLED" = 0, // desc: I2C disabled
            @"ENABLED" = 1, // desc: I2C enabled
        },
        SLV_DISABLED_WHILE_BUSY: enum(u1) { // bit offset: 1 desc: Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:\n\n (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;\n\n OR,\n\n (b) address and data bytes of the Slave-Receiver operation from a remote master.\n\n When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: Slave is disabled when it is idle
            @"ACTIVE" = 1, // desc: Slave is disabled when it is active
        },
        SLV_RX_DATA_LOST: enum(u1) { // bit offset: 2 desc: Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.\n\n Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.\n\n Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
            @"INACTIVE" = 0, // desc: Slave RX Data is not lost
            @"ACTIVE" = 1, // desc: Slave RX Data is lost
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 160 I2C SS, FS or FM+ spike suppression limit\n\n This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
    pub const IC_FS_SPKLEN = mmio(Address + 0x000000a0, 32, packed struct {
        IC_FS_SPKLEN: u8, // bit offset: 0 desc: This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 168 Clear RESTART_DET Interrupt Register
    pub const IC_CLR_RESTART_DET = mmio(Address + 0x000000a8, 32, packed struct {
        CLR_RESTART_DET: u1, // bit offset: 0 desc: Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 244 Component Parameter Register 1\n\n Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
    pub const IC_COMP_PARAM_1 = mmio(Address + 0x000000f4, 32, packed struct {
        APB_DATA_WIDTH: u2, // bit offset: 0 desc: APB data bus width is 32 bits
        MAX_SPEED_MODE: u2, // bit offset: 2 desc: MAX SPEED MODE = FAST MODE
        HC_COUNT_VALUES: u1, // bit offset: 4 desc: Programmable count values for each mode.
        INTR_IO: u1, // bit offset: 5 desc: COMBINED Interrupt outputs
        HAS_DMA: u1, // bit offset: 6 desc: DMA handshaking signals are enabled
        ADD_ENCODED_PARAMS: u1, // bit offset: 7 desc: Encoded parameters not visible
        RX_BUFFER_DEPTH: u8, // bit offset: 8 desc: RX Buffer Depth = 16
        TX_BUFFER_DEPTH: u8, // bit offset: 16 desc: TX Buffer Depth = 16
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 248 I2C Component Version Register
    pub const IC_COMP_VERSION = mmio(Address + 0x000000f8, 32, packed struct {
        IC_COMP_VERSION: u32, // bit offset: 0 desc:
    });
    // byte offset: 252 I2C Component Type Register
    pub const IC_COMP_TYPE = mmio(Address + 0x000000fc, 32, packed struct {
        IC_COMP_TYPE: u32, // bit offset: 0 desc: Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number.
    });
};
pub const ADC = extern struct {
    pub const Address: u32 = 0x4004c000;
    // byte offset: 0 ADC Control and Status
    pub const CS = mmio(Address + 0x00000000, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Power on ADC and enable its clock.\n 1 - enabled. 0 - disabled.
        TS_EN: u1, // bit offset: 1 desc: Power on temperature sensor. 1 - enabled. 0 - disabled.
        START_ONCE: u1, // bit offset: 2 desc: Start a single conversion. Self-clearing. Ignored if start_many is asserted.
        START_MANY: u1, // bit offset: 3 desc: Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        READY: u1, // bit offset: 8 desc: 1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed.\n 0 whilst conversion in progress.
        ERR: u1, // bit offset: 9 desc: The most recent ADC conversion encountered an error; result is undefined or noisy.
        ERR_STICKY: u1, // bit offset: 10 desc: Some past ADC conversion encountered an error. Write 1 to clear.
        reserved4: u1 = 0,
        AINSEL: u3, // bit offset: 12 desc: Select analog mux input. Updated automatically in round-robin mode.
        reserved5: u1 = 0,
        RROBIN: u5, // bit offset: 16 desc: Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable.\n Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion.\n The first channel to be sampled will be the one currently indicated by AINSEL.\n AINSEL will be updated after each conversion with the newly-selected channel.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 4 Result of most recent ADC conversion
    pub const RESULT = mmio(Address + 0x00000004, 32, packed struct {
        RESULT: u12, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 8 FIFO control and status
    pub const FCS = mmio(Address + 0x00000008, 32, packed struct {
        EN: u1, // bit offset: 0 desc: If 1: write result to the FIFO after each conversion.
        SHIFT: u1, // bit offset: 1 desc: If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers.
        ERR: u1, // bit offset: 2 desc: If 1: conversion error bit appears in the FIFO alongside the result
        DREQ_EN: u1, // bit offset: 3 desc: If 1: assert DMA requests when FIFO contains data
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        EMPTY: u1, // bit offset: 8 desc:
        FULL: u1, // bit offset: 9 desc:
        UNDER: u1, // bit offset: 10 desc: 1 if the FIFO has been underflowed. Write 1 to clear.
        OVER: u1, // bit offset: 11 desc: 1 if the FIFO has been overflowed. Write 1 to clear.
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        LEVEL: u4, // bit offset: 16 desc: The number of conversion results currently waiting in the FIFO
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        THRESH: u4, // bit offset: 24 desc: DREQ/IRQ asserted when level >= threshold
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
    });
    // byte offset: 12 Conversion result FIFO
    pub const FIFO = mmio(Address + 0x0000000c, 32, packed struct {
        VAL: u12, // bit offset: 0 desc:
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        ERR: u1, // bit offset: 15 desc: 1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 16 Clock divider. If non-zero, CS_START_MANY will start conversions\n at regular intervals rather than back-to-back.\n The divider is reset when either of these fields are written.\n Total period is 1 + INT + FRAC / 256
    pub const DIV = mmio(Address + 0x00000010, 32, packed struct {
        FRAC: u8, // bit offset: 0 desc: Fractional part of clock divisor. First-order delta-sigma.
        INT: u16, // bit offset: 8 desc: Integer part of clock divisor.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 20 Raw Interrupts
    pub const INTR = mmio(Address + 0x00000014, 32, packed struct {
        FIFO: u1, // bit offset: 0 desc: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 24 Interrupt Enable
    pub const INTE = mmio(Address + 0x00000018, 32, packed struct {
        FIFO: u1, // bit offset: 0 desc: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 28 Interrupt Force
    pub const INTF = mmio(Address + 0x0000001c, 32, packed struct {
        FIFO: u1, // bit offset: 0 desc: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 32 Interrupt status after masking & forcing
    pub const INTS = mmio(Address + 0x00000020, 32, packed struct {
        FIFO: u1, // bit offset: 0 desc: Triggered when the sample FIFO reaches a certain level.\n This level can be programmed via the FCS_THRESH field.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
};
pub const PWM = extern struct {
    pub const Address: u32 = 0x40050000;
    // byte offset: 0 Control and status register
    pub const CH0_CSR = mmio(Address + 0x00000000, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 4 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH0_DIV = mmio(Address + 0x00000004, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 8 Direct access to the PWM counter
    pub const CH0_CTR = mmio(Address + 0x00000008, 32, packed struct {
        CH0_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 12 Counter compare values
    pub const CH0_CC = mmio(Address + 0x0000000c, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 16 Counter wrap value
    pub const CH0_TOP = mmio(Address + 0x00000010, 32, packed struct {
        CH0_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 20 Control and status register
    pub const CH1_CSR = mmio(Address + 0x00000014, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 24 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH1_DIV = mmio(Address + 0x00000018, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 28 Direct access to the PWM counter
    pub const CH1_CTR = mmio(Address + 0x0000001c, 32, packed struct {
        CH1_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 32 Counter compare values
    pub const CH1_CC = mmio(Address + 0x00000020, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 36 Counter wrap value
    pub const CH1_TOP = mmio(Address + 0x00000024, 32, packed struct {
        CH1_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 40 Control and status register
    pub const CH2_CSR = mmio(Address + 0x00000028, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 44 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH2_DIV = mmio(Address + 0x0000002c, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 48 Direct access to the PWM counter
    pub const CH2_CTR = mmio(Address + 0x00000030, 32, packed struct {
        CH2_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 52 Counter compare values
    pub const CH2_CC = mmio(Address + 0x00000034, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 56 Counter wrap value
    pub const CH2_TOP = mmio(Address + 0x00000038, 32, packed struct {
        CH2_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 60 Control and status register
    pub const CH3_CSR = mmio(Address + 0x0000003c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 64 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH3_DIV = mmio(Address + 0x00000040, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 68 Direct access to the PWM counter
    pub const CH3_CTR = mmio(Address + 0x00000044, 32, packed struct {
        CH3_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 72 Counter compare values
    pub const CH3_CC = mmio(Address + 0x00000048, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 76 Counter wrap value
    pub const CH3_TOP = mmio(Address + 0x0000004c, 32, packed struct {
        CH3_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 80 Control and status register
    pub const CH4_CSR = mmio(Address + 0x00000050, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 84 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH4_DIV = mmio(Address + 0x00000054, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 88 Direct access to the PWM counter
    pub const CH4_CTR = mmio(Address + 0x00000058, 32, packed struct {
        CH4_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 92 Counter compare values
    pub const CH4_CC = mmio(Address + 0x0000005c, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 96 Counter wrap value
    pub const CH4_TOP = mmio(Address + 0x00000060, 32, packed struct {
        CH4_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 100 Control and status register
    pub const CH5_CSR = mmio(Address + 0x00000064, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 104 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH5_DIV = mmio(Address + 0x00000068, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 108 Direct access to the PWM counter
    pub const CH5_CTR = mmio(Address + 0x0000006c, 32, packed struct {
        CH5_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 112 Counter compare values
    pub const CH5_CC = mmio(Address + 0x00000070, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 116 Counter wrap value
    pub const CH5_TOP = mmio(Address + 0x00000074, 32, packed struct {
        CH5_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 120 Control and status register
    pub const CH6_CSR = mmio(Address + 0x00000078, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 124 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH6_DIV = mmio(Address + 0x0000007c, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 128 Direct access to the PWM counter
    pub const CH6_CTR = mmio(Address + 0x00000080, 32, packed struct {
        CH6_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 132 Counter compare values
    pub const CH6_CC = mmio(Address + 0x00000084, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 136 Counter wrap value
    pub const CH6_TOP = mmio(Address + 0x00000088, 32, packed struct {
        CH6_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 140 Control and status register
    pub const CH7_CSR = mmio(Address + 0x0000008c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable the PWM channel.
        PH_CORRECT: u1, // bit offset: 1 desc: 1: Enable phase-correct modulation. 0: Trailing-edge
        A_INV: u1, // bit offset: 2 desc: Invert output A
        B_INV: u1, // bit offset: 3 desc: Invert output B
        DIVMODE: enum(u2) { // bit offset: 4 desc:
            @"div" = 0, // desc: Free-running counting at rate dictated by fractional divider
            @"level" = 1, // desc: Fractional divider operation is gated by the PWM B pin.
            @"rise" = 2, // desc: Counter advances with each rising edge of the PWM B pin.
            @"fall" = 3, // desc: Counter advances with each falling edge of the PWM B pin.
        },
        PH_RET: u1, // bit offset: 6 desc: Retard the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running.
        PH_ADV: u1, // bit offset: 7 desc: Advance the phase of the counter by 1 count, while it is running.\n Self-clearing. Write a 1, and poll until low. Counter must be running\n at less than full speed (div_int + div_frac / 16 > 1)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 144 INT and FRAC form a fixed-point fractional number.\n Counting rate is system clock frequency divided by this number.\n Fractional division uses simple 1st-order sigma-delta.
    pub const CH7_DIV = mmio(Address + 0x00000090, 32, packed struct {
        FRAC: u4, // bit offset: 0 desc:
        INT: u8, // bit offset: 4 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 148 Direct access to the PWM counter
    pub const CH7_CTR = mmio(Address + 0x00000094, 32, packed struct {
        CH7_CTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 152 Counter compare values
    pub const CH7_CC = mmio(Address + 0x00000098, 32, packed struct {
        A: u16, // bit offset: 0 desc:
        B: u16, // bit offset: 16 desc:
    });
    // byte offset: 156 Counter wrap value
    pub const CH7_TOP = mmio(Address + 0x0000009c, 32, packed struct {
        CH7_TOP: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 160 This register aliases the CSR_EN bits for all channels.\n Writing to this register allows multiple channels to be enabled\n or disabled simultaneously, so they can run in perfect sync.\n For each channel, there is only one physical EN register bit,\n which can be accessed through here or CHx_CSR.
    pub const EN = mmio(Address + 0x000000a0, 32, packed struct {
        CH0: u1, // bit offset: 0 desc:
        CH1: u1, // bit offset: 1 desc:
        CH2: u1, // bit offset: 2 desc:
        CH3: u1, // bit offset: 3 desc:
        CH4: u1, // bit offset: 4 desc:
        CH5: u1, // bit offset: 5 desc:
        CH6: u1, // bit offset: 6 desc:
        CH7: u1, // bit offset: 7 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 164 Raw Interrupts
    pub const INTR = mmio(Address + 0x000000a4, 32, packed struct {
        CH0: u1, // bit offset: 0 desc:
        CH1: u1, // bit offset: 1 desc:
        CH2: u1, // bit offset: 2 desc:
        CH3: u1, // bit offset: 3 desc:
        CH4: u1, // bit offset: 4 desc:
        CH5: u1, // bit offset: 5 desc:
        CH6: u1, // bit offset: 6 desc:
        CH7: u1, // bit offset: 7 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 168 Interrupt Enable
    pub const INTE = mmio(Address + 0x000000a8, 32, packed struct {
        CH0: u1, // bit offset: 0 desc:
        CH1: u1, // bit offset: 1 desc:
        CH2: u1, // bit offset: 2 desc:
        CH3: u1, // bit offset: 3 desc:
        CH4: u1, // bit offset: 4 desc:
        CH5: u1, // bit offset: 5 desc:
        CH6: u1, // bit offset: 6 desc:
        CH7: u1, // bit offset: 7 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 172 Interrupt Force
    pub const INTF = mmio(Address + 0x000000ac, 32, packed struct {
        CH0: u1, // bit offset: 0 desc:
        CH1: u1, // bit offset: 1 desc:
        CH2: u1, // bit offset: 2 desc:
        CH3: u1, // bit offset: 3 desc:
        CH4: u1, // bit offset: 4 desc:
        CH5: u1, // bit offset: 5 desc:
        CH6: u1, // bit offset: 6 desc:
        CH7: u1, // bit offset: 7 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 176 Interrupt status after masking & forcing
    pub const INTS = mmio(Address + 0x000000b0, 32, packed struct {
        CH0: u1, // bit offset: 0 desc:
        CH1: u1, // bit offset: 1 desc:
        CH2: u1, // bit offset: 2 desc:
        CH3: u1, // bit offset: 3 desc:
        CH4: u1, // bit offset: 4 desc:
        CH5: u1, // bit offset: 5 desc:
        CH6: u1, // bit offset: 6 desc:
        CH7: u1, // bit offset: 7 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const TIMER = extern struct {
    pub const Address: u32 = 0x40054000;
    // byte offset: 0 Write to bits 63:32 of time\n always write timelw before timehw
    pub const TIMEHW = mmio(Address + 0x00000000, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 4 Write to bits 31:0 of time\n writes do not get copied to time until timehw is written
    pub const TIMELW = mmio(Address + 0x00000004, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 8 Read from bits 63:32 of time\n always read timelr before timehr
    pub const TIMEHR = mmio(Address + 0x00000008, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 12 Read from bits 31:0 of time
    pub const TIMELR = mmio(Address + 0x0000000c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 16 Arm alarm 0, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM0 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
    pub const ALARM0 = mmio(Address + 0x00000010, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 20 Arm alarm 1, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM1 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
    pub const ALARM1 = mmio(Address + 0x00000014, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 24 Arm alarm 2, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM2 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
    pub const ALARM2 = mmio(Address + 0x00000018, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 28 Arm alarm 3, and configure the time it will fire.\n Once armed, the alarm fires when TIMER_ALARM3 == TIMELR.\n The alarm will disarm itself once it fires, and can\n be disarmed early using the ARMED status register.
    pub const ALARM3 = mmio(Address + 0x0000001c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 32 Indicates the armed/disarmed status of each alarm.\n A write to the corresponding ALARMx register arms the alarm.\n Alarms automatically disarm upon firing, but writing ones here\n will disarm immediately without waiting to fire.
    pub const ARMED = mmio(Address + 0x00000020, 32, packed struct {
        ARMED: u4, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 36 Raw read from bits 63:32 of time (no side effects)
    pub const TIMERAWH = mmio(Address + 0x00000024, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 40 Raw read from bits 31:0 of time (no side effects)
    pub const TIMERAWL = mmio(Address + 0x00000028, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 44 Set bits high to enable pause when the corresponding debug ports are active
    pub const DBGPAUSE = mmio(Address + 0x0000002c, 32, packed struct {
        reserved0: u1 = 0,
        DBG0: u1, // bit offset: 1 desc: Pause when processor 0 is in debug mode
        DBG1: u1, // bit offset: 2 desc: Pause when processor 1 is in debug mode
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 48 Set high to pause the timer
    pub const PAUSE = mmio(Address + 0x00000030, 32, packed struct {
        PAUSE: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 52 Raw Interrupts
    pub const INTR = mmio(Address + 0x00000034, 32, packed struct {
        ALARM_0: u1, // bit offset: 0 desc:
        ALARM_1: u1, // bit offset: 1 desc:
        ALARM_2: u1, // bit offset: 2 desc:
        ALARM_3: u1, // bit offset: 3 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 56 Interrupt Enable
    pub const INTE = mmio(Address + 0x00000038, 32, packed struct {
        ALARM_0: u1, // bit offset: 0 desc:
        ALARM_1: u1, // bit offset: 1 desc:
        ALARM_2: u1, // bit offset: 2 desc:
        ALARM_3: u1, // bit offset: 3 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 60 Interrupt Force
    pub const INTF = mmio(Address + 0x0000003c, 32, packed struct {
        ALARM_0: u1, // bit offset: 0 desc:
        ALARM_1: u1, // bit offset: 1 desc:
        ALARM_2: u1, // bit offset: 2 desc:
        ALARM_3: u1, // bit offset: 3 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 64 Interrupt status after masking & forcing
    pub const INTS = mmio(Address + 0x00000040, 32, packed struct {
        ALARM_0: u1, // bit offset: 0 desc:
        ALARM_1: u1, // bit offset: 1 desc:
        ALARM_2: u1, // bit offset: 2 desc:
        ALARM_3: u1, // bit offset: 3 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
};
pub const WATCHDOG = extern struct {
    pub const Address: u32 = 0x40058000;
    // byte offset: 0 Watchdog control\n The rst_wdsel register determines which subsystems are reset when the watchdog is triggered.\n The watchdog can be triggered in software.
    pub const CTRL = mmio(Address + 0x00000000, 32, packed struct {
        TIME: u24, // bit offset: 0 desc: Indicates the number of ticks / 2 (see errata RP2040-E1) before a watchdog reset will be triggered
        PAUSE_JTAG: u1, // bit offset: 24 desc: Pause the watchdog timer when JTAG is accessing the bus fabric
        PAUSE_DBG0: u1, // bit offset: 25 desc: Pause the watchdog timer when processor 0 is in debug mode
        PAUSE_DBG1: u1, // bit offset: 26 desc: Pause the watchdog timer when processor 1 is in debug mode
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        ENABLE: u1, // bit offset: 30 desc: When not enabled the watchdog timer is paused
        TRIGGER: u1, // bit offset: 31 desc: Trigger a watchdog reset
    });
    // byte offset: 4 Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
    pub const LOAD = mmio(Address + 0x00000004, 32, packed struct {
        LOAD: u24, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 8 Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
    pub const REASON = mmio(Address + 0x00000008, 32, packed struct {
        TIMER: u1, // bit offset: 0 desc:
        FORCE: u1, // bit offset: 1 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 12 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH0 = mmio(Address + 0x0000000c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 16 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH1 = mmio(Address + 0x00000010, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 20 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH2 = mmio(Address + 0x00000014, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 24 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH3 = mmio(Address + 0x00000018, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 28 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH4 = mmio(Address + 0x0000001c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 32 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH5 = mmio(Address + 0x00000020, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 36 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH6 = mmio(Address + 0x00000024, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 40 Scratch register. Information persists through soft reset of the chip.
    pub const SCRATCH7 = mmio(Address + 0x00000028, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 44 Controls the tick generator
    pub const TICK = mmio(Address + 0x0000002c, 32, packed struct {
        CYCLES: u9, // bit offset: 0 desc: Total number of clk_tick cycles before the next tick.
        ENABLE: u1, // bit offset: 9 desc: start / stop tick generation
        RUNNING: u1, // bit offset: 10 desc: Is the tick generator running?
        COUNT: u9, // bit offset: 11 desc: Count down timer: the remaining number clk_tick cycles before the next tick is generated.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
};
pub const RTC = extern struct {
    pub const Address: u32 = 0x4005c000;
    // byte offset: 0 Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled.
    pub const CLKDIV_M1 = mmio(Address + 0x00000000, 32, packed struct {
        CLKDIV_M1: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 4 RTC setup register 0
    pub const SETUP_0 = mmio(Address + 0x00000004, 32, packed struct {
        DAY: u5, // bit offset: 0 desc: Day of the month (1..31)
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        MONTH: u4, // bit offset: 8 desc: Month (1..12)
        YEAR: u12, // bit offset: 12 desc: Year
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 8 RTC setup register 1
    pub const SETUP_1 = mmio(Address + 0x00000008, 32, packed struct {
        SEC: u6, // bit offset: 0 desc: Seconds
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        MIN: u6, // bit offset: 8 desc: Minutes
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        HOUR: u5, // bit offset: 16 desc: Hours
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        DOTW: u3, // bit offset: 24 desc: Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 12 RTC Control and status
    pub const CTRL = mmio(Address + 0x0000000c, 32, packed struct {
        RTC_ENABLE: u1, // bit offset: 0 desc: Enable RTC
        RTC_ACTIVE: u1, // bit offset: 1 desc: RTC enabled (running)
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        LOAD: u1, // bit offset: 4 desc: Load RTC
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        FORCE_NOTLEAPYEAR: u1, // bit offset: 8 desc: If set, leapyear is forced off.\n Useful for years divisible by 100 but not by 400
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
    });
    // byte offset: 16 Interrupt setup register 0
    pub const IRQ_SETUP_0 = mmio(Address + 0x00000010, 32, packed struct {
        DAY: u5, // bit offset: 0 desc: Day of the month (1..31)
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        MONTH: u4, // bit offset: 8 desc: Month (1..12)
        YEAR: u12, // bit offset: 12 desc: Year
        DAY_ENA: u1, // bit offset: 24 desc: Enable day matching
        MONTH_ENA: u1, // bit offset: 25 desc: Enable month matching
        YEAR_ENA: u1, // bit offset: 26 desc: Enable year matching
        reserved3: u1 = 0,
        MATCH_ENA: u1, // bit offset: 28 desc: Global match enable. Don't change any other value while this one is enabled
        MATCH_ACTIVE: u1, // bit offset: 29 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Interrupt setup register 1
    pub const IRQ_SETUP_1 = mmio(Address + 0x00000014, 32, packed struct {
        SEC: u6, // bit offset: 0 desc: Seconds
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        MIN: u6, // bit offset: 8 desc: Minutes
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        HOUR: u5, // bit offset: 16 desc: Hours
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        DOTW: u3, // bit offset: 24 desc: Day of the week
        reserved7: u1 = 0,
        SEC_ENA: u1, // bit offset: 28 desc: Enable second matching
        MIN_ENA: u1, // bit offset: 29 desc: Enable minute matching
        HOUR_ENA: u1, // bit offset: 30 desc: Enable hour matching
        DOTW_ENA: u1, // bit offset: 31 desc: Enable day of the week matching
    });
    // byte offset: 24 RTC register 1.
    pub const RTC_1 = mmio(Address + 0x00000018, 32, packed struct {
        DAY: u5, // bit offset: 0 desc: Day of the month (1..31)
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        MONTH: u4, // bit offset: 8 desc: Month (1..12)
        YEAR: u12, // bit offset: 12 desc: Year
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 28 RTC register 0\n Read this before RTC 1!
    pub const RTC_0 = mmio(Address + 0x0000001c, 32, packed struct {
        SEC: u6, // bit offset: 0 desc: Seconds
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        MIN: u6, // bit offset: 8 desc: Minutes
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        HOUR: u5, // bit offset: 16 desc: Hours
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        DOTW: u3, // bit offset: 24 desc: Day of the week
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 32 Raw Interrupts
    pub const INTR = mmio(Address + 0x00000020, 32, packed struct {
        RTC: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 36 Interrupt Enable
    pub const INTE = mmio(Address + 0x00000024, 32, packed struct {
        RTC: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 40 Interrupt Force
    pub const INTF = mmio(Address + 0x00000028, 32, packed struct {
        RTC: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 44 Interrupt status after masking & forcing
    pub const INTS = mmio(Address + 0x0000002c, 32, packed struct {
        RTC: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
};
pub const ROSC = extern struct {
    pub const Address: u32 = 0x40060000;
    // byte offset: 0 Ring Oscillator control
    pub const CTRL = mmio(Address + 0x00000000, 32, packed struct {
        FREQ_RANGE: enum(u12) { // bit offset: 0 desc: Controls the number of delay stages in the ROSC ring\n LOW uses stages 0 to 7\n MEDIUM uses stages 0 to 5\n HIGH uses stages 0 to 3\n TOOHIGH uses stages 0 to 1 and should not be used because its frequency exceeds design specifications\n The clock output will not glitch when changing the range up one step at a time\n The clock output will glitch when changing the range down\n Note: the values here are gray coded which is why HIGH comes before TOOHIGH
            @"LOW" = 4004, // desc:
            @"MEDIUM" = 4005, // desc:
            @"HIGH" = 4007, // desc:
            @"TOOHIGH" = 4006, // desc:
            _, // non-exhaustive
        },
        ENABLE: enum(u12) { // bit offset: 12 desc: On power-up this field is initialised to ENABLE\n The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up\n The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.
            @"DISABLE" = 3358, // desc:
            @"ENABLE" = 4011, // desc:
            _, // non-exhaustive
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 4 The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage\n The drive strength has 4 levels determined by the number of bits set\n Increasing the number of bits set increases the drive strength and increases the oscillation frequency\n 0 bits set is the default drive strength\n 1 bit set doubles the drive strength\n 2 bits set triples drive strength\n 3 bits set quadruples drive strength
    pub const FREQA = mmio(Address + 0x00000004, 32, packed struct {
        DS0: u3, // bit offset: 0 desc: Stage 0 drive strength
        reserved0: u1 = 0,
        DS1: u3, // bit offset: 4 desc: Stage 1 drive strength
        reserved1: u1 = 0,
        DS2: u3, // bit offset: 8 desc: Stage 2 drive strength
        reserved2: u1 = 0,
        DS3: u3, // bit offset: 12 desc: Stage 3 drive strength
        reserved3: u1 = 0,
        PASSWD: enum(u16) { // bit offset: 16 desc: Set to 0x9696 to apply the settings\n Any other value in this field will set all drive strengths to 0
            @"PASS" = 38550, // desc:
            _, // non-exhaustive
        },
    });
    // byte offset: 8 For a detailed description see freqa register
    pub const FREQB = mmio(Address + 0x00000008, 32, packed struct {
        DS4: u3, // bit offset: 0 desc: Stage 4 drive strength
        reserved0: u1 = 0,
        DS5: u3, // bit offset: 4 desc: Stage 5 drive strength
        reserved1: u1 = 0,
        DS6: u3, // bit offset: 8 desc: Stage 6 drive strength
        reserved2: u1 = 0,
        DS7: u3, // bit offset: 12 desc: Stage 7 drive strength
        reserved3: u1 = 0,
        PASSWD: enum(u16) { // bit offset: 16 desc: Set to 0x9696 to apply the settings\n Any other value in this field will set all drive strengths to 0
            @"PASS" = 38550, // desc:
            _, // non-exhaustive
        },
    });
    // byte offset: 12 Ring Oscillator pause control\n This is used to save power by pausing the ROSC\n On power-up this field is initialised to WAKE\n An invalid write will also select WAKE\n Warning: setup the irq before selecting dormant mode
    pub const DORMANT = mmio(Address + 0x0000000c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 16 Controls the output divider
    pub const DIV = mmio(Address + 0x00000010, 32, packed struct {
        DIV: enum(u12) { // bit offset: 0 desc: set to 0xaa0 + div where\n div = 0 divides by 32\n div = 1-31 divides by div\n any other value sets div=0 and therefore divides by 32\n this register resets to div=16
            @"PASS" = 2720, // desc:
            _, // non-exhaustive
        },
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 20 Controls the phase shifted output
    pub const PHASE = mmio(Address + 0x00000014, 32, packed struct {
        SHIFT: u2, // bit offset: 0 desc: phase shift the phase-shifted output by SHIFT input clocks\n this can be changed on-the-fly\n must be set to 0 before setting div=1
        FLIP: u1, // bit offset: 2 desc: invert the phase-shifted output\n this is ignored when div=1
        ENABLE: u1, // bit offset: 3 desc: enable the phase-shifted output\n this can be changed on-the-fly
        PASSWD: u8, // bit offset: 4 desc: set to 0xaa0\n any other value enables the output with shift=0
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 24 Ring Oscillator Status
    pub const STATUS = mmio(Address + 0x00000018, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        ENABLED: u1, // bit offset: 12 desc: Oscillator is enabled but not necessarily running and stable\n this resets to 0 but transitions to 1 during chip startup
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        DIV_RUNNING: u1, // bit offset: 16 desc: post-divider is running\n this resets to 0 but transitions to 1 during chip startup
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        BADWRITE: u1, // bit offset: 24 desc: An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FRFEQA or FREQB or DORMANT
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        reserved24: u1 = 0,
        reserved25: u1 = 0,
        reserved26: u1 = 0,
        reserved27: u1 = 0,
        STABLE: u1, // bit offset: 31 desc: Oscillator is running and stable
    });
    // byte offset: 28 This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
    pub const RANDOMBIT = mmio(Address + 0x0000001c, 32, packed struct {
        RANDOMBIT: u1, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
        padding30: u1 = 0,
    });
    // byte offset: 32 A down counter running at the ROSC frequency which counts to zero and stops.\n To start the counter write a non-zero value.\n Can be used for short software pauses when setting up time sensitive hardware.
    pub const COUNT = mmio(Address + 0x00000020, 32, packed struct {
        COUNT: u8, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
};
pub const VREG_AND_CHIP_RESET = extern struct {
    pub const Address: u32 = 0x40064000;
    // byte offset: 0 Voltage regulator control and status
    pub const VREG = mmio(Address + 0x00000000, 32, packed struct {
        EN: u1, // bit offset: 0 desc: enable\n 0=not enabled, 1=enabled
        HIZ: u1, // bit offset: 1 desc: high impedance mode select\n 0=not in high impedance mode, 1=in high impedance mode
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        VSEL: u4, // bit offset: 4 desc: output voltage select\n 0000 to 0101 - 0.80V\n 0110 - 0.85V\n 0111 - 0.90V\n 1000 - 0.95V\n 1001 - 1.00V\n 1010 - 1.05V\n 1011 - 1.10V (default)\n 1100 - 1.15V\n 1101 - 1.20V\n 1110 - 1.25V\n 1111 - 1.30V
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        ROK: u1, // bit offset: 12 desc: regulation status\n 0=not in regulation, 1=in regulation
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
    });
    // byte offset: 4 brown-out detection control
    pub const BOD = mmio(Address + 0x00000004, 32, packed struct {
        EN: u1, // bit offset: 0 desc: enable\n 0=not enabled, 1=enabled
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        VSEL: u4, // bit offset: 4 desc: threshold select\n 0000 - 0.473V\n 0001 - 0.516V\n 0010 - 0.559V\n 0011 - 0.602V\n 0100 - 0.645V\n 0101 - 0.688V\n 0110 - 0.731V\n 0111 - 0.774V\n 1000 - 0.817V\n 1001 - 0.860V (default)\n 1010 - 0.903V\n 1011 - 0.946V\n 1100 - 0.989V\n 1101 - 1.032V\n 1110 - 1.075V\n 1111 - 1.118V
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 8 Chip reset control and status
    pub const CHIP_RESET = mmio(Address + 0x00000008, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        HAD_POR: u1, // bit offset: 8 desc: Last reset was from the power-on reset or brown-out detection blocks
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        HAD_RUN: u1, // bit offset: 16 desc: Last reset was from the RUN pin
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        HAD_PSM_RESTART: u1, // bit offset: 20 desc: Last reset was from the debug port
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        PSM_RESTART_FLAG: u1, // bit offset: 24 desc: This is set by psm_restart from the debugger.\n Its purpose is to branch bootcode to a safe mode when the debugger has issued a psm_restart in order to recover from a boot lock-up.\n In the safe mode the debugger can repair the boot code, clear this flag then reboot the processor.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
    });
};
pub const TBMAN = extern struct {
    pub const Address: u32 = 0x4006c000;
    // byte offset: 0 Indicates the type of platform in use
    pub const PLATFORM = mmio(Address + 0x00000000, 32, packed struct {
        ASIC: u1, // bit offset: 0 desc: Indicates the platform is an ASIC
        FPGA: u1, // bit offset: 1 desc: Indicates the platform is an FPGA
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
};
pub const DMA = extern struct {
    pub const Address: u32 = 0x50000000;
    // byte offset: 0 DMA Channel 0 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH0_READ_ADDR = mmio(Address + 0x00000000, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 4 DMA Channel 0 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH0_WRITE_ADDR = mmio(Address + 0x00000004, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 8 DMA Channel 0 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH0_TRANS_COUNT = mmio(Address + 0x00000008, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 12 DMA Channel 0 Control and Status
    pub const CH0_CTRL_TRIG = mmio(Address + 0x0000000c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (0).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 16 Alias for channel 0 CTRL register
    pub const CH0_AL1_CTRL = mmio(Address + 0x00000010, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 20 Alias for channel 0 READ_ADDR register
    pub const CH0_AL1_READ_ADDR = mmio(Address + 0x00000014, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 24 Alias for channel 0 WRITE_ADDR register
    pub const CH0_AL1_WRITE_ADDR = mmio(Address + 0x00000018, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 28 Alias for channel 0 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH0_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000001c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 32 Alias for channel 0 CTRL register
    pub const CH0_AL2_CTRL = mmio(Address + 0x00000020, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 36 Alias for channel 0 TRANS_COUNT register
    pub const CH0_AL2_TRANS_COUNT = mmio(Address + 0x00000024, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 40 Alias for channel 0 READ_ADDR register
    pub const CH0_AL2_READ_ADDR = mmio(Address + 0x00000028, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 44 Alias for channel 0 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH0_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x0000002c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 48 Alias for channel 0 CTRL register
    pub const CH0_AL3_CTRL = mmio(Address + 0x00000030, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 52 Alias for channel 0 WRITE_ADDR register
    pub const CH0_AL3_WRITE_ADDR = mmio(Address + 0x00000034, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 56 Alias for channel 0 TRANS_COUNT register
    pub const CH0_AL3_TRANS_COUNT = mmio(Address + 0x00000038, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 60 Alias for channel 0 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH0_AL3_READ_ADDR_TRIG = mmio(Address + 0x0000003c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 64 DMA Channel 1 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH1_READ_ADDR = mmio(Address + 0x00000040, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 68 DMA Channel 1 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH1_WRITE_ADDR = mmio(Address + 0x00000044, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 72 DMA Channel 1 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH1_TRANS_COUNT = mmio(Address + 0x00000048, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 76 DMA Channel 1 Control and Status
    pub const CH1_CTRL_TRIG = mmio(Address + 0x0000004c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (1).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 80 Alias for channel 1 CTRL register
    pub const CH1_AL1_CTRL = mmio(Address + 0x00000050, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 84 Alias for channel 1 READ_ADDR register
    pub const CH1_AL1_READ_ADDR = mmio(Address + 0x00000054, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 88 Alias for channel 1 WRITE_ADDR register
    pub const CH1_AL1_WRITE_ADDR = mmio(Address + 0x00000058, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 92 Alias for channel 1 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH1_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000005c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 96 Alias for channel 1 CTRL register
    pub const CH1_AL2_CTRL = mmio(Address + 0x00000060, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 100 Alias for channel 1 TRANS_COUNT register
    pub const CH1_AL2_TRANS_COUNT = mmio(Address + 0x00000064, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 104 Alias for channel 1 READ_ADDR register
    pub const CH1_AL2_READ_ADDR = mmio(Address + 0x00000068, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 108 Alias for channel 1 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH1_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x0000006c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 112 Alias for channel 1 CTRL register
    pub const CH1_AL3_CTRL = mmio(Address + 0x00000070, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 116 Alias for channel 1 WRITE_ADDR register
    pub const CH1_AL3_WRITE_ADDR = mmio(Address + 0x00000074, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 120 Alias for channel 1 TRANS_COUNT register
    pub const CH1_AL3_TRANS_COUNT = mmio(Address + 0x00000078, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 124 Alias for channel 1 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH1_AL3_READ_ADDR_TRIG = mmio(Address + 0x0000007c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 128 DMA Channel 2 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH2_READ_ADDR = mmio(Address + 0x00000080, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 132 DMA Channel 2 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH2_WRITE_ADDR = mmio(Address + 0x00000084, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 136 DMA Channel 2 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH2_TRANS_COUNT = mmio(Address + 0x00000088, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 140 DMA Channel 2 Control and Status
    pub const CH2_CTRL_TRIG = mmio(Address + 0x0000008c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (2).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 144 Alias for channel 2 CTRL register
    pub const CH2_AL1_CTRL = mmio(Address + 0x00000090, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 148 Alias for channel 2 READ_ADDR register
    pub const CH2_AL1_READ_ADDR = mmio(Address + 0x00000094, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 152 Alias for channel 2 WRITE_ADDR register
    pub const CH2_AL1_WRITE_ADDR = mmio(Address + 0x00000098, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 156 Alias for channel 2 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH2_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000009c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 160 Alias for channel 2 CTRL register
    pub const CH2_AL2_CTRL = mmio(Address + 0x000000a0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 164 Alias for channel 2 TRANS_COUNT register
    pub const CH2_AL2_TRANS_COUNT = mmio(Address + 0x000000a4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 168 Alias for channel 2 READ_ADDR register
    pub const CH2_AL2_READ_ADDR = mmio(Address + 0x000000a8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 172 Alias for channel 2 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH2_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x000000ac, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 176 Alias for channel 2 CTRL register
    pub const CH2_AL3_CTRL = mmio(Address + 0x000000b0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 180 Alias for channel 2 WRITE_ADDR register
    pub const CH2_AL3_WRITE_ADDR = mmio(Address + 0x000000b4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 184 Alias for channel 2 TRANS_COUNT register
    pub const CH2_AL3_TRANS_COUNT = mmio(Address + 0x000000b8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 188 Alias for channel 2 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH2_AL3_READ_ADDR_TRIG = mmio(Address + 0x000000bc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 192 DMA Channel 3 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH3_READ_ADDR = mmio(Address + 0x000000c0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 196 DMA Channel 3 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH3_WRITE_ADDR = mmio(Address + 0x000000c4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 200 DMA Channel 3 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH3_TRANS_COUNT = mmio(Address + 0x000000c8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 204 DMA Channel 3 Control and Status
    pub const CH3_CTRL_TRIG = mmio(Address + 0x000000cc, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (3).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 208 Alias for channel 3 CTRL register
    pub const CH3_AL1_CTRL = mmio(Address + 0x000000d0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 212 Alias for channel 3 READ_ADDR register
    pub const CH3_AL1_READ_ADDR = mmio(Address + 0x000000d4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 216 Alias for channel 3 WRITE_ADDR register
    pub const CH3_AL1_WRITE_ADDR = mmio(Address + 0x000000d8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 220 Alias for channel 3 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH3_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x000000dc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 224 Alias for channel 3 CTRL register
    pub const CH3_AL2_CTRL = mmio(Address + 0x000000e0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 228 Alias for channel 3 TRANS_COUNT register
    pub const CH3_AL2_TRANS_COUNT = mmio(Address + 0x000000e4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 232 Alias for channel 3 READ_ADDR register
    pub const CH3_AL2_READ_ADDR = mmio(Address + 0x000000e8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 236 Alias for channel 3 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH3_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x000000ec, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 240 Alias for channel 3 CTRL register
    pub const CH3_AL3_CTRL = mmio(Address + 0x000000f0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 244 Alias for channel 3 WRITE_ADDR register
    pub const CH3_AL3_WRITE_ADDR = mmio(Address + 0x000000f4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 248 Alias for channel 3 TRANS_COUNT register
    pub const CH3_AL3_TRANS_COUNT = mmio(Address + 0x000000f8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 252 Alias for channel 3 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH3_AL3_READ_ADDR_TRIG = mmio(Address + 0x000000fc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 256 DMA Channel 4 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH4_READ_ADDR = mmio(Address + 0x00000100, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 260 DMA Channel 4 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH4_WRITE_ADDR = mmio(Address + 0x00000104, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 264 DMA Channel 4 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH4_TRANS_COUNT = mmio(Address + 0x00000108, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 268 DMA Channel 4 Control and Status
    pub const CH4_CTRL_TRIG = mmio(Address + 0x0000010c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (4).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 272 Alias for channel 4 CTRL register
    pub const CH4_AL1_CTRL = mmio(Address + 0x00000110, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 276 Alias for channel 4 READ_ADDR register
    pub const CH4_AL1_READ_ADDR = mmio(Address + 0x00000114, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 280 Alias for channel 4 WRITE_ADDR register
    pub const CH4_AL1_WRITE_ADDR = mmio(Address + 0x00000118, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 284 Alias for channel 4 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH4_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000011c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 288 Alias for channel 4 CTRL register
    pub const CH4_AL2_CTRL = mmio(Address + 0x00000120, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 292 Alias for channel 4 TRANS_COUNT register
    pub const CH4_AL2_TRANS_COUNT = mmio(Address + 0x00000124, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 296 Alias for channel 4 READ_ADDR register
    pub const CH4_AL2_READ_ADDR = mmio(Address + 0x00000128, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 300 Alias for channel 4 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH4_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x0000012c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 304 Alias for channel 4 CTRL register
    pub const CH4_AL3_CTRL = mmio(Address + 0x00000130, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 308 Alias for channel 4 WRITE_ADDR register
    pub const CH4_AL3_WRITE_ADDR = mmio(Address + 0x00000134, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 312 Alias for channel 4 TRANS_COUNT register
    pub const CH4_AL3_TRANS_COUNT = mmio(Address + 0x00000138, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 316 Alias for channel 4 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH4_AL3_READ_ADDR_TRIG = mmio(Address + 0x0000013c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 320 DMA Channel 5 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH5_READ_ADDR = mmio(Address + 0x00000140, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 324 DMA Channel 5 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH5_WRITE_ADDR = mmio(Address + 0x00000144, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 328 DMA Channel 5 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH5_TRANS_COUNT = mmio(Address + 0x00000148, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 332 DMA Channel 5 Control and Status
    pub const CH5_CTRL_TRIG = mmio(Address + 0x0000014c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (5).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 336 Alias for channel 5 CTRL register
    pub const CH5_AL1_CTRL = mmio(Address + 0x00000150, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 340 Alias for channel 5 READ_ADDR register
    pub const CH5_AL1_READ_ADDR = mmio(Address + 0x00000154, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 344 Alias for channel 5 WRITE_ADDR register
    pub const CH5_AL1_WRITE_ADDR = mmio(Address + 0x00000158, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 348 Alias for channel 5 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH5_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000015c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 352 Alias for channel 5 CTRL register
    pub const CH5_AL2_CTRL = mmio(Address + 0x00000160, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 356 Alias for channel 5 TRANS_COUNT register
    pub const CH5_AL2_TRANS_COUNT = mmio(Address + 0x00000164, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 360 Alias for channel 5 READ_ADDR register
    pub const CH5_AL2_READ_ADDR = mmio(Address + 0x00000168, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 364 Alias for channel 5 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH5_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x0000016c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 368 Alias for channel 5 CTRL register
    pub const CH5_AL3_CTRL = mmio(Address + 0x00000170, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 372 Alias for channel 5 WRITE_ADDR register
    pub const CH5_AL3_WRITE_ADDR = mmio(Address + 0x00000174, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 376 Alias for channel 5 TRANS_COUNT register
    pub const CH5_AL3_TRANS_COUNT = mmio(Address + 0x00000178, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 380 Alias for channel 5 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH5_AL3_READ_ADDR_TRIG = mmio(Address + 0x0000017c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 384 DMA Channel 6 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH6_READ_ADDR = mmio(Address + 0x00000180, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 388 DMA Channel 6 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH6_WRITE_ADDR = mmio(Address + 0x00000184, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 392 DMA Channel 6 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH6_TRANS_COUNT = mmio(Address + 0x00000188, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 396 DMA Channel 6 Control and Status
    pub const CH6_CTRL_TRIG = mmio(Address + 0x0000018c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (6).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 400 Alias for channel 6 CTRL register
    pub const CH6_AL1_CTRL = mmio(Address + 0x00000190, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 404 Alias for channel 6 READ_ADDR register
    pub const CH6_AL1_READ_ADDR = mmio(Address + 0x00000194, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 408 Alias for channel 6 WRITE_ADDR register
    pub const CH6_AL1_WRITE_ADDR = mmio(Address + 0x00000198, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 412 Alias for channel 6 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH6_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000019c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 416 Alias for channel 6 CTRL register
    pub const CH6_AL2_CTRL = mmio(Address + 0x000001a0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 420 Alias for channel 6 TRANS_COUNT register
    pub const CH6_AL2_TRANS_COUNT = mmio(Address + 0x000001a4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 424 Alias for channel 6 READ_ADDR register
    pub const CH6_AL2_READ_ADDR = mmio(Address + 0x000001a8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 428 Alias for channel 6 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH6_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x000001ac, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 432 Alias for channel 6 CTRL register
    pub const CH6_AL3_CTRL = mmio(Address + 0x000001b0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 436 Alias for channel 6 WRITE_ADDR register
    pub const CH6_AL3_WRITE_ADDR = mmio(Address + 0x000001b4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 440 Alias for channel 6 TRANS_COUNT register
    pub const CH6_AL3_TRANS_COUNT = mmio(Address + 0x000001b8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 444 Alias for channel 6 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH6_AL3_READ_ADDR_TRIG = mmio(Address + 0x000001bc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 448 DMA Channel 7 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH7_READ_ADDR = mmio(Address + 0x000001c0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 452 DMA Channel 7 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH7_WRITE_ADDR = mmio(Address + 0x000001c4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 456 DMA Channel 7 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH7_TRANS_COUNT = mmio(Address + 0x000001c8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 460 DMA Channel 7 Control and Status
    pub const CH7_CTRL_TRIG = mmio(Address + 0x000001cc, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (7).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 464 Alias for channel 7 CTRL register
    pub const CH7_AL1_CTRL = mmio(Address + 0x000001d0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 468 Alias for channel 7 READ_ADDR register
    pub const CH7_AL1_READ_ADDR = mmio(Address + 0x000001d4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 472 Alias for channel 7 WRITE_ADDR register
    pub const CH7_AL1_WRITE_ADDR = mmio(Address + 0x000001d8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 476 Alias for channel 7 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH7_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x000001dc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 480 Alias for channel 7 CTRL register
    pub const CH7_AL2_CTRL = mmio(Address + 0x000001e0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 484 Alias for channel 7 TRANS_COUNT register
    pub const CH7_AL2_TRANS_COUNT = mmio(Address + 0x000001e4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 488 Alias for channel 7 READ_ADDR register
    pub const CH7_AL2_READ_ADDR = mmio(Address + 0x000001e8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 492 Alias for channel 7 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH7_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x000001ec, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 496 Alias for channel 7 CTRL register
    pub const CH7_AL3_CTRL = mmio(Address + 0x000001f0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 500 Alias for channel 7 WRITE_ADDR register
    pub const CH7_AL3_WRITE_ADDR = mmio(Address + 0x000001f4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 504 Alias for channel 7 TRANS_COUNT register
    pub const CH7_AL3_TRANS_COUNT = mmio(Address + 0x000001f8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 508 Alias for channel 7 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH7_AL3_READ_ADDR_TRIG = mmio(Address + 0x000001fc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 512 DMA Channel 8 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH8_READ_ADDR = mmio(Address + 0x00000200, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 516 DMA Channel 8 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH8_WRITE_ADDR = mmio(Address + 0x00000204, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 520 DMA Channel 8 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH8_TRANS_COUNT = mmio(Address + 0x00000208, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 524 DMA Channel 8 Control and Status
    pub const CH8_CTRL_TRIG = mmio(Address + 0x0000020c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (8).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 528 Alias for channel 8 CTRL register
    pub const CH8_AL1_CTRL = mmio(Address + 0x00000210, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 532 Alias for channel 8 READ_ADDR register
    pub const CH8_AL1_READ_ADDR = mmio(Address + 0x00000214, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 536 Alias for channel 8 WRITE_ADDR register
    pub const CH8_AL1_WRITE_ADDR = mmio(Address + 0x00000218, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 540 Alias for channel 8 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH8_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000021c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 544 Alias for channel 8 CTRL register
    pub const CH8_AL2_CTRL = mmio(Address + 0x00000220, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 548 Alias for channel 8 TRANS_COUNT register
    pub const CH8_AL2_TRANS_COUNT = mmio(Address + 0x00000224, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 552 Alias for channel 8 READ_ADDR register
    pub const CH8_AL2_READ_ADDR = mmio(Address + 0x00000228, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 556 Alias for channel 8 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH8_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x0000022c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 560 Alias for channel 8 CTRL register
    pub const CH8_AL3_CTRL = mmio(Address + 0x00000230, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 564 Alias for channel 8 WRITE_ADDR register
    pub const CH8_AL3_WRITE_ADDR = mmio(Address + 0x00000234, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 568 Alias for channel 8 TRANS_COUNT register
    pub const CH8_AL3_TRANS_COUNT = mmio(Address + 0x00000238, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 572 Alias for channel 8 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH8_AL3_READ_ADDR_TRIG = mmio(Address + 0x0000023c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 576 DMA Channel 9 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH9_READ_ADDR = mmio(Address + 0x00000240, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 580 DMA Channel 9 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH9_WRITE_ADDR = mmio(Address + 0x00000244, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 584 DMA Channel 9 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH9_TRANS_COUNT = mmio(Address + 0x00000248, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 588 DMA Channel 9 Control and Status
    pub const CH9_CTRL_TRIG = mmio(Address + 0x0000024c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (9).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 592 Alias for channel 9 CTRL register
    pub const CH9_AL1_CTRL = mmio(Address + 0x00000250, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 596 Alias for channel 9 READ_ADDR register
    pub const CH9_AL1_READ_ADDR = mmio(Address + 0x00000254, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 600 Alias for channel 9 WRITE_ADDR register
    pub const CH9_AL1_WRITE_ADDR = mmio(Address + 0x00000258, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 604 Alias for channel 9 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH9_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000025c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 608 Alias for channel 9 CTRL register
    pub const CH9_AL2_CTRL = mmio(Address + 0x00000260, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 612 Alias for channel 9 TRANS_COUNT register
    pub const CH9_AL2_TRANS_COUNT = mmio(Address + 0x00000264, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 616 Alias for channel 9 READ_ADDR register
    pub const CH9_AL2_READ_ADDR = mmio(Address + 0x00000268, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 620 Alias for channel 9 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH9_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x0000026c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 624 Alias for channel 9 CTRL register
    pub const CH9_AL3_CTRL = mmio(Address + 0x00000270, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 628 Alias for channel 9 WRITE_ADDR register
    pub const CH9_AL3_WRITE_ADDR = mmio(Address + 0x00000274, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 632 Alias for channel 9 TRANS_COUNT register
    pub const CH9_AL3_TRANS_COUNT = mmio(Address + 0x00000278, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 636 Alias for channel 9 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH9_AL3_READ_ADDR_TRIG = mmio(Address + 0x0000027c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 640 DMA Channel 10 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH10_READ_ADDR = mmio(Address + 0x00000280, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 644 DMA Channel 10 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH10_WRITE_ADDR = mmio(Address + 0x00000284, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 648 DMA Channel 10 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH10_TRANS_COUNT = mmio(Address + 0x00000288, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 652 DMA Channel 10 Control and Status
    pub const CH10_CTRL_TRIG = mmio(Address + 0x0000028c, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (10).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 656 Alias for channel 10 CTRL register
    pub const CH10_AL1_CTRL = mmio(Address + 0x00000290, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 660 Alias for channel 10 READ_ADDR register
    pub const CH10_AL1_READ_ADDR = mmio(Address + 0x00000294, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 664 Alias for channel 10 WRITE_ADDR register
    pub const CH10_AL1_WRITE_ADDR = mmio(Address + 0x00000298, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 668 Alias for channel 10 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH10_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x0000029c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 672 Alias for channel 10 CTRL register
    pub const CH10_AL2_CTRL = mmio(Address + 0x000002a0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 676 Alias for channel 10 TRANS_COUNT register
    pub const CH10_AL2_TRANS_COUNT = mmio(Address + 0x000002a4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 680 Alias for channel 10 READ_ADDR register
    pub const CH10_AL2_READ_ADDR = mmio(Address + 0x000002a8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 684 Alias for channel 10 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH10_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x000002ac, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 688 Alias for channel 10 CTRL register
    pub const CH10_AL3_CTRL = mmio(Address + 0x000002b0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 692 Alias for channel 10 WRITE_ADDR register
    pub const CH10_AL3_WRITE_ADDR = mmio(Address + 0x000002b4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 696 Alias for channel 10 TRANS_COUNT register
    pub const CH10_AL3_TRANS_COUNT = mmio(Address + 0x000002b8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 700 Alias for channel 10 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH10_AL3_READ_ADDR_TRIG = mmio(Address + 0x000002bc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 704 DMA Channel 11 Read Address pointer\n This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
    pub const CH11_READ_ADDR = mmio(Address + 0x000002c0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 708 DMA Channel 11 Write Address pointer\n This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
    pub const CH11_WRITE_ADDR = mmio(Address + 0x000002c4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 712 DMA Channel 11 Transfer Count\n Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
    pub const CH11_TRANS_COUNT = mmio(Address + 0x000002c8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 716 DMA Channel 11 Control and Status
    pub const CH11_CTRL_TRIG = mmio(Address + 0x000002cc, 32, packed struct {
        EN: u1, // bit offset: 0 desc: DMA Channel Enable.\n When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
        HIGH_PRIORITY: u1, // bit offset: 1 desc: HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
        DATA_SIZE: enum(u2) { // bit offset: 2 desc: Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
            @"SIZE_BYTE" = 0, // desc:
            @"SIZE_HALFWORD" = 1, // desc:
            @"SIZE_WORD" = 2, // desc:
            _, // non-exhaustive
        },
        INCR_READ: u1, // bit offset: 4 desc: If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n Generally this should be disabled for peripheral-to-memory transfers.
        INCR_WRITE: u1, // bit offset: 5 desc: If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n Generally this should be disabled for memory-to-peripheral transfers.
        RING_SIZE: enum(u4) { // bit offset: 6 desc: Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
            @"RING_NONE" = 0, // desc:
            _, // non-exhaustive
        },
        RING_SEL: u1, // bit offset: 10 desc: Select whether RING_SIZE applies to read or write addresses.\n If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
        CHAIN_TO: u4, // bit offset: 11 desc: When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.\n Reset value is equal to channel number (11).
        TREQ_SEL: enum(u6) { // bit offset: 15 desc: Select a Transfer Request signal.\n The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system).\n 0x0 to 0x3a -> select DREQ n as TREQ
            @"TIMER0" = 59, // desc: Select Timer 0 as TREQ
            @"TIMER1" = 60, // desc: Select Timer 1 as TREQ
            @"TIMER2" = 61, // desc: Select Timer 2 as TREQ (Optional)
            @"TIMER3" = 62, // desc: Select Timer 3 as TREQ (Optional)
            @"PERMANENT" = 63, // desc: Permanent request, for unpaced transfers.
            _, // non-exhaustive
        },
        IRQ_QUIET: u1, // bit offset: 21 desc: In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
        BSWAP: u1, // bit offset: 22 desc: Apply byte-swap transformation to DMA data.\n For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
        SNIFF_EN: u1, // bit offset: 23 desc: If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n This allows checksum to be enabled or disabled on a per-control- block basis.
        BUSY: u1, // bit offset: 24 desc: This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        WRITE_ERROR: u1, // bit offset: 29 desc: If 1, the channel received a write bus error. Write one to clear.\n WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later)
        READ_ERROR: u1, // bit offset: 30 desc: If 1, the channel received a read bus error. Write one to clear.\n READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later)
        AHB_ERROR: u1, // bit offset: 31 desc: Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
    });
    // byte offset: 720 Alias for channel 11 CTRL register
    pub const CH11_AL1_CTRL = mmio(Address + 0x000002d0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 724 Alias for channel 11 READ_ADDR register
    pub const CH11_AL1_READ_ADDR = mmio(Address + 0x000002d4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 728 Alias for channel 11 WRITE_ADDR register
    pub const CH11_AL1_WRITE_ADDR = mmio(Address + 0x000002d8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 732 Alias for channel 11 TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH11_AL1_TRANS_COUNT_TRIG = mmio(Address + 0x000002dc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 736 Alias for channel 11 CTRL register
    pub const CH11_AL2_CTRL = mmio(Address + 0x000002e0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 740 Alias for channel 11 TRANS_COUNT register
    pub const CH11_AL2_TRANS_COUNT = mmio(Address + 0x000002e4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 744 Alias for channel 11 READ_ADDR register
    pub const CH11_AL2_READ_ADDR = mmio(Address + 0x000002e8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 748 Alias for channel 11 WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH11_AL2_WRITE_ADDR_TRIG = mmio(Address + 0x000002ec, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 752 Alias for channel 11 CTRL register
    pub const CH11_AL3_CTRL = mmio(Address + 0x000002f0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 756 Alias for channel 11 WRITE_ADDR register
    pub const CH11_AL3_WRITE_ADDR = mmio(Address + 0x000002f4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 760 Alias for channel 11 TRANS_COUNT register
    pub const CH11_AL3_TRANS_COUNT = mmio(Address + 0x000002f8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 764 Alias for channel 11 READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value will\n reload the channel counter and start the channel.
    pub const CH11_AL3_READ_ADDR_TRIG = mmio(Address + 0x000002fc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 1024 Interrupt Status (raw)
    pub const INTR = mmio(Address + 0x00000400, 32, packed struct {
        INTR: u16, // bit offset: 0 desc: Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1.\n\n Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1.\n\n This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores.\n\n It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1028 Interrupt Enables for IRQ 0
    pub const INTE0 = mmio(Address + 0x00000404, 32, packed struct {
        INTE0: u16, // bit offset: 0 desc: Set bit n to pass interrupts from channel n to DMA IRQ 0.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1032 Force Interrupts
    pub const INTF0 = mmio(Address + 0x00000408, 32, packed struct {
        INTF0: u16, // bit offset: 0 desc: Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1036 Interrupt Status for IRQ 0
    pub const INTS0 = mmio(Address + 0x0000040c, 32, packed struct {
        INTS0: u16, // bit offset: 0 desc: Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted.\n Channel interrupts can be cleared by writing a bit mask here.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1044 Interrupt Enables for IRQ 1
    pub const INTE1 = mmio(Address + 0x00000414, 32, packed struct {
        INTE1: u16, // bit offset: 0 desc: Set bit n to pass interrupts from channel n to DMA IRQ 1.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1048 Force Interrupts for IRQ 1
    pub const INTF1 = mmio(Address + 0x00000418, 32, packed struct {
        INTF1: u16, // bit offset: 0 desc: Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1052 Interrupt Status (masked) for IRQ 1
    pub const INTS1 = mmio(Address + 0x0000041c, 32, packed struct {
        INTS1: u16, // bit offset: 0 desc: Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted.\n Channel interrupts can be cleared by writing a bit mask here.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1056 Pacing (X/Y) Fractional Timer\n The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
    pub const TIMER0 = mmio(Address + 0x00000420, 32, packed struct {
        Y: u16, // bit offset: 0 desc: Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
        X: u16, // bit offset: 16 desc: Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
    });
    // byte offset: 1060 Pacing (X/Y) Fractional Timer\n The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
    pub const TIMER1 = mmio(Address + 0x00000424, 32, packed struct {
        Y: u16, // bit offset: 0 desc: Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
        X: u16, // bit offset: 16 desc: Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
    });
    // byte offset: 1072 Trigger one or more channels simultaneously
    pub const MULTI_CHAN_TRIGGER = mmio(Address + 0x00000430, 32, packed struct {
        MULTI_CHAN_TRIGGER: u16, // bit offset: 0 desc: Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1076 Sniffer Control
    pub const SNIFF_CTRL = mmio(Address + 0x00000434, 32, packed struct {
        EN: u1, // bit offset: 0 desc: Enable sniffer
        DMACH: u4, // bit offset: 1 desc: DMA channel for Sniffer to observe
        CALC: enum(u4) { // bit offset: 5 desc:
            @"CRC32" = 0, // desc: Calculate a CRC-32 (IEEE802.3 polynomial)
            @"CRC32R" = 1, // desc: Calculate a CRC-32 (IEEE802.3 polynomial) with bit reversed data
            @"CRC16" = 2, // desc: Calculate a CRC-16-CCITT
            @"CRC16R" = 3, // desc: Calculate a CRC-16-CCITT with bit reversed data
            @"EVEN" = 14, // desc: XOR reduction over all data. == 1 if the total 1 population count is odd.
            @"SUM" = 15, // desc: Calculate a simple 32-bit checksum (addition with a 32 bit accumulator)
            _, // non-exhaustive
        },
        BSWAP: u1, // bit offset: 9 desc: Locally perform a byte reverse on the sniffed data, before feeding into checksum.\n\n Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view.
        OUT_REV: u1, // bit offset: 10 desc: If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
        OUT_INV: u1, // bit offset: 11 desc: If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 1080 Data accumulator for sniff hardware\n Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register.
    pub const SNIFF_DATA = mmio(Address + 0x00000438, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 1088 Debug RAF, WAF, TDF levels
    pub const FIFO_LEVELS = mmio(Address + 0x00000440, 32, packed struct {
        TDF_LVL: u8, // bit offset: 0 desc: Current Transfer-Data-FIFO fill level
        WAF_LVL: u8, // bit offset: 8 desc: Current Write-Address-FIFO fill level
        RAF_LVL: u8, // bit offset: 16 desc: Current Read-Address-FIFO fill level
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 1092 Abort an in-progress transfer sequence on one or more channels
    pub const CHAN_ABORT = mmio(Address + 0x00000444, 32, packed struct {
        CHAN_ABORT: u16, // bit offset: 0 desc: Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs.\n\n After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 1096 The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
    pub const N_CHANNELS = mmio(Address + 0x00000448, 32, packed struct {
        N_CHANNELS: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 2048 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH0_DBG_CTDREQ = mmio(Address + 0x00000800, 32, packed struct {
        CH0_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2052 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH0_DBG_TCR = mmio(Address + 0x00000804, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2112 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH1_DBG_CTDREQ = mmio(Address + 0x00000840, 32, packed struct {
        CH1_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2116 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH1_DBG_TCR = mmio(Address + 0x00000844, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2176 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH2_DBG_CTDREQ = mmio(Address + 0x00000880, 32, packed struct {
        CH2_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2180 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH2_DBG_TCR = mmio(Address + 0x00000884, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2240 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH3_DBG_CTDREQ = mmio(Address + 0x000008c0, 32, packed struct {
        CH3_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2244 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH3_DBG_TCR = mmio(Address + 0x000008c4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2304 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH4_DBG_CTDREQ = mmio(Address + 0x00000900, 32, packed struct {
        CH4_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2308 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH4_DBG_TCR = mmio(Address + 0x00000904, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2368 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH5_DBG_CTDREQ = mmio(Address + 0x00000940, 32, packed struct {
        CH5_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2372 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH5_DBG_TCR = mmio(Address + 0x00000944, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2432 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH6_DBG_CTDREQ = mmio(Address + 0x00000980, 32, packed struct {
        CH6_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2436 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH6_DBG_TCR = mmio(Address + 0x00000984, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2496 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH7_DBG_CTDREQ = mmio(Address + 0x000009c0, 32, packed struct {
        CH7_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2500 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH7_DBG_TCR = mmio(Address + 0x000009c4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2560 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH8_DBG_CTDREQ = mmio(Address + 0x00000a00, 32, packed struct {
        CH8_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2564 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH8_DBG_TCR = mmio(Address + 0x00000a04, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2624 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH9_DBG_CTDREQ = mmio(Address + 0x00000a40, 32, packed struct {
        CH9_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2628 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH9_DBG_TCR = mmio(Address + 0x00000a44, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2688 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH10_DBG_CTDREQ = mmio(Address + 0x00000a80, 32, packed struct {
        CH10_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2692 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH10_DBG_TCR = mmio(Address + 0x00000a84, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 2752 Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
    pub const CH11_DBG_CTDREQ = mmio(Address + 0x00000ac0, 32, packed struct {
        CH11_DBG_CTDREQ: u6, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 2756 Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
    pub const CH11_DBG_TCR = mmio(Address + 0x00000ac4, 32, packed struct {
        raw: u32, // placeholder field
    });
};
pub const USBCTRL_REGS = extern struct {
    pub const Address: u32 = 0x50110000;
    // byte offset: 0 Device address and endpoint control
    pub const ADDR_ENDP = mmio(Address + 0x00000000, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Device endpoint to send data to. Only valid for HOST mode.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
    // byte offset: 4 Interrupt endpoint 1. Only valid for HOST mode.
    pub const ADDR_ENDP1 = mmio(Address + 0x00000004, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 8 Interrupt endpoint 2. Only valid for HOST mode.
    pub const ADDR_ENDP2 = mmio(Address + 0x00000008, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 12 Interrupt endpoint 3. Only valid for HOST mode.
    pub const ADDR_ENDP3 = mmio(Address + 0x0000000c, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 16 Interrupt endpoint 4. Only valid for HOST mode.
    pub const ADDR_ENDP4 = mmio(Address + 0x00000010, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 20 Interrupt endpoint 5. Only valid for HOST mode.
    pub const ADDR_ENDP5 = mmio(Address + 0x00000014, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 24 Interrupt endpoint 6. Only valid for HOST mode.
    pub const ADDR_ENDP6 = mmio(Address + 0x00000018, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 28 Interrupt endpoint 7. Only valid for HOST mode.
    pub const ADDR_ENDP7 = mmio(Address + 0x0000001c, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 32 Interrupt endpoint 8. Only valid for HOST mode.
    pub const ADDR_ENDP8 = mmio(Address + 0x00000020, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 36 Interrupt endpoint 9. Only valid for HOST mode.
    pub const ADDR_ENDP9 = mmio(Address + 0x00000024, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 40 Interrupt endpoint 10. Only valid for HOST mode.
    pub const ADDR_ENDP10 = mmio(Address + 0x00000028, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 44 Interrupt endpoint 11. Only valid for HOST mode.
    pub const ADDR_ENDP11 = mmio(Address + 0x0000002c, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 48 Interrupt endpoint 12. Only valid for HOST mode.
    pub const ADDR_ENDP12 = mmio(Address + 0x00000030, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 52 Interrupt endpoint 13. Only valid for HOST mode.
    pub const ADDR_ENDP13 = mmio(Address + 0x00000034, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 56 Interrupt endpoint 14. Only valid for HOST mode.
    pub const ADDR_ENDP14 = mmio(Address + 0x00000038, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 60 Interrupt endpoint 15. Only valid for HOST mode.
    pub const ADDR_ENDP15 = mmio(Address + 0x0000003c, 32, packed struct {
        ADDRESS: u7, // bit offset: 0 desc: Device address
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        ENDPOINT: u4, // bit offset: 16 desc: Endpoint number of the interrupt endpoint
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        INTEP_DIR: u1, // bit offset: 25 desc: Direction of the interrupt endpoint. In=0, Out=1
        INTEP_PREAMBLE: u1, // bit offset: 26 desc: Interrupt EP requires preamble (is a low speed device on a full speed hub)
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
    });
    // byte offset: 64 Main control register
    pub const MAIN_CTRL = mmio(Address + 0x00000040, 32, packed struct {
        CONTROLLER_EN: u1, // bit offset: 0 desc: Enable controller
        HOST_NDEVICE: u1, // bit offset: 1 desc: Device mode = 0, Host mode = 1
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        reserved24: u1 = 0,
        reserved25: u1 = 0,
        reserved26: u1 = 0,
        reserved27: u1 = 0,
        reserved28: u1 = 0,
        SIM_TIMING: u1, // bit offset: 31 desc: Reduced timings for simulation
    });
    // byte offset: 68 Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
    pub const SOF_WR = mmio(Address + 0x00000044, 32, packed struct {
        COUNT: u11, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 72 Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
    pub const SOF_RD = mmio(Address + 0x00000048, 32, packed struct {
        COUNT: u11, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
    });
    // byte offset: 76 SIE control register
    pub const SIE_CTRL = mmio(Address + 0x0000004c, 32, packed struct {
        START_TRANS: u1, // bit offset: 0 desc: Host: Start transaction
        SEND_SETUP: u1, // bit offset: 1 desc: Host: Send Setup packet
        SEND_DATA: u1, // bit offset: 2 desc: Host: Send transaction (OUT from host)
        RECEIVE_DATA: u1, // bit offset: 3 desc: Host: Receive transaction (IN to host)
        STOP_TRANS: u1, // bit offset: 4 desc: Host: Stop transaction
        reserved0: u1 = 0,
        PREAMBLE_EN: u1, // bit offset: 6 desc: Host: Preable enable for LS device on FS hub
        reserved1: u1 = 0,
        SOF_SYNC: u1, // bit offset: 8 desc: Host: Delay packet(s) until after SOF
        SOF_EN: u1, // bit offset: 9 desc: Host: Enable SOF generation (for full speed bus)
        KEEP_ALIVE_EN: u1, // bit offset: 10 desc: Host: Enable keep alive packet (for low speed bus)
        VBUS_EN: u1, // bit offset: 11 desc: Host: Enable VBUS
        RESUME: u1, // bit offset: 12 desc: Device: Remote wakeup. Device can initiate its own resume after suspend.
        RESET_BUS: u1, // bit offset: 13 desc: Host: Reset bus
        reserved2: u1 = 0,
        PULLDOWN_EN: u1, // bit offset: 15 desc: Host: Enable pull down resistors
        PULLUP_EN: u1, // bit offset: 16 desc: Device: Enable pull up resistor
        RPU_OPT: u1, // bit offset: 17 desc: Device: Pull-up strength (0=1K2, 1=2k3)
        TRANSCEIVER_PD: u1, // bit offset: 18 desc: Power down bus transceiver
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        DIRECT_DM: u1, // bit offset: 24 desc: Direct control of DM
        DIRECT_DP: u1, // bit offset: 25 desc: Direct control of DP
        DIRECT_EN: u1, // bit offset: 26 desc: Direct bus drive enable
        EP0_INT_NAK: u1, // bit offset: 27 desc: Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
        EP0_INT_2BUF: u1, // bit offset: 28 desc: Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
        EP0_INT_1BUF: u1, // bit offset: 29 desc: Device: Set bit in BUFF_STATUS for every buffer completed on EP0
        EP0_DOUBLE_BUF: u1, // bit offset: 30 desc: Device: EP0 single buffered = 0, double buffered = 1
        EP0_INT_STALL: u1, // bit offset: 31 desc: Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
    });
    // byte offset: 80 SIE status register
    pub const SIE_STATUS = mmio(Address + 0x00000050, 32, packed struct {
        VBUS_DETECTED: u1, // bit offset: 0 desc: Device: VBUS Detected
        reserved0: u1 = 0,
        LINE_STATE: u2, // bit offset: 2 desc: USB bus line state
        SUSPENDED: u1, // bit offset: 4 desc: Bus in suspended state. Valid for device and host. Host and device will go into suspend if neither Keep Alive / SOF frames are enabled.
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        SPEED: u2, // bit offset: 8 desc: Host: device speed. Disconnected = 00, LS = 01, FS = 10
        VBUS_OVER_CURR: u1, // bit offset: 10 desc: VBUS over current detected
        RESUME: u1, // bit offset: 11 desc: Host: Device has initiated a remote resume. Device: host has initiated a resume.
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        CONNECTED: u1, // bit offset: 16 desc: Device: connected
        SETUP_REC: u1, // bit offset: 17 desc: Device: Setup packet received
        TRANS_COMPLETE: u1, // bit offset: 18 desc: Transaction complete.\n\n Raised by device if:\n\n * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register\n\n Raised by host if:\n\n * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
        BUS_RESET: u1, // bit offset: 19 desc: Device: bus reset received
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        CRC_ERROR: u1, // bit offset: 24 desc: CRC Error. Raised by the Serial RX engine.
        BIT_STUFF_ERROR: u1, // bit offset: 25 desc: Bit Stuff Error. Raised by the Serial RX engine.
        RX_OVERFLOW: u1, // bit offset: 26 desc: RX overflow is raised by the Serial RX engine if the incoming data is too fast.
        RX_TIMEOUT: u1, // bit offset: 27 desc: RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec.
        NAK_REC: u1, // bit offset: 28 desc: Host: NAK received
        STALL_REC: u1, // bit offset: 29 desc: Host: STALL received
        ACK_REC: u1, // bit offset: 30 desc: ACK received. Raised by both host and device.
        DATA_SEQ_ERROR: u1, // bit offset: 31 desc: Data Sequence Error.\n\n The device can raise a sequence error in the following conditions:\n\n * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM\n\n The host can raise a data sequence error in the following conditions:\n\n * An IN packet from the device has the wrong data PID
    });
    // byte offset: 84 interrupt endpoint control register
    pub const INT_EP_CTRL = mmio(Address + 0x00000054, 32, packed struct {
        reserved0: u1 = 0,
        INT_EP_ACTIVE: u15, // bit offset: 1 desc: Host: Enable interrupt endpoint 1 -> 15
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 88 Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
    pub const BUFF_STATUS = mmio(Address + 0x00000058, 32, packed struct {
        EP0_IN: u1, // bit offset: 0 desc:
        EP0_OUT: u1, // bit offset: 1 desc:
        EP1_IN: u1, // bit offset: 2 desc:
        EP1_OUT: u1, // bit offset: 3 desc:
        EP2_IN: u1, // bit offset: 4 desc:
        EP2_OUT: u1, // bit offset: 5 desc:
        EP3_IN: u1, // bit offset: 6 desc:
        EP3_OUT: u1, // bit offset: 7 desc:
        EP4_IN: u1, // bit offset: 8 desc:
        EP4_OUT: u1, // bit offset: 9 desc:
        EP5_IN: u1, // bit offset: 10 desc:
        EP5_OUT: u1, // bit offset: 11 desc:
        EP6_IN: u1, // bit offset: 12 desc:
        EP6_OUT: u1, // bit offset: 13 desc:
        EP7_IN: u1, // bit offset: 14 desc:
        EP7_OUT: u1, // bit offset: 15 desc:
        EP8_IN: u1, // bit offset: 16 desc:
        EP8_OUT: u1, // bit offset: 17 desc:
        EP9_IN: u1, // bit offset: 18 desc:
        EP9_OUT: u1, // bit offset: 19 desc:
        EP10_IN: u1, // bit offset: 20 desc:
        EP10_OUT: u1, // bit offset: 21 desc:
        EP11_IN: u1, // bit offset: 22 desc:
        EP11_OUT: u1, // bit offset: 23 desc:
        EP12_IN: u1, // bit offset: 24 desc:
        EP12_OUT: u1, // bit offset: 25 desc:
        EP13_IN: u1, // bit offset: 26 desc:
        EP13_OUT: u1, // bit offset: 27 desc:
        EP14_IN: u1, // bit offset: 28 desc:
        EP14_OUT: u1, // bit offset: 29 desc:
        EP15_IN: u1, // bit offset: 30 desc:
        EP15_OUT: u1, // bit offset: 31 desc:
    });
    // byte offset: 92 Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
    pub const BUFF_CPU_SHOULD_HANDLE = mmio(Address + 0x0000005c, 32, packed struct {
        EP0_IN: u1, // bit offset: 0 desc:
        EP0_OUT: u1, // bit offset: 1 desc:
        EP1_IN: u1, // bit offset: 2 desc:
        EP1_OUT: u1, // bit offset: 3 desc:
        EP2_IN: u1, // bit offset: 4 desc:
        EP2_OUT: u1, // bit offset: 5 desc:
        EP3_IN: u1, // bit offset: 6 desc:
        EP3_OUT: u1, // bit offset: 7 desc:
        EP4_IN: u1, // bit offset: 8 desc:
        EP4_OUT: u1, // bit offset: 9 desc:
        EP5_IN: u1, // bit offset: 10 desc:
        EP5_OUT: u1, // bit offset: 11 desc:
        EP6_IN: u1, // bit offset: 12 desc:
        EP6_OUT: u1, // bit offset: 13 desc:
        EP7_IN: u1, // bit offset: 14 desc:
        EP7_OUT: u1, // bit offset: 15 desc:
        EP8_IN: u1, // bit offset: 16 desc:
        EP8_OUT: u1, // bit offset: 17 desc:
        EP9_IN: u1, // bit offset: 18 desc:
        EP9_OUT: u1, // bit offset: 19 desc:
        EP10_IN: u1, // bit offset: 20 desc:
        EP10_OUT: u1, // bit offset: 21 desc:
        EP11_IN: u1, // bit offset: 22 desc:
        EP11_OUT: u1, // bit offset: 23 desc:
        EP12_IN: u1, // bit offset: 24 desc:
        EP12_OUT: u1, // bit offset: 25 desc:
        EP13_IN: u1, // bit offset: 26 desc:
        EP13_OUT: u1, // bit offset: 27 desc:
        EP14_IN: u1, // bit offset: 28 desc:
        EP14_OUT: u1, // bit offset: 29 desc:
        EP15_IN: u1, // bit offset: 30 desc:
        EP15_OUT: u1, // bit offset: 31 desc:
    });
    // byte offset: 96 Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
    pub const EP_ABORT = mmio(Address + 0x00000060, 32, packed struct {
        EP0_IN: u1, // bit offset: 0 desc:
        EP0_OUT: u1, // bit offset: 1 desc:
        EP1_IN: u1, // bit offset: 2 desc:
        EP1_OUT: u1, // bit offset: 3 desc:
        EP2_IN: u1, // bit offset: 4 desc:
        EP2_OUT: u1, // bit offset: 5 desc:
        EP3_IN: u1, // bit offset: 6 desc:
        EP3_OUT: u1, // bit offset: 7 desc:
        EP4_IN: u1, // bit offset: 8 desc:
        EP4_OUT: u1, // bit offset: 9 desc:
        EP5_IN: u1, // bit offset: 10 desc:
        EP5_OUT: u1, // bit offset: 11 desc:
        EP6_IN: u1, // bit offset: 12 desc:
        EP6_OUT: u1, // bit offset: 13 desc:
        EP7_IN: u1, // bit offset: 14 desc:
        EP7_OUT: u1, // bit offset: 15 desc:
        EP8_IN: u1, // bit offset: 16 desc:
        EP8_OUT: u1, // bit offset: 17 desc:
        EP9_IN: u1, // bit offset: 18 desc:
        EP9_OUT: u1, // bit offset: 19 desc:
        EP10_IN: u1, // bit offset: 20 desc:
        EP10_OUT: u1, // bit offset: 21 desc:
        EP11_IN: u1, // bit offset: 22 desc:
        EP11_OUT: u1, // bit offset: 23 desc:
        EP12_IN: u1, // bit offset: 24 desc:
        EP12_OUT: u1, // bit offset: 25 desc:
        EP13_IN: u1, // bit offset: 26 desc:
        EP13_OUT: u1, // bit offset: 27 desc:
        EP14_IN: u1, // bit offset: 28 desc:
        EP14_OUT: u1, // bit offset: 29 desc:
        EP15_IN: u1, // bit offset: 30 desc:
        EP15_OUT: u1, // bit offset: 31 desc:
    });
    // byte offset: 100 Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
    pub const EP_ABORT_DONE = mmio(Address + 0x00000064, 32, packed struct {
        EP0_IN: u1, // bit offset: 0 desc:
        EP0_OUT: u1, // bit offset: 1 desc:
        EP1_IN: u1, // bit offset: 2 desc:
        EP1_OUT: u1, // bit offset: 3 desc:
        EP2_IN: u1, // bit offset: 4 desc:
        EP2_OUT: u1, // bit offset: 5 desc:
        EP3_IN: u1, // bit offset: 6 desc:
        EP3_OUT: u1, // bit offset: 7 desc:
        EP4_IN: u1, // bit offset: 8 desc:
        EP4_OUT: u1, // bit offset: 9 desc:
        EP5_IN: u1, // bit offset: 10 desc:
        EP5_OUT: u1, // bit offset: 11 desc:
        EP6_IN: u1, // bit offset: 12 desc:
        EP6_OUT: u1, // bit offset: 13 desc:
        EP7_IN: u1, // bit offset: 14 desc:
        EP7_OUT: u1, // bit offset: 15 desc:
        EP8_IN: u1, // bit offset: 16 desc:
        EP8_OUT: u1, // bit offset: 17 desc:
        EP9_IN: u1, // bit offset: 18 desc:
        EP9_OUT: u1, // bit offset: 19 desc:
        EP10_IN: u1, // bit offset: 20 desc:
        EP10_OUT: u1, // bit offset: 21 desc:
        EP11_IN: u1, // bit offset: 22 desc:
        EP11_OUT: u1, // bit offset: 23 desc:
        EP12_IN: u1, // bit offset: 24 desc:
        EP12_OUT: u1, // bit offset: 25 desc:
        EP13_IN: u1, // bit offset: 26 desc:
        EP13_OUT: u1, // bit offset: 27 desc:
        EP14_IN: u1, // bit offset: 28 desc:
        EP14_OUT: u1, // bit offset: 29 desc:
        EP15_IN: u1, // bit offset: 30 desc:
        EP15_OUT: u1, // bit offset: 31 desc:
    });
    // byte offset: 104 Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
    pub const EP_STALL_ARM = mmio(Address + 0x00000068, 32, packed struct {
        EP0_IN: u1, // bit offset: 0 desc:
        EP0_OUT: u1, // bit offset: 1 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 108 Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
    pub const NAK_POLL = mmio(Address + 0x0000006c, 32, packed struct {
        DELAY_LS: u10, // bit offset: 0 desc: NAK polling interval for a low speed device
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        DELAY_FS: u10, // bit offset: 16 desc: NAK polling interval for a full speed device
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
    });
    // byte offset: 112 Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
    pub const EP_STATUS_STALL_NAK = mmio(Address + 0x00000070, 32, packed struct {
        EP0_IN: u1, // bit offset: 0 desc:
        EP0_OUT: u1, // bit offset: 1 desc:
        EP1_IN: u1, // bit offset: 2 desc:
        EP1_OUT: u1, // bit offset: 3 desc:
        EP2_IN: u1, // bit offset: 4 desc:
        EP2_OUT: u1, // bit offset: 5 desc:
        EP3_IN: u1, // bit offset: 6 desc:
        EP3_OUT: u1, // bit offset: 7 desc:
        EP4_IN: u1, // bit offset: 8 desc:
        EP4_OUT: u1, // bit offset: 9 desc:
        EP5_IN: u1, // bit offset: 10 desc:
        EP5_OUT: u1, // bit offset: 11 desc:
        EP6_IN: u1, // bit offset: 12 desc:
        EP6_OUT: u1, // bit offset: 13 desc:
        EP7_IN: u1, // bit offset: 14 desc:
        EP7_OUT: u1, // bit offset: 15 desc:
        EP8_IN: u1, // bit offset: 16 desc:
        EP8_OUT: u1, // bit offset: 17 desc:
        EP9_IN: u1, // bit offset: 18 desc:
        EP9_OUT: u1, // bit offset: 19 desc:
        EP10_IN: u1, // bit offset: 20 desc:
        EP10_OUT: u1, // bit offset: 21 desc:
        EP11_IN: u1, // bit offset: 22 desc:
        EP11_OUT: u1, // bit offset: 23 desc:
        EP12_IN: u1, // bit offset: 24 desc:
        EP12_OUT: u1, // bit offset: 25 desc:
        EP13_IN: u1, // bit offset: 26 desc:
        EP13_OUT: u1, // bit offset: 27 desc:
        EP14_IN: u1, // bit offset: 28 desc:
        EP14_OUT: u1, // bit offset: 29 desc:
        EP15_IN: u1, // bit offset: 30 desc:
        EP15_OUT: u1, // bit offset: 31 desc:
    });
    // byte offset: 116 Where to connect the USB controller. Should be to_phy by default.
    pub const USB_MUXING = mmio(Address + 0x00000074, 32, packed struct {
        TO_PHY: u1, // bit offset: 0 desc:
        TO_EXTPHY: u1, // bit offset: 1 desc:
        TO_DIGITAL_PAD: u1, // bit offset: 2 desc:
        SOFTCON: u1, // bit offset: 3 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 120 Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.
    pub const USB_PWR = mmio(Address + 0x00000078, 32, packed struct {
        VBUS_EN: u1, // bit offset: 0 desc:
        VBUS_EN_OVERRIDE_EN: u1, // bit offset: 1 desc:
        VBUS_DETECT: u1, // bit offset: 2 desc:
        VBUS_DETECT_OVERRIDE_EN: u1, // bit offset: 3 desc:
        OVERCURR_DETECT: u1, // bit offset: 4 desc:
        OVERCURR_DETECT_EN: u1, // bit offset: 5 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 124 This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.
    pub const USBPHY_DIRECT = mmio(Address + 0x0000007c, 32, packed struct {
        DP_PULLUP_HISEL: u1, // bit offset: 0 desc: Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
        DP_PULLUP_EN: u1, // bit offset: 1 desc: DP pull up enable
        DP_PULLDN_EN: u1, // bit offset: 2 desc: DP pull down enable
        reserved0: u1 = 0,
        DM_PULLUP_HISEL: u1, // bit offset: 4 desc: Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
        DM_PULLUP_EN: u1, // bit offset: 5 desc: DM pull up enable
        DM_PULLDN_EN: u1, // bit offset: 6 desc: DM pull down enable
        reserved1: u1 = 0,
        TX_DP_OE: u1, // bit offset: 8 desc: Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving\n If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving
        TX_DM_OE: u1, // bit offset: 9 desc: Output enable. If TX_DIFFMODE=1, Ignored.\n If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving
        TX_DP: u1, // bit offset: 10 desc: Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP\n If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP
        TX_DM: u1, // bit offset: 11 desc: Output data. TX_DIFFMODE=1, Ignored\n TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM
        RX_PD: u1, // bit offset: 12 desc: RX power down override (if override enable is set). 1 = powered down.
        TX_PD: u1, // bit offset: 13 desc: TX power down override (if override enable is set). 1 = powered down.
        TX_FSSLEW: u1, // bit offset: 14 desc: TX_FSSLEW=0: Low speed slew rate\n TX_FSSLEW=1: Full speed slew rate
        TX_DIFFMODE: u1, // bit offset: 15 desc: TX_DIFFMODE=0: Single ended mode\n TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE ignored)
        RX_DD: u1, // bit offset: 16 desc: Differential RX
        RX_DP: u1, // bit offset: 17 desc: DPP pin state
        RX_DM: u1, // bit offset: 18 desc: DPM pin state
        DP_OVCN: u1, // bit offset: 19 desc: DP overcurrent
        DM_OVCN: u1, // bit offset: 20 desc: DM overcurrent
        DP_OVV: u1, // bit offset: 21 desc: DP over voltage
        DM_OVV: u1, // bit offset: 22 desc: DM over voltage
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
    });
    // byte offset: 128 Override enable for each control in usbphy_direct
    pub const USBPHY_DIRECT_OVERRIDE = mmio(Address + 0x00000080, 32, packed struct {
        DP_PULLUP_HISEL_OVERRIDE_EN: u1, // bit offset: 0 desc:
        DM_PULLUP_HISEL_OVERRIDE_EN: u1, // bit offset: 1 desc:
        DP_PULLUP_EN_OVERRIDE_EN: u1, // bit offset: 2 desc:
        DP_PULLDN_EN_OVERRIDE_EN: u1, // bit offset: 3 desc:
        DM_PULLDN_EN_OVERRIDE_EN: u1, // bit offset: 4 desc:
        TX_DP_OE_OVERRIDE_EN: u1, // bit offset: 5 desc:
        TX_DM_OE_OVERRIDE_EN: u1, // bit offset: 6 desc:
        TX_DP_OVERRIDE_EN: u1, // bit offset: 7 desc:
        TX_DM_OVERRIDE_EN: u1, // bit offset: 8 desc:
        RX_PD_OVERRIDE_EN: u1, // bit offset: 9 desc:
        TX_PD_OVERRIDE_EN: u1, // bit offset: 10 desc:
        TX_FSSLEW_OVERRIDE_EN: u1, // bit offset: 11 desc:
        DM_PULLUP_OVERRIDE_EN: u1, // bit offset: 12 desc:
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        TX_DIFFMODE_OVERRIDE_EN: u1, // bit offset: 15 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 132 Used to adjust trim values of USB phy pull down resistors.
    pub const USBPHY_TRIM = mmio(Address + 0x00000084, 32, packed struct {
        DP_PULLDN_TRIM: u5, // bit offset: 0 desc: Value to drive to USB PHY\n DP pulldown resistor trim control\n Experimental data suggests that the reset value will work, but this register allows adjustment if required
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        DM_PULLDN_TRIM: u5, // bit offset: 8 desc: Value to drive to USB PHY\n DM pulldown resistor trim control\n Experimental data suggests that the reset value will work, but this register allows adjustment if required
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
    });
    // byte offset: 140 Raw Interrupts
    pub const INTR = mmio(Address + 0x0000008c, 32, packed struct {
        HOST_CONN_DIS: u1, // bit offset: 0 desc: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_RESUME: u1, // bit offset: 1 desc: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_SOF: u1, // bit offset: 2 desc: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        TRANS_COMPLETE: u1, // bit offset: 3 desc: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        BUFF_STATUS: u1, // bit offset: 4 desc: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        ERROR_DATA_SEQ: u1, // bit offset: 5 desc: Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_RX_TIMEOUT: u1, // bit offset: 6 desc: Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_OVERFLOW: u1, // bit offset: 7 desc: Source: SIE_STATUS.RX_OVERFLOW
        ERROR_BIT_STUFF: u1, // bit offset: 8 desc: Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_CRC: u1, // bit offset: 9 desc: Source: SIE_STATUS.CRC_ERROR
        STALL: u1, // bit offset: 10 desc: Source: SIE_STATUS.STALL_REC
        VBUS_DETECT: u1, // bit offset: 11 desc: Source: SIE_STATUS.VBUS_DETECT
        BUS_RESET: u1, // bit offset: 12 desc: Source: SIE_STATUS.BUS_RESET
        DEV_CONN_DIS: u1, // bit offset: 13 desc: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_SUSPEND: u1, // bit offset: 14 desc: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_RESUME_FROM_HOST: u1, // bit offset: 15 desc: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        SETUP_REQ: u1, // bit offset: 16 desc: Device. Source: SIE_STATUS.SETUP_REC
        DEV_SOF: u1, // bit offset: 17 desc: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        ABORT_DONE: u1, // bit offset: 18 desc: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        EP_STALL_NAK: u1, // bit offset: 19 desc: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
    // byte offset: 144 Interrupt Enable
    pub const INTE = mmio(Address + 0x00000090, 32, packed struct {
        HOST_CONN_DIS: u1, // bit offset: 0 desc: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_RESUME: u1, // bit offset: 1 desc: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_SOF: u1, // bit offset: 2 desc: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        TRANS_COMPLETE: u1, // bit offset: 3 desc: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        BUFF_STATUS: u1, // bit offset: 4 desc: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        ERROR_DATA_SEQ: u1, // bit offset: 5 desc: Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_RX_TIMEOUT: u1, // bit offset: 6 desc: Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_OVERFLOW: u1, // bit offset: 7 desc: Source: SIE_STATUS.RX_OVERFLOW
        ERROR_BIT_STUFF: u1, // bit offset: 8 desc: Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_CRC: u1, // bit offset: 9 desc: Source: SIE_STATUS.CRC_ERROR
        STALL: u1, // bit offset: 10 desc: Source: SIE_STATUS.STALL_REC
        VBUS_DETECT: u1, // bit offset: 11 desc: Source: SIE_STATUS.VBUS_DETECT
        BUS_RESET: u1, // bit offset: 12 desc: Source: SIE_STATUS.BUS_RESET
        DEV_CONN_DIS: u1, // bit offset: 13 desc: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_SUSPEND: u1, // bit offset: 14 desc: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_RESUME_FROM_HOST: u1, // bit offset: 15 desc: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        SETUP_REQ: u1, // bit offset: 16 desc: Device. Source: SIE_STATUS.SETUP_REC
        DEV_SOF: u1, // bit offset: 17 desc: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        ABORT_DONE: u1, // bit offset: 18 desc: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        EP_STALL_NAK: u1, // bit offset: 19 desc: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
    // byte offset: 148 Interrupt Force
    pub const INTF = mmio(Address + 0x00000094, 32, packed struct {
        HOST_CONN_DIS: u1, // bit offset: 0 desc: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_RESUME: u1, // bit offset: 1 desc: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_SOF: u1, // bit offset: 2 desc: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        TRANS_COMPLETE: u1, // bit offset: 3 desc: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        BUFF_STATUS: u1, // bit offset: 4 desc: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        ERROR_DATA_SEQ: u1, // bit offset: 5 desc: Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_RX_TIMEOUT: u1, // bit offset: 6 desc: Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_OVERFLOW: u1, // bit offset: 7 desc: Source: SIE_STATUS.RX_OVERFLOW
        ERROR_BIT_STUFF: u1, // bit offset: 8 desc: Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_CRC: u1, // bit offset: 9 desc: Source: SIE_STATUS.CRC_ERROR
        STALL: u1, // bit offset: 10 desc: Source: SIE_STATUS.STALL_REC
        VBUS_DETECT: u1, // bit offset: 11 desc: Source: SIE_STATUS.VBUS_DETECT
        BUS_RESET: u1, // bit offset: 12 desc: Source: SIE_STATUS.BUS_RESET
        DEV_CONN_DIS: u1, // bit offset: 13 desc: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_SUSPEND: u1, // bit offset: 14 desc: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_RESUME_FROM_HOST: u1, // bit offset: 15 desc: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        SETUP_REQ: u1, // bit offset: 16 desc: Device. Source: SIE_STATUS.SETUP_REC
        DEV_SOF: u1, // bit offset: 17 desc: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        ABORT_DONE: u1, // bit offset: 18 desc: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        EP_STALL_NAK: u1, // bit offset: 19 desc: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
    // byte offset: 152 Interrupt status after masking & forcing
    pub const INTS = mmio(Address + 0x00000098, 32, packed struct {
        HOST_CONN_DIS: u1, // bit offset: 0 desc: Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
        HOST_RESUME: u1, // bit offset: 1 desc: Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
        HOST_SOF: u1, // bit offset: 2 desc: Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
        TRANS_COMPLETE: u1, // bit offset: 3 desc: Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
        BUFF_STATUS: u1, // bit offset: 4 desc: Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
        ERROR_DATA_SEQ: u1, // bit offset: 5 desc: Source: SIE_STATUS.DATA_SEQ_ERROR
        ERROR_RX_TIMEOUT: u1, // bit offset: 6 desc: Source: SIE_STATUS.RX_TIMEOUT
        ERROR_RX_OVERFLOW: u1, // bit offset: 7 desc: Source: SIE_STATUS.RX_OVERFLOW
        ERROR_BIT_STUFF: u1, // bit offset: 8 desc: Source: SIE_STATUS.BIT_STUFF_ERROR
        ERROR_CRC: u1, // bit offset: 9 desc: Source: SIE_STATUS.CRC_ERROR
        STALL: u1, // bit offset: 10 desc: Source: SIE_STATUS.STALL_REC
        VBUS_DETECT: u1, // bit offset: 11 desc: Source: SIE_STATUS.VBUS_DETECT
        BUS_RESET: u1, // bit offset: 12 desc: Source: SIE_STATUS.BUS_RESET
        DEV_CONN_DIS: u1, // bit offset: 13 desc: Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
        DEV_SUSPEND: u1, // bit offset: 14 desc: Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
        DEV_RESUME_FROM_HOST: u1, // bit offset: 15 desc: Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
        SETUP_REQ: u1, // bit offset: 16 desc: Device. Source: SIE_STATUS.SETUP_REC
        DEV_SOF: u1, // bit offset: 17 desc: Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
        ABORT_DONE: u1, // bit offset: 18 desc: Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
        EP_STALL_NAK: u1, // bit offset: 19 desc: Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
    });
};
pub const PIO0 = extern struct {
    pub const Address: u32 = 0x50200000;
    // byte offset: 0 PIO control register
    pub const CTRL = mmio(Address + 0x00000000, 32, packed struct {
        SM_ENABLE: u4, // bit offset: 0 desc: Enable state machine
        SM_RESTART: u4, // bit offset: 4 desc: Clear internal SM state which is otherwise difficult to access\n (e.g. shift counters). Self-clearing.
        CLKDIV_RESTART: u4, // bit offset: 8 desc: Force clock dividers to restart their count and clear fractional\n accumulators. Restart multiple dividers to synchronise them.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 4 FIFO status register
    pub const FSTAT = mmio(Address + 0x00000004, 32, packed struct {
        RXFULL: u4, // bit offset: 0 desc: State machine RX FIFO is full
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        RXEMPTY: u4, // bit offset: 8 desc: State machine RX FIFO is empty
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        TXFULL: u4, // bit offset: 16 desc: State machine TX FIFO is full
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        TXEMPTY: u4, // bit offset: 24 desc: State machine TX FIFO is empty
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
    });
    // byte offset: 8 FIFO debug register
    pub const FDEBUG = mmio(Address + 0x00000008, 32, packed struct {
        RXSTALL: u4, // bit offset: 0 desc: State machine has stalled on full RX FIFO. Write 1 to clear.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        RXUNDER: u4, // bit offset: 8 desc: RX FIFO underflow has occurred. Write 1 to clear.
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        TXOVER: u4, // bit offset: 16 desc: TX FIFO overflow has occurred. Write 1 to clear.
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        TXSTALL: u4, // bit offset: 24 desc: State machine has stalled on empty TX FIFO. Write 1 to clear.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
    });
    // byte offset: 12 FIFO levels
    pub const FLEVEL = mmio(Address + 0x0000000c, 32, packed struct {
        TX0: u4, // bit offset: 0 desc:
        RX0: u4, // bit offset: 4 desc:
        TX1: u4, // bit offset: 8 desc:
        RX1: u4, // bit offset: 12 desc:
        TX2: u4, // bit offset: 16 desc:
        RX2: u4, // bit offset: 20 desc:
        TX3: u4, // bit offset: 24 desc:
        RX3: u4, // bit offset: 28 desc:
    });
    // byte offset: 16 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF0 = mmio(Address + 0x00000010, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 20 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF1 = mmio(Address + 0x00000014, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 24 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF2 = mmio(Address + 0x00000018, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 28 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF3 = mmio(Address + 0x0000001c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 32 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF0 = mmio(Address + 0x00000020, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 36 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF1 = mmio(Address + 0x00000024, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 40 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF2 = mmio(Address + 0x00000028, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 44 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF3 = mmio(Address + 0x0000002c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 48 Interrupt request register. Write 1 to clear
    pub const IRQ = mmio(Address + 0x00000030, 32, packed struct {
        IRQ: u8, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 52 Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.\n Note this is different to the INTF register: writing here affects PIO internal\n state. INTF just asserts the processor-facing IRQ signal for testing ISRs,\n and is not visible to the state machines.
    pub const IRQ_FORCE = mmio(Address + 0x00000034, 32, packed struct {
        IRQ_FORCE: u8, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 56 There is a 2-flipflop synchronizer on each GPIO input, which protects\n PIO logic from metastabilities. This increases input delay, and for fast\n synchronous IO (e.g. SPI) these synchronizers may need to be bypassed.\n Each bit in this register corresponds to one GPIO.\n 0 -> input is synchronized (default)\n 1 -> synchronizer is bypassed\n If in doubt, leave this register as all zeroes.
    pub const INPUT_SYNC_BYPASS = mmio(Address + 0x00000038, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 60 Read to sample the pad output values PIO is currently driving to the GPIOs.
    pub const DBG_PADOUT = mmio(Address + 0x0000003c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 64 Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs.
    pub const DBG_PADOE = mmio(Address + 0x00000040, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 68 The PIO hardware has some free parameters that may vary between chip products.\n These should be provided in the chip datasheet, but are also exposed here.
    pub const DBG_CFGINFO = mmio(Address + 0x00000044, 32, packed struct {
        FIFO_DEPTH: u6, // bit offset: 0 desc: The depth of the state machine TX/RX FIFOs, measured in words.\n Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double\n this depth.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        SM_COUNT: u4, // bit offset: 8 desc: The number of state machines this PIO instance is equipped with.
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IMEM_SIZE: u6, // bit offset: 16 desc: The size of the instruction memory, measured in units of one instruction
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
    });
    // byte offset: 72 Write-only access to instruction memory location 0
    pub const INSTR_MEM0 = mmio(Address + 0x00000048, 32, packed struct {
        INSTR_MEM0: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 76 Write-only access to instruction memory location 1
    pub const INSTR_MEM1 = mmio(Address + 0x0000004c, 32, packed struct {
        INSTR_MEM1: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 80 Write-only access to instruction memory location 2
    pub const INSTR_MEM2 = mmio(Address + 0x00000050, 32, packed struct {
        INSTR_MEM2: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 84 Write-only access to instruction memory location 3
    pub const INSTR_MEM3 = mmio(Address + 0x00000054, 32, packed struct {
        INSTR_MEM3: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 88 Write-only access to instruction memory location 4
    pub const INSTR_MEM4 = mmio(Address + 0x00000058, 32, packed struct {
        INSTR_MEM4: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 92 Write-only access to instruction memory location 5
    pub const INSTR_MEM5 = mmio(Address + 0x0000005c, 32, packed struct {
        INSTR_MEM5: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 96 Write-only access to instruction memory location 6
    pub const INSTR_MEM6 = mmio(Address + 0x00000060, 32, packed struct {
        INSTR_MEM6: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 100 Write-only access to instruction memory location 7
    pub const INSTR_MEM7 = mmio(Address + 0x00000064, 32, packed struct {
        INSTR_MEM7: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 104 Write-only access to instruction memory location 8
    pub const INSTR_MEM8 = mmio(Address + 0x00000068, 32, packed struct {
        INSTR_MEM8: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 108 Write-only access to instruction memory location 9
    pub const INSTR_MEM9 = mmio(Address + 0x0000006c, 32, packed struct {
        INSTR_MEM9: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 112 Write-only access to instruction memory location 10
    pub const INSTR_MEM10 = mmio(Address + 0x00000070, 32, packed struct {
        INSTR_MEM10: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 116 Write-only access to instruction memory location 11
    pub const INSTR_MEM11 = mmio(Address + 0x00000074, 32, packed struct {
        INSTR_MEM11: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 120 Write-only access to instruction memory location 12
    pub const INSTR_MEM12 = mmio(Address + 0x00000078, 32, packed struct {
        INSTR_MEM12: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 124 Write-only access to instruction memory location 13
    pub const INSTR_MEM13 = mmio(Address + 0x0000007c, 32, packed struct {
        INSTR_MEM13: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 128 Write-only access to instruction memory location 14
    pub const INSTR_MEM14 = mmio(Address + 0x00000080, 32, packed struct {
        INSTR_MEM14: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 132 Write-only access to instruction memory location 15
    pub const INSTR_MEM15 = mmio(Address + 0x00000084, 32, packed struct {
        INSTR_MEM15: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 136 Write-only access to instruction memory location 16
    pub const INSTR_MEM16 = mmio(Address + 0x00000088, 32, packed struct {
        INSTR_MEM16: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 140 Write-only access to instruction memory location 17
    pub const INSTR_MEM17 = mmio(Address + 0x0000008c, 32, packed struct {
        INSTR_MEM17: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 144 Write-only access to instruction memory location 18
    pub const INSTR_MEM18 = mmio(Address + 0x00000090, 32, packed struct {
        INSTR_MEM18: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 148 Write-only access to instruction memory location 19
    pub const INSTR_MEM19 = mmio(Address + 0x00000094, 32, packed struct {
        INSTR_MEM19: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 152 Write-only access to instruction memory location 20
    pub const INSTR_MEM20 = mmio(Address + 0x00000098, 32, packed struct {
        INSTR_MEM20: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 156 Write-only access to instruction memory location 21
    pub const INSTR_MEM21 = mmio(Address + 0x0000009c, 32, packed struct {
        INSTR_MEM21: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 160 Write-only access to instruction memory location 22
    pub const INSTR_MEM22 = mmio(Address + 0x000000a0, 32, packed struct {
        INSTR_MEM22: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 164 Write-only access to instruction memory location 23
    pub const INSTR_MEM23 = mmio(Address + 0x000000a4, 32, packed struct {
        INSTR_MEM23: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 168 Write-only access to instruction memory location 24
    pub const INSTR_MEM24 = mmio(Address + 0x000000a8, 32, packed struct {
        INSTR_MEM24: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 172 Write-only access to instruction memory location 25
    pub const INSTR_MEM25 = mmio(Address + 0x000000ac, 32, packed struct {
        INSTR_MEM25: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 176 Write-only access to instruction memory location 26
    pub const INSTR_MEM26 = mmio(Address + 0x000000b0, 32, packed struct {
        INSTR_MEM26: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 180 Write-only access to instruction memory location 27
    pub const INSTR_MEM27 = mmio(Address + 0x000000b4, 32, packed struct {
        INSTR_MEM27: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 184 Write-only access to instruction memory location 28
    pub const INSTR_MEM28 = mmio(Address + 0x000000b8, 32, packed struct {
        INSTR_MEM28: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 188 Write-only access to instruction memory location 29
    pub const INSTR_MEM29 = mmio(Address + 0x000000bc, 32, packed struct {
        INSTR_MEM29: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 192 Write-only access to instruction memory location 30
    pub const INSTR_MEM30 = mmio(Address + 0x000000c0, 32, packed struct {
        INSTR_MEM30: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 196 Write-only access to instruction memory location 31
    pub const INSTR_MEM31 = mmio(Address + 0x000000c4, 32, packed struct {
        INSTR_MEM31: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 200 Clock divider register for state machine 0\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM0_CLKDIV = mmio(Address + 0x000000c8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 204 Execution/behavioural settings for state machine 0
    pub const SM0_EXECCTRL = mmio(Address + 0x000000cc, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 208 Control behaviour of the input/output shift registers for state machine 0
    pub const SM0_SHIFTCTRL = mmio(Address + 0x000000d0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 212 Current instruction address of state machine 0
    pub const SM0_ADDR = mmio(Address + 0x000000d4, 32, packed struct {
        SM0_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 216 Instruction currently being executed by state machine 0\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM0_INSTR = mmio(Address + 0x000000d8, 32, packed struct {
        SM0_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 220 State machine pin control
    pub const SM0_PINCTRL = mmio(Address + 0x000000dc, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 224 Clock divider register for state machine 1\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM1_CLKDIV = mmio(Address + 0x000000e0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 228 Execution/behavioural settings for state machine 1
    pub const SM1_EXECCTRL = mmio(Address + 0x000000e4, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 232 Control behaviour of the input/output shift registers for state machine 1
    pub const SM1_SHIFTCTRL = mmio(Address + 0x000000e8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 236 Current instruction address of state machine 1
    pub const SM1_ADDR = mmio(Address + 0x000000ec, 32, packed struct {
        SM1_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 240 Instruction currently being executed by state machine 1\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM1_INSTR = mmio(Address + 0x000000f0, 32, packed struct {
        SM1_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 244 State machine pin control
    pub const SM1_PINCTRL = mmio(Address + 0x000000f4, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 248 Clock divider register for state machine 2\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM2_CLKDIV = mmio(Address + 0x000000f8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 252 Execution/behavioural settings for state machine 2
    pub const SM2_EXECCTRL = mmio(Address + 0x000000fc, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 256 Control behaviour of the input/output shift registers for state machine 2
    pub const SM2_SHIFTCTRL = mmio(Address + 0x00000100, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 260 Current instruction address of state machine 2
    pub const SM2_ADDR = mmio(Address + 0x00000104, 32, packed struct {
        SM2_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 264 Instruction currently being executed by state machine 2\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM2_INSTR = mmio(Address + 0x00000108, 32, packed struct {
        SM2_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 268 State machine pin control
    pub const SM2_PINCTRL = mmio(Address + 0x0000010c, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 272 Clock divider register for state machine 3\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM3_CLKDIV = mmio(Address + 0x00000110, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 276 Execution/behavioural settings for state machine 3
    pub const SM3_EXECCTRL = mmio(Address + 0x00000114, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 280 Control behaviour of the input/output shift registers for state machine 3
    pub const SM3_SHIFTCTRL = mmio(Address + 0x00000118, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 284 Current instruction address of state machine 3
    pub const SM3_ADDR = mmio(Address + 0x0000011c, 32, packed struct {
        SM3_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 288 Instruction currently being executed by state machine 3\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM3_INSTR = mmio(Address + 0x00000120, 32, packed struct {
        SM3_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 292 State machine pin control
    pub const SM3_PINCTRL = mmio(Address + 0x00000124, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 296 Raw Interrupts
    pub const INTR = mmio(Address + 0x00000128, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 300 Interrupt Enable for irq0
    pub const IRQ0_INTE = mmio(Address + 0x0000012c, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 304 Interrupt Force for irq0
    pub const IRQ0_INTF = mmio(Address + 0x00000130, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 308 Interrupt status after masking & forcing for irq0
    pub const IRQ0_INTS = mmio(Address + 0x00000134, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 312 Interrupt Enable for irq1
    pub const IRQ1_INTE = mmio(Address + 0x00000138, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 316 Interrupt Force for irq1
    pub const IRQ1_INTF = mmio(Address + 0x0000013c, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 320 Interrupt status after masking & forcing for irq1
    pub const IRQ1_INTS = mmio(Address + 0x00000140, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
};
pub const PIO1 = extern struct {
    pub const Address: u32 = 0x50300000;
    // byte offset: 0 PIO control register
    pub const CTRL = mmio(Address + 0x00000000, 32, packed struct {
        SM_ENABLE: u4, // bit offset: 0 desc: Enable state machine
        SM_RESTART: u4, // bit offset: 4 desc: Clear internal SM state which is otherwise difficult to access\n (e.g. shift counters). Self-clearing.
        CLKDIV_RESTART: u4, // bit offset: 8 desc: Force clock dividers to restart their count and clear fractional\n accumulators. Restart multiple dividers to synchronise them.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 4 FIFO status register
    pub const FSTAT = mmio(Address + 0x00000004, 32, packed struct {
        RXFULL: u4, // bit offset: 0 desc: State machine RX FIFO is full
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        RXEMPTY: u4, // bit offset: 8 desc: State machine RX FIFO is empty
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        TXFULL: u4, // bit offset: 16 desc: State machine TX FIFO is full
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        TXEMPTY: u4, // bit offset: 24 desc: State machine TX FIFO is empty
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
    });
    // byte offset: 8 FIFO debug register
    pub const FDEBUG = mmio(Address + 0x00000008, 32, packed struct {
        RXSTALL: u4, // bit offset: 0 desc: State machine has stalled on full RX FIFO. Write 1 to clear.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        RXUNDER: u4, // bit offset: 8 desc: RX FIFO underflow has occurred. Write 1 to clear.
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        TXOVER: u4, // bit offset: 16 desc: TX FIFO overflow has occurred. Write 1 to clear.
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        TXSTALL: u4, // bit offset: 24 desc: State machine has stalled on empty TX FIFO. Write 1 to clear.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
    });
    // byte offset: 12 FIFO levels
    pub const FLEVEL = mmio(Address + 0x0000000c, 32, packed struct {
        TX0: u4, // bit offset: 0 desc:
        RX0: u4, // bit offset: 4 desc:
        TX1: u4, // bit offset: 8 desc:
        RX1: u4, // bit offset: 12 desc:
        TX2: u4, // bit offset: 16 desc:
        RX2: u4, // bit offset: 20 desc:
        TX3: u4, // bit offset: 24 desc:
        RX3: u4, // bit offset: 28 desc:
    });
    // byte offset: 16 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF0 = mmio(Address + 0x00000010, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 20 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF1 = mmio(Address + 0x00000014, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 24 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF2 = mmio(Address + 0x00000018, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 28 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO.
    pub const TXF3 = mmio(Address + 0x0000001c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 32 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF0 = mmio(Address + 0x00000020, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 36 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF1 = mmio(Address + 0x00000024, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 40 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF2 = mmio(Address + 0x00000028, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 44 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO.
    pub const RXF3 = mmio(Address + 0x0000002c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 48 Interrupt request register. Write 1 to clear
    pub const IRQ = mmio(Address + 0x00000030, 32, packed struct {
        IRQ: u8, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 52 Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.\n Note this is different to the INTF register: writing here affects PIO internal\n state. INTF just asserts the processor-facing IRQ signal for testing ISRs,\n and is not visible to the state machines.
    pub const IRQ_FORCE = mmio(Address + 0x00000034, 32, packed struct {
        IRQ_FORCE: u8, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
    });
    // byte offset: 56 There is a 2-flipflop synchronizer on each GPIO input, which protects\n PIO logic from metastabilities. This increases input delay, and for fast\n synchronous IO (e.g. SPI) these synchronizers may need to be bypassed.\n Each bit in this register corresponds to one GPIO.\n 0 -> input is synchronized (default)\n 1 -> synchronizer is bypassed\n If in doubt, leave this register as all zeroes.
    pub const INPUT_SYNC_BYPASS = mmio(Address + 0x00000038, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 60 Read to sample the pad output values PIO is currently driving to the GPIOs.
    pub const DBG_PADOUT = mmio(Address + 0x0000003c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 64 Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs.
    pub const DBG_PADOE = mmio(Address + 0x00000040, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 68 The PIO hardware has some free parameters that may vary between chip products.\n These should be provided in the chip datasheet, but are also exposed here.
    pub const DBG_CFGINFO = mmio(Address + 0x00000044, 32, packed struct {
        FIFO_DEPTH: u6, // bit offset: 0 desc: The depth of the state machine TX/RX FIFOs, measured in words.\n Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double\n this depth.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        SM_COUNT: u4, // bit offset: 8 desc: The number of state machines this PIO instance is equipped with.
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IMEM_SIZE: u6, // bit offset: 16 desc: The size of the instruction memory, measured in units of one instruction
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
    });
    // byte offset: 72 Write-only access to instruction memory location 0
    pub const INSTR_MEM0 = mmio(Address + 0x00000048, 32, packed struct {
        INSTR_MEM0: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 76 Write-only access to instruction memory location 1
    pub const INSTR_MEM1 = mmio(Address + 0x0000004c, 32, packed struct {
        INSTR_MEM1: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 80 Write-only access to instruction memory location 2
    pub const INSTR_MEM2 = mmio(Address + 0x00000050, 32, packed struct {
        INSTR_MEM2: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 84 Write-only access to instruction memory location 3
    pub const INSTR_MEM3 = mmio(Address + 0x00000054, 32, packed struct {
        INSTR_MEM3: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 88 Write-only access to instruction memory location 4
    pub const INSTR_MEM4 = mmio(Address + 0x00000058, 32, packed struct {
        INSTR_MEM4: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 92 Write-only access to instruction memory location 5
    pub const INSTR_MEM5 = mmio(Address + 0x0000005c, 32, packed struct {
        INSTR_MEM5: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 96 Write-only access to instruction memory location 6
    pub const INSTR_MEM6 = mmio(Address + 0x00000060, 32, packed struct {
        INSTR_MEM6: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 100 Write-only access to instruction memory location 7
    pub const INSTR_MEM7 = mmio(Address + 0x00000064, 32, packed struct {
        INSTR_MEM7: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 104 Write-only access to instruction memory location 8
    pub const INSTR_MEM8 = mmio(Address + 0x00000068, 32, packed struct {
        INSTR_MEM8: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 108 Write-only access to instruction memory location 9
    pub const INSTR_MEM9 = mmio(Address + 0x0000006c, 32, packed struct {
        INSTR_MEM9: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 112 Write-only access to instruction memory location 10
    pub const INSTR_MEM10 = mmio(Address + 0x00000070, 32, packed struct {
        INSTR_MEM10: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 116 Write-only access to instruction memory location 11
    pub const INSTR_MEM11 = mmio(Address + 0x00000074, 32, packed struct {
        INSTR_MEM11: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 120 Write-only access to instruction memory location 12
    pub const INSTR_MEM12 = mmio(Address + 0x00000078, 32, packed struct {
        INSTR_MEM12: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 124 Write-only access to instruction memory location 13
    pub const INSTR_MEM13 = mmio(Address + 0x0000007c, 32, packed struct {
        INSTR_MEM13: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 128 Write-only access to instruction memory location 14
    pub const INSTR_MEM14 = mmio(Address + 0x00000080, 32, packed struct {
        INSTR_MEM14: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 132 Write-only access to instruction memory location 15
    pub const INSTR_MEM15 = mmio(Address + 0x00000084, 32, packed struct {
        INSTR_MEM15: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 136 Write-only access to instruction memory location 16
    pub const INSTR_MEM16 = mmio(Address + 0x00000088, 32, packed struct {
        INSTR_MEM16: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 140 Write-only access to instruction memory location 17
    pub const INSTR_MEM17 = mmio(Address + 0x0000008c, 32, packed struct {
        INSTR_MEM17: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 144 Write-only access to instruction memory location 18
    pub const INSTR_MEM18 = mmio(Address + 0x00000090, 32, packed struct {
        INSTR_MEM18: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 148 Write-only access to instruction memory location 19
    pub const INSTR_MEM19 = mmio(Address + 0x00000094, 32, packed struct {
        INSTR_MEM19: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 152 Write-only access to instruction memory location 20
    pub const INSTR_MEM20 = mmio(Address + 0x00000098, 32, packed struct {
        INSTR_MEM20: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 156 Write-only access to instruction memory location 21
    pub const INSTR_MEM21 = mmio(Address + 0x0000009c, 32, packed struct {
        INSTR_MEM21: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 160 Write-only access to instruction memory location 22
    pub const INSTR_MEM22 = mmio(Address + 0x000000a0, 32, packed struct {
        INSTR_MEM22: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 164 Write-only access to instruction memory location 23
    pub const INSTR_MEM23 = mmio(Address + 0x000000a4, 32, packed struct {
        INSTR_MEM23: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 168 Write-only access to instruction memory location 24
    pub const INSTR_MEM24 = mmio(Address + 0x000000a8, 32, packed struct {
        INSTR_MEM24: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 172 Write-only access to instruction memory location 25
    pub const INSTR_MEM25 = mmio(Address + 0x000000ac, 32, packed struct {
        INSTR_MEM25: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 176 Write-only access to instruction memory location 26
    pub const INSTR_MEM26 = mmio(Address + 0x000000b0, 32, packed struct {
        INSTR_MEM26: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 180 Write-only access to instruction memory location 27
    pub const INSTR_MEM27 = mmio(Address + 0x000000b4, 32, packed struct {
        INSTR_MEM27: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 184 Write-only access to instruction memory location 28
    pub const INSTR_MEM28 = mmio(Address + 0x000000b8, 32, packed struct {
        INSTR_MEM28: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 188 Write-only access to instruction memory location 29
    pub const INSTR_MEM29 = mmio(Address + 0x000000bc, 32, packed struct {
        INSTR_MEM29: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 192 Write-only access to instruction memory location 30
    pub const INSTR_MEM30 = mmio(Address + 0x000000c0, 32, packed struct {
        INSTR_MEM30: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 196 Write-only access to instruction memory location 31
    pub const INSTR_MEM31 = mmio(Address + 0x000000c4, 32, packed struct {
        INSTR_MEM31: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 200 Clock divider register for state machine 0\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM0_CLKDIV = mmio(Address + 0x000000c8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 204 Execution/behavioural settings for state machine 0
    pub const SM0_EXECCTRL = mmio(Address + 0x000000cc, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 208 Control behaviour of the input/output shift registers for state machine 0
    pub const SM0_SHIFTCTRL = mmio(Address + 0x000000d0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 212 Current instruction address of state machine 0
    pub const SM0_ADDR = mmio(Address + 0x000000d4, 32, packed struct {
        SM0_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 216 Instruction currently being executed by state machine 0\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM0_INSTR = mmio(Address + 0x000000d8, 32, packed struct {
        SM0_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 220 State machine pin control
    pub const SM0_PINCTRL = mmio(Address + 0x000000dc, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 224 Clock divider register for state machine 1\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM1_CLKDIV = mmio(Address + 0x000000e0, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 228 Execution/behavioural settings for state machine 1
    pub const SM1_EXECCTRL = mmio(Address + 0x000000e4, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 232 Control behaviour of the input/output shift registers for state machine 1
    pub const SM1_SHIFTCTRL = mmio(Address + 0x000000e8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 236 Current instruction address of state machine 1
    pub const SM1_ADDR = mmio(Address + 0x000000ec, 32, packed struct {
        SM1_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 240 Instruction currently being executed by state machine 1\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM1_INSTR = mmio(Address + 0x000000f0, 32, packed struct {
        SM1_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 244 State machine pin control
    pub const SM1_PINCTRL = mmio(Address + 0x000000f4, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 248 Clock divider register for state machine 2\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM2_CLKDIV = mmio(Address + 0x000000f8, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 252 Execution/behavioural settings for state machine 2
    pub const SM2_EXECCTRL = mmio(Address + 0x000000fc, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 256 Control behaviour of the input/output shift registers for state machine 2
    pub const SM2_SHIFTCTRL = mmio(Address + 0x00000100, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 260 Current instruction address of state machine 2
    pub const SM2_ADDR = mmio(Address + 0x00000104, 32, packed struct {
        SM2_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 264 Instruction currently being executed by state machine 2\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM2_INSTR = mmio(Address + 0x00000108, 32, packed struct {
        SM2_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 268 State machine pin control
    pub const SM2_PINCTRL = mmio(Address + 0x0000010c, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 272 Clock divider register for state machine 3\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
    pub const SM3_CLKDIV = mmio(Address + 0x00000110, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        FRAC: u8, // bit offset: 8 desc: Fractional part of clock divider
        INT: u16, // bit offset: 16 desc: Effective frequency is sysclk/int.\n Value of 0 is interpreted as max possible value
    });
    // byte offset: 276 Execution/behavioural settings for state machine 3
    pub const SM3_EXECCTRL = mmio(Address + 0x00000114, 32, packed struct {
        STATUS_N: u4, // bit offset: 0 desc: Comparison level for the MOV x, STATUS instruction
        STATUS_SEL: enum(u1) { // bit offset: 4 desc: Comparison used for the MOV x, STATUS instruction.
            @"TXLEVEL" = 0, // desc: All-ones if TX FIFO level < N, otherwise all-zeroes
            @"RXLEVEL" = 1, // desc: All-ones if RX FIFO level < N, otherwise all-zeroes
        },
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        WRAP_BOTTOM: u5, // bit offset: 7 desc: After reaching wrap_top, execution is wrapped to this address.
        WRAP_TOP: u5, // bit offset: 12 desc: After reaching this address, execution is wrapped to wrap_bottom.\n If the instruction is a jump, and the jump condition is true, the jump takes priority.
        OUT_STICKY: u1, // bit offset: 17 desc: Continuously assert the most recent OUT/SET to the pins
        INLINE_OUT_EN: u1, // bit offset: 18 desc: If 1, use a bit of OUT data as an auxiliary write enable\n When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n deassert the latest pin write. This can create useful masking/override behaviour\n due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
        OUT_EN_SEL: u5, // bit offset: 19 desc: Which data bit to use for inline OUT enable
        JMP_PIN: u5, // bit offset: 24 desc: The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
        SIDE_PINDIR: u1, // bit offset: 29 desc: Side-set data is asserted to pin OEs instead of pin values
        SIDE_EN: u1, // bit offset: 30 desc: If 1, the delay MSB is used as side-set enable, rather than a\n side-set data bit. This allows instructions to perform side-set optionally,\n rather than on every instruction.
        EXEC_STALLED: u1, // bit offset: 31 desc: An instruction written to SMx_INSTR is stalled, and latched by the\n state machine. Will clear once the instruction completes.
    });
    // byte offset: 280 Control behaviour of the input/output shift registers for state machine 3
    pub const SM3_SHIFTCTRL = mmio(Address + 0x00000118, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        AUTOPUSH: u1, // bit offset: 16 desc: Push automatically when the input shift register is filled
        AUTOPULL: u1, // bit offset: 17 desc: Pull automatically when the output shift register is emptied
        IN_SHIFTDIR: u1, // bit offset: 18 desc: 1 = shift input shift register to right (data enters from left). 0 = to left.
        OUT_SHIFTDIR: u1, // bit offset: 19 desc: 1 = shift out of output shift register to right. 0 = to left.
        PUSH_THRESH: u5, // bit offset: 20 desc: Number of bits shifted into RXSR before autopush or conditional push.\n Write 0 for value of 32.
        PULL_THRESH: u5, // bit offset: 25 desc: Number of bits shifted out of TXSR before autopull or conditional pull.\n Write 0 for value of 32.
        FJOIN_TX: u1, // bit offset: 30 desc: When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n RX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
        FJOIN_RX: u1, // bit offset: 31 desc: When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n TX FIFO is disabled as a result (always reads as both full and empty).\n FIFOs are flushed when this bit is changed.
    });
    // byte offset: 284 Current instruction address of state machine 3
    pub const SM3_ADDR = mmio(Address + 0x0000011c, 32, packed struct {
        SM3_ADDR: u5, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 288 Instruction currently being executed by state machine 3\n Write to execute an instruction immediately (including jumps) and then resume execution.
    pub const SM3_INSTR = mmio(Address + 0x00000120, 32, packed struct {
        SM3_INSTR: u16, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 292 State machine pin control
    pub const SM3_PINCTRL = mmio(Address + 0x00000124, 32, packed struct {
        OUT_BASE: u5, // bit offset: 0 desc: The virtual pin corresponding to OUT bit 0
        SET_BASE: u5, // bit offset: 5 desc: The virtual pin corresponding to SET bit 0
        SIDESET_BASE: u5, // bit offset: 10 desc: The virtual pin corresponding to delay field bit 0
        IN_BASE: u5, // bit offset: 15 desc: The virtual pin corresponding to IN bit 0
        OUT_COUNT: u6, // bit offset: 20 desc: The number of pins asserted by an OUT. Value of 0 -> 32 pins
        SET_COUNT: u3, // bit offset: 26 desc: The number of pins asserted by a SET. Max of 5
        SIDESET_COUNT: u3, // bit offset: 29 desc: The number of delay bits co-opted for side-set. Inclusive of the enable bit, if present.
    });
    // byte offset: 296 Raw Interrupts
    pub const INTR = mmio(Address + 0x00000128, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 300 Interrupt Enable for irq0
    pub const IRQ0_INTE = mmio(Address + 0x0000012c, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 304 Interrupt Force for irq0
    pub const IRQ0_INTF = mmio(Address + 0x00000130, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 308 Interrupt status after masking & forcing for irq0
    pub const IRQ0_INTS = mmio(Address + 0x00000134, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 312 Interrupt Enable for irq1
    pub const IRQ1_INTE = mmio(Address + 0x00000138, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 316 Interrupt Force for irq1
    pub const IRQ1_INTF = mmio(Address + 0x0000013c, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
    // byte offset: 320 Interrupt status after masking & forcing for irq1
    pub const IRQ1_INTS = mmio(Address + 0x00000140, 32, packed struct {
        SM0_RXNEMPTY: u1, // bit offset: 0 desc:
        SM1_RXNEMPTY: u1, // bit offset: 1 desc:
        SM2_RXNEMPTY: u1, // bit offset: 2 desc:
        SM3_RXNEMPTY: u1, // bit offset: 3 desc:
        SM0_TXNFULL: u1, // bit offset: 4 desc:
        SM1_TXNFULL: u1, // bit offset: 5 desc:
        SM2_TXNFULL: u1, // bit offset: 6 desc:
        SM3_TXNFULL: u1, // bit offset: 7 desc:
        SM0: u1, // bit offset: 8 desc:
        SM1: u1, // bit offset: 9 desc:
        SM2: u1, // bit offset: 10 desc:
        SM3: u1, // bit offset: 11 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
    });
};
pub const SIO = extern struct {
    pub const Address: u32 = 0xd0000000;
    // byte offset: 0 Processor core identifier\n Value is 0 when read from processor core 0, and 1 when read from processor core 1.
    pub const CPUID = mmio(Address + 0x00000000, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 4 Input value for GPIO pins
    pub const GPIO_IN = mmio(Address + 0x00000004, 32, packed struct {
        GPIO_IN: u30, // bit offset: 0 desc: Input value for GPIO0...29
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Input value for QSPI pins
    pub const GPIO_HI_IN = mmio(Address + 0x00000008, 32, packed struct {
        GPIO_HI_IN: u6, // bit offset: 0 desc: Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2, SD3
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 16 GPIO output value
    pub const GPIO_OUT = mmio(Address + 0x00000010, 32, packed struct {
        GPIO_OUT: u30, // bit offset: 0 desc: Set output level (1/0 -> high/low) for GPIO0...29.\n Reading back gives the last value written, NOT the input value from the pins.\n If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 GPIO output value set
    pub const GPIO_OUT_SET = mmio(Address + 0x00000014, 32, packed struct {
        GPIO_OUT_SET: u30, // bit offset: 0 desc: Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 GPIO output value clear
    pub const GPIO_OUT_CLR = mmio(Address + 0x00000018, 32, packed struct {
        GPIO_OUT_CLR: u30, // bit offset: 0 desc: Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 GPIO output value XOR
    pub const GPIO_OUT_XOR = mmio(Address + 0x0000001c, 32, packed struct {
        GPIO_OUT_XOR: u30, // bit offset: 0 desc: Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 GPIO output enable
    pub const GPIO_OE = mmio(Address + 0x00000020, 32, packed struct {
        GPIO_OE: u30, // bit offset: 0 desc: Set output enable (1/0 -> output/input) for GPIO0...29.\n Reading back gives the last value written.\n If core 0 and core 1 both write to GPIO_OE simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 GPIO output enable set
    pub const GPIO_OE_SET = mmio(Address + 0x00000024, 32, packed struct {
        GPIO_OE_SET: u30, // bit offset: 0 desc: Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 GPIO output enable clear
    pub const GPIO_OE_CLR = mmio(Address + 0x00000028, 32, packed struct {
        GPIO_OE_CLR: u30, // bit offset: 0 desc: Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 GPIO output enable XOR
    pub const GPIO_OE_XOR = mmio(Address + 0x0000002c, 32, packed struct {
        GPIO_OE_XOR: u30, // bit offset: 0 desc: Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 QSPI output value
    pub const GPIO_HI_OUT = mmio(Address + 0x00000030, 32, packed struct {
        GPIO_HI_OUT: u6, // bit offset: 0 desc: Set output level (1/0 -> high/low) for QSPI IO0...5.\n Reading back gives the last value written, NOT the input value from the pins.\n If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 52 QSPI output value set
    pub const GPIO_HI_OUT_SET = mmio(Address + 0x00000034, 32, packed struct {
        GPIO_HI_OUT_SET: u6, // bit offset: 0 desc: Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 56 QSPI output value clear
    pub const GPIO_HI_OUT_CLR = mmio(Address + 0x00000038, 32, packed struct {
        GPIO_HI_OUT_CLR: u6, // bit offset: 0 desc: Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 60 QSPI output value XOR
    pub const GPIO_HI_OUT_XOR = mmio(Address + 0x0000003c, 32, packed struct {
        GPIO_HI_OUT_XOR: u6, // bit offset: 0 desc: Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 64 QSPI output enable
    pub const GPIO_HI_OE = mmio(Address + 0x00000040, 32, packed struct {
        GPIO_HI_OE: u6, // bit offset: 0 desc: Set output enable (1/0 -> output/input) for QSPI IO0...5.\n Reading back gives the last value written.\n If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias),\n the result is as though the write from core 0 took place first,\n and the write from core 1 was then applied to that intermediate result.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 68 QSPI output enable set
    pub const GPIO_HI_OE_SET = mmio(Address + 0x00000044, 32, packed struct {
        GPIO_HI_OE_SET: u6, // bit offset: 0 desc: Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 72 QSPI output enable clear
    pub const GPIO_HI_OE_CLR = mmio(Address + 0x00000048, 32, packed struct {
        GPIO_HI_OE_CLR: u6, // bit offset: 0 desc: Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 76 QSPI output enable XOR
    pub const GPIO_HI_OE_XOR = mmio(Address + 0x0000004c, 32, packed struct {
        GPIO_HI_OE_XOR: u6, // bit offset: 0 desc: Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
    });
    // byte offset: 80 Status register for inter-core FIFOs (mailboxes).\n There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep.\n Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX).\n Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX).\n The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
    pub const FIFO_ST = mmio(Address + 0x00000050, 32, packed struct {
        VLD: u1, // bit offset: 0 desc: Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)
        RDY: u1, // bit offset: 1 desc: Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data)
        WOF: u1, // bit offset: 2 desc: Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.
        ROE: u1, // bit offset: 3 desc: Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 84 Write access to this core's TX FIFO
    pub const FIFO_WR = mmio(Address + 0x00000054, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 88 Read access to this core's RX FIFO
    pub const FIFO_RD = mmio(Address + 0x00000058, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 92 Spinlock state\n A bitmap containing the state of all 32 spinlocks (1=locked).\n Mainly intended for debugging.
    pub const SPINLOCK_ST = mmio(Address + 0x0000005c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 96 Divider unsigned dividend\n Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`.\n Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER.\n UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an\n unsigned calculation, and the S alias starts a signed calculation.
    pub const DIV_UDIVIDEND = mmio(Address + 0x00000060, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 100 Divider unsigned divisor\n Write to the DIVISOR operand of the divider, i.e. the q in `p / q`.\n Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER.\n UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an\n unsigned calculation, and the S alias starts a signed calculation.
    pub const DIV_UDIVISOR = mmio(Address + 0x00000064, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 104 Divider signed dividend\n The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.
    pub const DIV_SDIVIDEND = mmio(Address + 0x00000068, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 108 Divider signed divisor\n The same as UDIVISOR, but starts a signed calculation, rather than unsigned.
    pub const DIV_SDIVISOR = mmio(Address + 0x0000006c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 112 Divider result quotient\n The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low.\n For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ.\n This register can be written to directly, for context save/restore purposes. This halts any\n in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.\n Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order\n REMAINDER, QUOTIENT if CSR_DIRTY is used.
    pub const DIV_QUOTIENT = mmio(Address + 0x00000070, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 116 Divider result remainder\n The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low.\n For signed calculations, REMAINDER is negative only when DIVIDEND is negative.\n This register can be written to directly, for context save/restore purposes. This halts any\n in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.
    pub const DIV_REMAINDER = mmio(Address + 0x00000074, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 120 Control and status register for divider.
    pub const DIV_CSR = mmio(Address + 0x00000078, 32, packed struct {
        READY: u1, // bit offset: 0 desc: Reads as 0 when a calculation is in progress, 1 otherwise.\n Writing an operand (xDIVIDEND, xDIVISOR) will immediately start a new calculation, no\n matter if one is already in progress.\n Writing to a result register will immediately terminate any in-progress calculation\n and set the READY and DIRTY flags.
        DIRTY: u1, // bit offset: 1 desc: Changes to 1 when any register is written, and back to 0 when QUOTIENT is read.\n Software can use this flag to make save/restore more efficient (skip if not DIRTY).\n If the flag is used in this way, it's recommended to either read QUOTIENT only,\n or REMAINDER and then QUOTIENT, to prevent data loss on context switch.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
        padding29: u1 = 0,
    });
    // byte offset: 128 Read/write access to accumulator 0
    pub const INTERP0_ACCUM0 = mmio(Address + 0x00000080, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 132 Read/write access to accumulator 1
    pub const INTERP0_ACCUM1 = mmio(Address + 0x00000084, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 136 Read/write access to BASE0 register.
    pub const INTERP0_BASE0 = mmio(Address + 0x00000088, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 140 Read/write access to BASE1 register.
    pub const INTERP0_BASE1 = mmio(Address + 0x0000008c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 144 Read/write access to BASE2 register.
    pub const INTERP0_BASE2 = mmio(Address + 0x00000090, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 148 Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_LANE0 = mmio(Address + 0x00000094, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 152 Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_LANE1 = mmio(Address + 0x00000098, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 156 Read FULL result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP0_POP_FULL = mmio(Address + 0x0000009c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 160 Read LANE0 result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_LANE0 = mmio(Address + 0x000000a0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 164 Read LANE1 result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_LANE1 = mmio(Address + 0x000000a4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 168 Read FULL result, without altering any internal state (PEEK).
    pub const INTERP0_PEEK_FULL = mmio(Address + 0x000000a8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 172 Control register for lane 0
    pub const INTERP0_CTRL_LANE0 = mmio(Address + 0x000000ac, 32, packed struct {
        SHIFT: u5, // bit offset: 0 desc: Logical right-shift applied to accumulator before masking
        MASK_LSB: u5, // bit offset: 5 desc: The least-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5, // bit offset: 10 desc: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
        SIGNED: u1, // bit offset: 15 desc: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
        CROSS_INPUT: u1, // bit offset: 16 desc: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
        CROSS_RESULT: u1, // bit offset: 17 desc: If 1, feed the opposite lane's result into this lane's accumulator on POP.
        ADD_RAW: u1, // bit offset: 18 desc: If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
        FORCE_MSB: u2, // bit offset: 19 desc: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
        BLEND: u1, // bit offset: 21 desc: Only present on INTERP0 on each core. If BLEND mode is enabled:\n - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled\n by the 8 LSBs of lane 1 shift and mask value (a fractional number between\n 0 and 255/256ths)\n - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value)\n - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask)\n LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.
        reserved0: u1 = 0,
        OVERF0: u1, // bit offset: 23 desc: Indicates if any masked-off MSBs in ACCUM0 are set.
        OVERF1: u1, // bit offset: 24 desc: Indicates if any masked-off MSBs in ACCUM1 are set.
        OVERF: u1, // bit offset: 25 desc: Set if either OVERF0 or OVERF1 is set.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
    });
    // byte offset: 176 Control register for lane 1
    pub const INTERP0_CTRL_LANE1 = mmio(Address + 0x000000b0, 32, packed struct {
        SHIFT: u5, // bit offset: 0 desc: Logical right-shift applied to accumulator before masking
        MASK_LSB: u5, // bit offset: 5 desc: The least-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5, // bit offset: 10 desc: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
        SIGNED: u1, // bit offset: 15 desc: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.
        CROSS_INPUT: u1, // bit offset: 16 desc: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
        CROSS_RESULT: u1, // bit offset: 17 desc: If 1, feed the opposite lane's result into this lane's accumulator on POP.
        ADD_RAW: u1, // bit offset: 18 desc: If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
        FORCE_MSB: u2, // bit offset: 19 desc: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 180 Values written here are atomically added to ACCUM0\n Reading yields lane 0's raw shift and mask value (BASE0 not added).
    pub const INTERP0_ACCUM0_ADD = mmio(Address + 0x000000b4, 32, packed struct {
        INTERP0_ACCUM0_ADD: u24, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 184 Values written here are atomically added to ACCUM1\n Reading yields lane 1's raw shift and mask value (BASE1 not added).
    pub const INTERP0_ACCUM1_ADD = mmio(Address + 0x000000b8, 32, packed struct {
        INTERP0_ACCUM1_ADD: u24, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 188 On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
    pub const INTERP0_BASE_1AND0 = mmio(Address + 0x000000bc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 192 Read/write access to accumulator 0
    pub const INTERP1_ACCUM0 = mmio(Address + 0x000000c0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 196 Read/write access to accumulator 1
    pub const INTERP1_ACCUM1 = mmio(Address + 0x000000c4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 200 Read/write access to BASE0 register.
    pub const INTERP1_BASE0 = mmio(Address + 0x000000c8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 204 Read/write access to BASE1 register.
    pub const INTERP1_BASE1 = mmio(Address + 0x000000cc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 208 Read/write access to BASE2 register.
    pub const INTERP1_BASE2 = mmio(Address + 0x000000d0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 212 Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_LANE0 = mmio(Address + 0x000000d4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 216 Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_LANE1 = mmio(Address + 0x000000d8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 220 Read FULL result, and simultaneously write lane results to both accumulators (POP).
    pub const INTERP1_POP_FULL = mmio(Address + 0x000000dc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 224 Read LANE0 result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_LANE0 = mmio(Address + 0x000000e0, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 228 Read LANE1 result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_LANE1 = mmio(Address + 0x000000e4, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 232 Read FULL result, without altering any internal state (PEEK).
    pub const INTERP1_PEEK_FULL = mmio(Address + 0x000000e8, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 236 Control register for lane 0
    pub const INTERP1_CTRL_LANE0 = mmio(Address + 0x000000ec, 32, packed struct {
        SHIFT: u5, // bit offset: 0 desc: Logical right-shift applied to accumulator before masking
        MASK_LSB: u5, // bit offset: 5 desc: The least-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5, // bit offset: 10 desc: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
        SIGNED: u1, // bit offset: 15 desc: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
        CROSS_INPUT: u1, // bit offset: 16 desc: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
        CROSS_RESULT: u1, // bit offset: 17 desc: If 1, feed the opposite lane's result into this lane's accumulator on POP.
        ADD_RAW: u1, // bit offset: 18 desc: If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
        FORCE_MSB: u2, // bit offset: 19 desc: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
        reserved0: u1 = 0,
        CLAMP: u1, // bit offset: 22 desc: Only present on INTERP1 on each core. If CLAMP mode is enabled:\n - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of\n BASE0 and an upper bound of BASE1.\n - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED
        OVERF0: u1, // bit offset: 23 desc: Indicates if any masked-off MSBs in ACCUM0 are set.
        OVERF1: u1, // bit offset: 24 desc: Indicates if any masked-off MSBs in ACCUM1 are set.
        OVERF: u1, // bit offset: 25 desc: Set if either OVERF0 or OVERF1 is set.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
    });
    // byte offset: 240 Control register for lane 1
    pub const INTERP1_CTRL_LANE1 = mmio(Address + 0x000000f0, 32, packed struct {
        SHIFT: u5, // bit offset: 0 desc: Logical right-shift applied to accumulator before masking
        MASK_LSB: u5, // bit offset: 5 desc: The least-significant bit allowed to pass by the mask (inclusive)
        MASK_MSB: u5, // bit offset: 10 desc: The most-significant bit allowed to pass by the mask (inclusive)\n Setting MSB < LSB may cause chip to turn inside-out
        SIGNED: u1, // bit offset: 15 desc: If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits\n before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.
        CROSS_INPUT: u1, // bit offset: 16 desc: If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware.\n Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
        CROSS_RESULT: u1, // bit offset: 17 desc: If 1, feed the opposite lane's result into this lane's accumulator on POP.
        ADD_RAW: u1, // bit offset: 18 desc: If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
        FORCE_MSB: u2, // bit offset: 19 desc: ORed into bits 29:28 of the lane result presented to the processor on the bus.\n No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence\n of pointers into flash or SRAM.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
    });
    // byte offset: 244 Values written here are atomically added to ACCUM0\n Reading yields lane 0's raw shift and mask value (BASE0 not added).
    pub const INTERP1_ACCUM0_ADD = mmio(Address + 0x000000f4, 32, packed struct {
        INTERP1_ACCUM0_ADD: u24, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 248 Values written here are atomically added to ACCUM1\n Reading yields lane 1's raw shift and mask value (BASE1 not added).
    pub const INTERP1_ACCUM1_ADD = mmio(Address + 0x000000f8, 32, packed struct {
        INTERP1_ACCUM1_ADD: u24, // bit offset: 0 desc:
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 252 On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
    pub const INTERP1_BASE_1AND0 = mmio(Address + 0x000000fc, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 256 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK0 = mmio(Address + 0x00000100, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 260 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK1 = mmio(Address + 0x00000104, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 264 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK2 = mmio(Address + 0x00000108, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 268 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK3 = mmio(Address + 0x0000010c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 272 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK4 = mmio(Address + 0x00000110, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 276 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK5 = mmio(Address + 0x00000114, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 280 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK6 = mmio(Address + 0x00000118, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 284 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK7 = mmio(Address + 0x0000011c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 288 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK8 = mmio(Address + 0x00000120, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 292 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK9 = mmio(Address + 0x00000124, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 296 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK10 = mmio(Address + 0x00000128, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 300 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK11 = mmio(Address + 0x0000012c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 304 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK12 = mmio(Address + 0x00000130, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 308 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK13 = mmio(Address + 0x00000134, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 312 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK14 = mmio(Address + 0x00000138, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 316 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK15 = mmio(Address + 0x0000013c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 320 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK16 = mmio(Address + 0x00000140, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 324 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK17 = mmio(Address + 0x00000144, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 328 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK18 = mmio(Address + 0x00000148, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 332 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK19 = mmio(Address + 0x0000014c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 336 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK20 = mmio(Address + 0x00000150, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 340 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK21 = mmio(Address + 0x00000154, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 344 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK22 = mmio(Address + 0x00000158, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 348 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK23 = mmio(Address + 0x0000015c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 352 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK24 = mmio(Address + 0x00000160, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 356 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK25 = mmio(Address + 0x00000164, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 360 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK26 = mmio(Address + 0x00000168, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 364 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK27 = mmio(Address + 0x0000016c, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 368 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK28 = mmio(Address + 0x00000170, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 372 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK29 = mmio(Address + 0x00000174, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 376 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK30 = mmio(Address + 0x00000178, 32, packed struct {
        raw: u32, // placeholder field
    });
    // byte offset: 380 Reading from a spinlock address will:\n - Return 0 if lock is already locked\n - Otherwise return nonzero, and simultaneously claim the lock\n\n Writing (any value) releases the lock.\n If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins.\n The value returned on success is 0x1 << lock number.
    pub const SPINLOCK31 = mmio(Address + 0x0000017c, 32, packed struct {
        raw: u32, // placeholder field
    });
};
pub const PPB = extern struct {
    pub const Address: u32 = 0xe0000000;
    // byte offset: 57360 Use the SysTick Control and Status Register to enable the SysTick features.
    pub const SYST_CSR = mmio(Address + 0x0000e010, 32, packed struct {
        ENABLE: u1, // bit offset: 0 desc: Enable SysTick counter:\n 0 = Counter disabled.\n 1 = Counter enabled.
        TICKINT: u1, // bit offset: 1 desc: Enables SysTick exception request:\n 0 = Counting down to zero does not assert the SysTick exception request.\n 1 = Counting down to zero to asserts the SysTick exception request.
        CLKSOURCE: u1, // bit offset: 2 desc: SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.\n Selects the SysTick timer clock source:\n 0 = External reference clock.\n 1 = Processor clock.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        COUNTFLAG: u1, // bit offset: 16 desc: Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
    });
    // byte offset: 57364 Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.\n To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
    pub const SYST_RVR = mmio(Address + 0x0000e014, 32, packed struct {
        RELOAD: u24, // bit offset: 0 desc: Value to load into the SysTick Current Value Register when the counter reaches 0.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 57368 Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
    pub const SYST_CVR = mmio(Address + 0x0000e018, 32, packed struct {
        CURRENT: u24, // bit offset: 0 desc: Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 57372 Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
    pub const SYST_CALIB = mmio(Address + 0x0000e01c, 32, packed struct {
        TENMS: u24, // bit offset: 0 desc: An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        SKEW: u1, // bit offset: 30 desc: If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).
        NOREF: u1, // bit offset: 31 desc: If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.
    });
    // byte offset: 57600 Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled.\n If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
    pub const NVIC_ISER = mmio(Address + 0x0000e100, 32, packed struct {
        SETENA: u32, // bit offset: 0 desc: Interrupt set-enable bits.\n Write:\n 0 = No effect.\n 1 = Enable interrupt.\n Read:\n 0 = Interrupt disabled.\n 1 = Interrupt enabled.
    });
    // byte offset: 57728 Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
    pub const NVIC_ICER = mmio(Address + 0x0000e180, 32, packed struct {
        CLRENA: u32, // bit offset: 0 desc: Interrupt clear-enable bits.\n Write:\n 0 = No effect.\n 1 = Disable interrupt.\n Read:\n 0 = Interrupt disabled.\n 1 = Interrupt enabled.
    });
    // byte offset: 57856 The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
    pub const NVIC_ISPR = mmio(Address + 0x0000e200, 32, packed struct {
        SETPEND: u32, // bit offset: 0 desc: Interrupt set-pending bits.\n Write:\n 0 = No effect.\n 1 = Changes interrupt state to pending.\n Read:\n 0 = Interrupt is not pending.\n 1 = Interrupt is pending.\n Note: Writing 1 to the NVIC_ISPR bit corresponding to:\n An interrupt that is pending has no effect.\n A disabled interrupt sets the state of that interrupt to pending.
    });
    // byte offset: 57984 Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
    pub const NVIC_ICPR = mmio(Address + 0x0000e280, 32, packed struct {
        CLRPEND: u32, // bit offset: 0 desc: Interrupt clear-pending bits.\n Write:\n 0 = No effect.\n 1 = Removes pending state and interrupt.\n Read:\n 0 = Interrupt is not pending.\n 1 = Interrupt is pending.
    });
    // byte offset: 58368 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt.\n These registers are only word-accessible
    pub const NVIC_IPR0 = mmio(Address + 0x0000e400, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_0: u2, // bit offset: 6 desc: Priority of interrupt 0
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_1: u2, // bit offset: 14 desc: Priority of interrupt 1
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_2: u2, // bit offset: 22 desc: Priority of interrupt 2
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_3: u2, // bit offset: 30 desc: Priority of interrupt 3
    });
    // byte offset: 58372 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR1 = mmio(Address + 0x0000e404, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_4: u2, // bit offset: 6 desc: Priority of interrupt 4
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_5: u2, // bit offset: 14 desc: Priority of interrupt 5
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_6: u2, // bit offset: 22 desc: Priority of interrupt 6
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_7: u2, // bit offset: 30 desc: Priority of interrupt 7
    });
    // byte offset: 58376 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR2 = mmio(Address + 0x0000e408, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_8: u2, // bit offset: 6 desc: Priority of interrupt 8
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_9: u2, // bit offset: 14 desc: Priority of interrupt 9
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_10: u2, // bit offset: 22 desc: Priority of interrupt 10
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_11: u2, // bit offset: 30 desc: Priority of interrupt 11
    });
    // byte offset: 58380 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR3 = mmio(Address + 0x0000e40c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_12: u2, // bit offset: 6 desc: Priority of interrupt 12
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_13: u2, // bit offset: 14 desc: Priority of interrupt 13
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_14: u2, // bit offset: 22 desc: Priority of interrupt 14
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_15: u2, // bit offset: 30 desc: Priority of interrupt 15
    });
    // byte offset: 58384 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR4 = mmio(Address + 0x0000e410, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_16: u2, // bit offset: 6 desc: Priority of interrupt 16
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_17: u2, // bit offset: 14 desc: Priority of interrupt 17
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_18: u2, // bit offset: 22 desc: Priority of interrupt 18
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_19: u2, // bit offset: 30 desc: Priority of interrupt 19
    });
    // byte offset: 58388 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR5 = mmio(Address + 0x0000e414, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_20: u2, // bit offset: 6 desc: Priority of interrupt 20
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_21: u2, // bit offset: 14 desc: Priority of interrupt 21
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_22: u2, // bit offset: 22 desc: Priority of interrupt 22
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_23: u2, // bit offset: 30 desc: Priority of interrupt 23
    });
    // byte offset: 58392 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR6 = mmio(Address + 0x0000e418, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_24: u2, // bit offset: 6 desc: Priority of interrupt 24
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_25: u2, // bit offset: 14 desc: Priority of interrupt 25
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_26: u2, // bit offset: 22 desc: Priority of interrupt 26
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_27: u2, // bit offset: 30 desc: Priority of interrupt 27
    });
    // byte offset: 58396 Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
    pub const NVIC_IPR7 = mmio(Address + 0x0000e41c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        IP_28: u2, // bit offset: 6 desc: Priority of interrupt 28
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        IP_29: u2, // bit offset: 14 desc: Priority of interrupt 29
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        IP_30: u2, // bit offset: 22 desc: Priority of interrupt 30
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        IP_31: u2, // bit offset: 30 desc: Priority of interrupt 31
    });
    // byte offset: 60672 Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
    pub const CPUID = mmio(Address + 0x0000ed00, 32, packed struct {
        REVISION: u4, // bit offset: 0 desc: Minor revision number m in the rnpm revision status:\n 0x1 = Patch 1.
        PARTNO: u12, // bit offset: 4 desc: Number of processor within family: 0xC60 = Cortex-M0+
        ARCHITECTURE: u4, // bit offset: 16 desc: Constant that defines the architecture of the processor:\n 0xC = ARMv6-M architecture.
        VARIANT: u4, // bit offset: 20 desc: Major revision number n in the rnpm revision status:\n 0x0 = Revision 0.
        IMPLEMENTER: u8, // bit offset: 24 desc: Implementor code: 0x41 = ARM
    });
    // byte offset: 60676 Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
    pub const ICSR = mmio(Address + 0x0000ed04, 32, packed struct {
        VECTACTIVE: u9, // bit offset: 0 desc: Active exception number field. Reset clears the VECTACTIVE field.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        VECTPENDING: u9, // bit offset: 12 desc: Indicates the exception number for the highest priority pending exception: 0 = no pending exceptions. Non zero = The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier.
        reserved3: u1 = 0,
        ISRPENDING: u1, // bit offset: 22 desc: External interrupt pending flag
        ISRPREEMPT: u1, // bit offset: 23 desc: The system can only access this bit when the core is halted. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced.
        reserved4: u1 = 0,
        PENDSTCLR: u1, // bit offset: 25 desc: SysTick exception clear-pending bit.\n Write:\n 0 = No effect.\n 1 = Removes the pending state from the SysTick exception.\n This bit is WO. On a register read its value is Unknown.
        PENDSTSET: u1, // bit offset: 26 desc: SysTick exception set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes SysTick exception state to pending.\n Read:\n 0 = SysTick exception is not pending.\n 1 = SysTick exception is pending.
        PENDSVCLR: u1, // bit offset: 27 desc: PendSV clear-pending bit.\n Write:\n 0 = No effect.\n 1 = Removes the pending state from the PendSV exception.
        PENDSVSET: u1, // bit offset: 28 desc: PendSV set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes PendSV exception state to pending.\n Read:\n 0 = PendSV exception is not pending.\n 1 = PendSV exception is pending.\n Writing 1 to this bit is the only way to set the PendSV exception state to pending.
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        NMIPENDSET: u1, // bit offset: 31 desc: Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered.\n NMI set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes NMI exception state to pending.\n Read:\n 0 = NMI exception is not pending.\n 1 = NMI exception is pending.\n Because NMI is the highest-priority exception, normally the processor enters the NMI\n exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears\n this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the\n NMI signal is reasserted while the processor is executing that handler.
    });
    // byte offset: 60680 The VTOR holds the vector table offset address.
    pub const VTOR = mmio(Address + 0x0000ed08, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        TBLOFF: u24, // bit offset: 8 desc: Bits [31:8] of the indicate the vector table offset address.
    });
    // byte offset: 60684 Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
    pub const AIRCR = mmio(Address + 0x0000ed0c, 32, packed struct {
        reserved0: u1 = 0,
        VECTCLRACTIVE: u1, // bit offset: 1 desc: Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted. When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.
        SYSRESETREQ: u1, // bit offset: 2 desc: Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        ENDIANESS: u1, // bit offset: 15 desc: Data endianness implemented:\n 0 = Little-endian.
        VECTKEY: u16, // bit offset: 16 desc: Register key:\n Reads as Unknown\n On writes, write 0x05FA to VECTKEY, otherwise the write is ignored.
    });
    // byte offset: 60688 System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
    pub const SCR = mmio(Address + 0x0000ed10, 32, packed struct {
        reserved0: u1 = 0,
        SLEEPONEXIT: u1, // bit offset: 1 desc: Indicates sleep-on-exit when returning from Handler mode to Thread mode:\n 0 = Do not sleep when returning to Thread mode.\n 1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode.\n Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.
        SLEEPDEEP: u1, // bit offset: 2 desc: Controls whether the processor uses sleep or deep sleep as its low power mode:\n 0 = Sleep.\n 1 = Deep sleep.
        reserved1: u1 = 0,
        SEVONPEND: u1, // bit offset: 4 desc: Send Event on Pending bit:\n 0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded.\n 1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor.\n When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the\n processor is not waiting for an event, the event is registered and affects the next WFE.\n The processor also wakes up on execution of an SEV instruction or an external event.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
    });
    // byte offset: 60692 The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
    pub const CCR = mmio(Address + 0x0000ed14, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        UNALIGN_TRP: u1, // bit offset: 3 desc: Always reads as one, indicates that all unaligned accesses generate a HardFault.
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        STKALIGN: u1, // bit offset: 9 desc: Always reads as one, indicates 8-byte stack alignment on exception entry. On exception entry, the processor uses bit[9] of the stacked PSR to indicate the stack alignment. On return from the exception it uses this stacked bit to restore the correct stack alignment.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
    });
    // byte offset: 60700 System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
    pub const SHPR2 = mmio(Address + 0x0000ed1c, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        reserved24: u1 = 0,
        reserved25: u1 = 0,
        reserved26: u1 = 0,
        reserved27: u1 = 0,
        reserved28: u1 = 0,
        reserved29: u1 = 0,
        PRI_11: u2, // bit offset: 30 desc: Priority of system handler 11, SVCall
    });
    // byte offset: 60704 System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
    pub const SHPR3 = mmio(Address + 0x0000ed20, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        reserved15: u1 = 0,
        reserved16: u1 = 0,
        reserved17: u1 = 0,
        reserved18: u1 = 0,
        reserved19: u1 = 0,
        reserved20: u1 = 0,
        reserved21: u1 = 0,
        PRI_14: u2, // bit offset: 22 desc: Priority of system handler 14, PendSV
        reserved22: u1 = 0,
        reserved23: u1 = 0,
        reserved24: u1 = 0,
        reserved25: u1 = 0,
        reserved26: u1 = 0,
        reserved27: u1 = 0,
        PRI_15: u2, // bit offset: 30 desc: Priority of system handler 15, SysTick
    });
    // byte offset: 60708 Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
    pub const SHCSR = mmio(Address + 0x0000ed24, 32, packed struct {
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        reserved7: u1 = 0,
        reserved8: u1 = 0,
        reserved9: u1 = 0,
        reserved10: u1 = 0,
        reserved11: u1 = 0,
        reserved12: u1 = 0,
        reserved13: u1 = 0,
        reserved14: u1 = 0,
        SVCALLPENDED: u1, // bit offset: 15 desc: Reads as 1 if SVCall is Pending. Write 1 to set pending SVCall, write 0 to clear pending SVCall.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
    });
    // byte offset: 60816 Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
    pub const MPU_TYPE = mmio(Address + 0x0000ed90, 32, packed struct {
        SEPARATE: u1, // bit offset: 0 desc: Indicates support for separate instruction and data address maps. Reads as 0 as ARMv6-M only supports a unified MPU.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        reserved3: u1 = 0,
        reserved4: u1 = 0,
        reserved5: u1 = 0,
        reserved6: u1 = 0,
        DREGION: u8, // bit offset: 8 desc: Number of regions supported by the MPU.
        IREGION: u8, // bit offset: 16 desc: Instruction region. Reads as zero as ARMv6-M only supports a unified MPU.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
    });
    // byte offset: 60820 Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
    pub const MPU_CTRL = mmio(Address + 0x0000ed94, 32, packed struct {
        ENABLE: u1, // bit offset: 0 desc: Enables the MPU. If the MPU is disabled, privileged and unprivileged accesses use the default memory map.\n 0 = MPU disabled.\n 1 = MPU enabled.
        HFNMIENA: u1, // bit offset: 1 desc: Controls the use of the MPU for HardFaults and NMIs. Setting this bit when ENABLE is clear results in UNPREDICTABLE behaviour.\n When the MPU is enabled:\n 0 = MPU is disabled during HardFault and NMI handlers, regardless of the value of the ENABLE bit.\n 1 = the MPU is enabled during HardFault and NMI handlers.
        PRIVDEFENA: u1, // bit offset: 2 desc: Controls whether the default memory map is enabled as a background region for privileged accesses. This bit is ignored when ENABLE is clear.\n 0 = If the MPU is enabled, disables use of the default memory map. Any memory access to a location not\n covered by any enabled region causes a fault.\n 1 = If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses.\n When enabled, the background region acts as if it is region number -1. Any region that is defined and enabled has priority over this default map.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
        padding28: u1 = 0,
    });
    // byte offset: 60824 Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
    pub const MPU_RNR = mmio(Address + 0x0000ed98, 32, packed struct {
        REGION: u4, // bit offset: 0 desc: Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers.\n The MPU supports 8 memory regions, so the permitted values of this field are 0-7.
        padding0: u1 = 0,
        padding1: u1 = 0,
        padding2: u1 = 0,
        padding3: u1 = 0,
        padding4: u1 = 0,
        padding5: u1 = 0,
        padding6: u1 = 0,
        padding7: u1 = 0,
        padding8: u1 = 0,
        padding9: u1 = 0,
        padding10: u1 = 0,
        padding11: u1 = 0,
        padding12: u1 = 0,
        padding13: u1 = 0,
        padding14: u1 = 0,
        padding15: u1 = 0,
        padding16: u1 = 0,
        padding17: u1 = 0,
        padding18: u1 = 0,
        padding19: u1 = 0,
        padding20: u1 = 0,
        padding21: u1 = 0,
        padding22: u1 = 0,
        padding23: u1 = 0,
        padding24: u1 = 0,
        padding25: u1 = 0,
        padding26: u1 = 0,
        padding27: u1 = 0,
    });
    // byte offset: 60828 Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
    pub const MPU_RBAR = mmio(Address + 0x0000ed9c, 32, packed struct {
        REGION: u4, // bit offset: 0 desc: On writes, specifies the number of the region whose base address to update provided VALID is set written as 1. On reads, returns bits [3:0] of MPU_RNR.
        VALID: u1, // bit offset: 4 desc: On writes, indicates whether the write must update the base address of the region identified by the REGION field, updating the MPU_RNR to indicate this new region.\n Write:\n 0 = MPU_RNR not changed, and the processor:\n Updates the base address for the region specified in the MPU_RNR.\n Ignores the value of the REGION field.\n 1 = The processor:\n Updates the value of the MPU_RNR to the value of the REGION field.\n Updates the base address for the region specified in the REGION field.\n Always reads as zero.
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        reserved2: u1 = 0,
        ADDR: u24, // bit offset: 8 desc: Base address of the region.
    });
    // byte offset: 60832 Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
    pub const MPU_RASR = mmio(Address + 0x0000eda0, 32, packed struct {
        ENABLE: u1, // bit offset: 0 desc: Enables the region.
        SIZE: u5, // bit offset: 1 desc: Indicates the region size. Region size in bytes = 2^(SIZE+1). The minimum permitted value is 7 (b00111) = 256Bytes
        reserved0: u1 = 0,
        reserved1: u1 = 0,
        SRD: u8, // bit offset: 8 desc: Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled.
        ATTRS: u16, // bit offset: 16 desc: The MPU Region Attribute field. Use to define the region attribute control.\n 28 = XN: Instruction access disable bit:\n 0 = Instruction fetches enabled.\n 1 = Instruction fetches disabled.\n 26:24 = AP: Access permission field\n 18 = S: Shareable bit\n 17 = C: Cacheable bit\n 16 = B: Bufferable bit
    });
};

