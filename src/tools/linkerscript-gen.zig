const std = @import("std");
const build_options = @import("build_options");
const chip = @import("chip");
const micro_linker = @import("microzig-linker");

const target = blk: {
    @setEvalBranchQuota(20_000);

    const t = std.zig.CrossTarget.parse(std.zig.CrossTarget.ParseOptions{
        .arch_os_abi = build_options.microzig_target_triple,
    }) catch unreachable;
    std.debug.assert(t.cpu_arch != null);
    break :blk t;
};

pub fn main() !u8 {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const allocator = &arena.allocator;

    const args = try std.process.argsAlloc(allocator);

    if (args.len < 2) {
        std.log.err("Missing CLI argument. Give the output file name!", .{});
        return 1;
    }

    if (std.fs.path.dirname(args[1])) |dir| {
        try std.fs.cwd().makePath(dir);
    }

    var dest_file = try std.fs.cwd().createFile(args[1], .{});
    defer dest_file.close();

    var writer = dest_file.writer();

    try writer.writeAll("/*\n * This file was auto-generated by microzig\n *\n");
    try writer.print(" * Target CPU:  {s}\n", .{build_options.microzig_cpu_name});
    try writer.print(" * Target Chip: {s}\n", .{build_options.microzig_chip_name});
    try writer.writeAll(" */\n\n");

    try writer.writeAll(
        \\
        // This is not the "true" entry point, but there's no such thing on embedded platforms
        // anyways. This is the logical entrypoint that should be invoked when
        // stack, .data and .bss are set up and the CPU is ready to be used.
        \\ENTRY(microzig_main);
        \\
        \\
    );

    try writer.writeAll("MEMORY\n{\n");
    {
        var counters = [2]usize{ 0, 0 };
        for (chip.memory_regions) |region| {
            // flash (rx!w) : ORIGIN = 0x00000000, LENGTH = 512k

            switch (region.kind) {
                .flash => {
                    try writer.print("  flash{d} (rx!w)", .{counters[0]});
                    counters[0] += 1;
                },
                .ram => {
                    try writer.print("  ram{d}   (rw!x)", .{counters[1]});
                    counters[1] += 1;
                },
                .custom => |custom| {
                    try writer.print("  {s} (", .{custom.name});
                    if (custom.readable) try writer.writeAll("r");
                    if (custom.writeable) try writer.writeAll("w");
                    if (custom.executable) try writer.writeAll("x");

                    if (!custom.readable or !custom.writeable or !custom.executable) {
                        try writer.writeAll("!");
                        if (!custom.readable) try writer.writeAll("r");
                        if (!custom.writeable) try writer.writeAll("w");
                        if (!custom.executable) try writer.writeAll("x");
                    }
                    try writer.writeAll(")");
                },
            }
            try writer.print(" : ORIGIN = 0x{X:0>8}, LENGTH = 0x{X:0>8}\n", .{ region.offset, region.length });
        }
    }

    try writer.writeAll("}\n\nSECTIONS\n{\n");
    {
        if (chip.memory_regions[0].offset == 0x10000000) {
            try writer.writeAll(
                \\  .microzig_rp2040_boot2 ORIGIN(flash0) :
                \\  {
                \\    KEEP(*(.microzig_rp2040_boot2));
                \\    . = ALIGN(256);
                \\  } > flash0
                \\
                \\
            );
        }

        try writer.writeAll(
            \\  .text :
            \\  {
            \\     KEEP(*(microzig_flash_start))
            \\     *(.text*)
            \\  } > flash0
            \\
            \\
        );

        if (target.cpu_arch.? == .arm or target.cpu_arch.? == .thumb) {
            try writer.writeAll(
                \\  .ARM.exidx : {
                \\      *(.ARM.exidx* .gnu.linkonce.armexidx.*)
                \\  } >flash0
                \\
                \\
            );
        }

        try writer.writeAll(
            \\  .data :
            \\  {
            \\     microzig_data_start = .;
            \\     *(.rodata*)
            \\     *(.data*)
            \\     microzig_data_end = .;
            \\  } > ram0 AT> flash0
            \\
            \\  .bss (NOLOAD) :
            \\  {
            \\      microzig_bss_start = .;
            \\      *(.bss*)
            \\      microzig_bss_end = .;
            \\  } > ram0
            \\
            \\  microzig_data_load_start = LOADADDR(.data);
            \\
        );
    }
    try writer.writeAll("}\n");

    // TODO: Assert that the flash can actually hold all data!
    // try writer.writeAll(
    //     \\
    //     \\  ASSERT( (SIZEOF(.text) + SIZEOF(.data) > LENGTH(flash0)), "Error: .text + .data is too large for flash!" );
    //     \\
    // );
    return 0;
}
